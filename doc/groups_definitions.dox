# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2021, Intel Corporation

/** @defgroup containers  Containers*/
/** @defgroup experimental_containers Experimental Containers */

/** @defgroup transactions Transactions
  * This section introduces transaction feature in libpmemobj-cpp.
  *
  * ## General info about transactions
  *
  * The heart of the libpmemobj are transactions, and they are designed to be developer-friendly.
  * Let's take a look at the following snippet:
  *
  * @snippet transaction/transaction.cpp general_tx_example
  *
  * Here is a basic example of how automatic transaction can look like. 
  * After object creation there are few statements which are in a transaction.
  * At the end of scope *tx* object will be destroyed and transaction should be commited.
  *
  * It's worth noticing that @ref pmem::obj::flat_transaction is recommended to use over @ref pmem::obj::basic_transaction.
  * An extra explanation is provided inline an example in @ref pmem::obj::flat_transaction description.
  *
  * Mentioned above transactions are handled through two internal classes:
  * - **manual** transactions has to be committed explicitly, otherwise it will abort.
  * All operations between creating and destroying the transaction
  * object are treated as performed in a transaction block and
  * can be rolled back.
  * The locks are held for the entire duration of the transaction. They
  * are released at the end of the scope, so within the `catch` block,
  * they are already unlocked.
  * More about executing transaction is here: @ref pmem::obj::transaction::run
  * - **automatic** transactions are only available in C++17. All operations
  * between creating and destroying the transaction object are treated as
  * performed in a transaction block and can be rolled back.
  * If you have a C++17 compliant compiler, the automatic transaction will
  * commit and abort automatically depending on the context of object destruction.
  * The locks are held for the entire duration of the transaction. They
  * are released at the end of the scope, so within the `catch` block,
  * they are already unlocked.
  *
  * If you want to read more and see example usages of both, you have to see
  * flat or basic transaction documentation, because each implementation may differ.
  *
  * ## Lifecycle and stages:
  *
  * When you are using transaction API a transaction can be in one of the following states:
  * - *TX_STAGE_NONE*
  * - *TX_STAGE_WORK*
  * - *TX_STAGE_ONCOMMIT*
  * - *TX_STAGE_FINALLY*
  * - *TX_STAGE_ONABORT*
  *
  * This stages also have defined transitions between them in libpmemobj, but
  * in libpmemobj-cpp it's transparent, so please focus on relationship between stages.
  * Look at the diagram below:
  *
  * ![lifecycle](https://pmem.io/assets/lifecycle.png "Transaction lifecycle")
  *
  * To be more familiar with functions used in diagram read:
  * [pmemobj_tx_begin manpage](https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_tx_begin.3.html)
  * If you need to read general information about transaction move to the *Additional sources* section.
  *
  * ## Example of flat_transaction
  * Example of @ref pmem::obj::flat_transaction is listed below with basic explanation inline.
  * @snippet transaction/transaction.cpp tx_nested_struct_example
  * For more examples please look at the examples directory in libpmemobj-cpp repository.
  *
  * ## Additional sources
  * - [blog post about transactions](https://pmem.io/2016/05/25/cpp-07.html)
  * - [blog post about transactional allocations](https://pmem.io/2016/05/19/cpp-06.html)
  */

/** @defgroup allocation Allocation*/
/** @defgroup data_view Data View*/
/** @defgroup synchronization Synchronization Primitives*/
/** @defgroup primitives Primitives*/
/** @defgroup exceptions Exceptions*/
