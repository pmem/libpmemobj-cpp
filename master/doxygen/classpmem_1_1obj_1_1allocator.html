<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::allocator&lt; T, Policy, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git85.g2ab46040</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpmem_1_1obj_1_1allocator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classpmem_1_1obj_1_1allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::allocator&lt; T, Policy, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__allocation.html">Allocation</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>(EXPERIMENTAL) Encapsulates the information about the persistent memory allocation model using PMDK's libpmemobj.  
 <a href="classpmem_1_1obj_1_1allocator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="allocator_8hpp_source.html">libpmemobj++/allocator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pmem::obj::allocator&lt; T, Policy, Traits &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpmem_1_1obj_1_1allocator__inherit__graph.png" border="0" usemap="#apmem_1_1obj_1_1allocator_3_01T_00_01Policy_00_01Traits_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="apmem_1_1obj_1_1allocator_3_01T_00_01Policy_00_01Traits_01_4_inherit__map" id="apmem_1_1obj_1_1allocator_3_01T_00_01Policy_00_01Traits_01_4_inherit__map">
<area shape="rect" title="(EXPERIMENTAL) Encapsulates the information about the persistent memory allocation model using PMDK&#39;s..." alt="" coords="102,95,242,136"/>
<area shape="rect" href="classpmem_1_1obj_1_1standard__alloc__policy.html" title="The allocation policy template for a given type." alt="" coords="5,5,147,47"/>
<area shape="rect" href="classpmem_1_1obj_1_1object__traits.html" title="Encapsulates object specific allocator functionality." alt="" coords="171,13,365,39"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1allocator_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind to a different type.  <a href="structpmem_1_1obj_1_1allocator_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac13987e502feefee8e618209c320361e"><td class="memItemLeft" align="right" valign="top"><a id="ac13987e502feefee8e618209c320361e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename AllocationPolicy::size_type</td></tr>
<tr class="separator:ac13987e502feefee8e618209c320361e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192d59d01709c3d06e2176cc7ace98b"><td class="memItemLeft" align="right" valign="top"><a id="a3192d59d01709c3d06e2176cc7ace98b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename AllocationPolicy::pointer</td></tr>
<tr class="separator:a3192d59d01709c3d06e2176cc7ace98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae464b232f68d88e914581d582ee70886"><td class="memItemLeft" align="right" valign="top"><a id="ae464b232f68d88e914581d582ee70886"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename AllocationPolicy::value_type</td></tr>
<tr class="separator:ae464b232f68d88e914581d582ee70886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27b58262ddccbd74535354f03b83b8"><td class="memItemLeft" align="right" valign="top"><a id="a9c27b58262ddccbd74535354f03b83b8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_void_pointer</b> = <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; const void &gt;</td></tr>
<tr class="separator:a9c27b58262ddccbd74535354f03b83b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb5e1a38a4b9181daa9c34f32b0847b"><td class="memItemLeft" align="right" valign="top"><a id="afcb5e1a38a4b9181daa9c34f32b0847b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bool_type</b> = bool</td></tr>
<tr class="separator:afcb5e1a38a4b9181daa9c34f32b0847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc8d6360ca09a75bda6cdebbfea9f1"><td class="memItemLeft" align="right" valign="top"><a id="a96fc8d6360ca09a75bda6cdebbfea9f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; const value_type &gt;</td></tr>
<tr class="separator:a96fc8d6360ca09a75bda6cdebbfea9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75b24f1244811588d276632316fdc4f"><td class="memItemLeft" align="right" valign="top"><a id="af75b24f1244811588d276632316fdc4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:af75b24f1244811588d276632316fdc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a87e234e3bd5a2e29a45f55746945"><td class="memItemLeft" align="right" valign="top"><a id="ac67a87e234e3bd5a2e29a45f55746945"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:ac67a87e234e3bd5a2e29a45f55746945"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0316f8bc0a2566fb8d092014530129a1"><td class="memItemLeft" align="right" valign="top"><a id="a0316f8bc0a2566fb8d092014530129a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#a0316f8bc0a2566fb8d092014530129a1">allocator</a> ()=default</td></tr>
<tr class="memdesc:a0316f8bc0a2566fb8d092014530129a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted constructor. <br /></td></tr>
<tr class="separator:a0316f8bc0a2566fb8d092014530129a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114931ebb6ca2b8ac01a6ab636be8cc8"><td class="memItemLeft" align="right" valign="top"><a id="a114931ebb6ca2b8ac01a6ab636be8cc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#a114931ebb6ca2b8ac01a6ab636be8cc8">~allocator</a> ()=default</td></tr>
<tr class="memdesc:a114931ebb6ca2b8ac01a6ab636be8cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted destructor. <br /></td></tr>
<tr class="separator:a114931ebb6ca2b8ac01a6ab636be8cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc57cb39e8d37cbcdbcb8d93022efe7c"><td class="memItemLeft" align="right" valign="top"><a id="abc57cb39e8d37cbcdbcb8d93022efe7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#abc57cb39e8d37cbcdbcb8d93022efe7c">allocator</a> (<a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a> const &amp;rhs)</td></tr>
<tr class="memdesc:abc57cb39e8d37cbcdbcb8d93022efe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:abc57cb39e8d37cbcdbcb8d93022efe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab172045532539eda6d818701fb73a30d"><td class="memTemplParams" colspan="2"><a id="ab172045532539eda6d818701fb73a30d"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab172045532539eda6d818701fb73a30d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#ab172045532539eda6d818701fb73a30d">allocator</a> (<a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; U &gt; const &amp;)</td></tr>
<tr class="memdesc:ab172045532539eda6d818701fb73a30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type converting constructor. <br /></td></tr>
<tr class="separator:ab172045532539eda6d818701fb73a30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a2d7c7f4be8da329de7142ff5adbf4"><td class="memTemplParams" colspan="2"><a id="aa9a2d7c7f4be8da329de7142ff5adbf4"></a>
template&lt;typename U , typename P , typename T2 &gt; </td></tr>
<tr class="memitem:aa9a2d7c7f4be8da329de7142ff5adbf4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#aa9a2d7c7f4be8da329de7142ff5adbf4">allocator</a> (<a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; U, P, T2 &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:aa9a2d7c7f4be8da329de7142ff5adbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type converting constructor. <br /></td></tr>
<tr class="separator:aa9a2d7c7f4be8da329de7142ff5adbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ba80d5a80a7f18d689816c334ae3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#a97ba80d5a80a7f18d689816c334ae3dc">allocate</a> (size_type cnt, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr_3_01const_01void_01_4.html">const_void_pointer</a>=0)</td></tr>
<tr class="memdesc:a97ba80d5a80a7f18d689816c334ae3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for cnt objects of type T.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#a97ba80d5a80a7f18d689816c334ae3dc">More...</a><br /></td></tr>
<tr class="separator:a97ba80d5a80a7f18d689816c334ae3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9ce43199d07cbea95de2fc0e552df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#aaf9ce43199d07cbea95de2fc0e552df1">deallocate</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a> <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>, size_type=0)</td></tr>
<tr class="memdesc:aaf9ce43199d07cbea95de2fc0e552df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates storage pointed to p, which must be a value returned by a previous call to allocate that has not been invalidated by an intervening call to deallocate.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#aaf9ce43199d07cbea95de2fc0e552df1">More...</a><br /></td></tr>
<tr class="separator:aaf9ce43199d07cbea95de2fc0e552df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7716374e2114a8e72d0ab54c08ed5a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#a6f7716374e2114a8e72d0ab54c08ed5a">max_size</a> () const</td></tr>
<tr class="memdesc:a6f7716374e2114a8e72d0ab54c08ed5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest value that can meaningfully be passed to <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#a97ba80d5a80a7f18d689816c334ae3dc" title="Allocate storage for cnt objects of type T.">allocate()</a>.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#a6f7716374e2114a8e72d0ab54c08ed5a">More...</a><br /></td></tr>
<tr class="separator:a6f7716374e2114a8e72d0ab54c08ed5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95742ee582bc789f4811766ae12052d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits.html#a95742ee582bc789f4811766ae12052d3">construct</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a> <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>, const_reference t)</td></tr>
<tr class="memdesc:a95742ee582bc789f4811766ae12052d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object at a specific address.  <a href="classpmem_1_1obj_1_1object__traits.html#a95742ee582bc789f4811766ae12052d3">More...</a><br /></td></tr>
<tr class="separator:a95742ee582bc789f4811766ae12052d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d7cc8a0b8ae83717143530b792b5dc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad3d7cc8a0b8ae83717143530b792b5dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits.html#ad3d7cc8a0b8ae83717143530b792b5dc">construct</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a> <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad3d7cc8a0b8ae83717143530b792b5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object at a specific address.  <a href="classpmem_1_1obj_1_1object__traits.html#ad3d7cc8a0b8ae83717143530b792b5dc">More...</a><br /></td></tr>
<tr class="separator:ad3d7cc8a0b8ae83717143530b792b5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7149caf1374071bfe6c6af99bf5d9f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits.html#a7149caf1374071bfe6c6af99bf5d9f3b">destroy</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a> <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>)</td></tr>
<tr class="memdesc:a7149caf1374071bfe6c6af99bf5d9f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an object based on a pointer.  <a href="classpmem_1_1obj_1_1object__traits.html#a7149caf1374071bfe6c6af99bf5d9f3b">More...</a><br /></td></tr>
<tr class="separator:a7149caf1374071bfe6c6af99bf5d9f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9e0c28b3312273692904de7e6298519e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename Tr , typename T2 , typename P2 , typename Tr2 &gt; </td></tr>
<tr class="memitem:a9e0c28b3312273692904de7e6298519e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#a9e0c28b3312273692904de7e6298519e">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T2, P2, Tr2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9e0c28b3312273692904de7e6298519e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="classpmem_1_1obj_1_1allocator.html#a9e0c28b3312273692904de7e6298519e">More...</a><br /></td></tr>
<tr class="separator:a9e0c28b3312273692904de7e6298519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bf077bd33f5423c638bf6d42a0e3ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename Tr , typename OtherAllocator &gt; </td></tr>
<tr class="memitem:a45bf077bd33f5423c638bf6d42a0e3ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html#a45bf077bd33f5423c638bf6d42a0e3ff">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;lhs, const OtherAllocator &amp;rhs)</td></tr>
<tr class="memdesc:a45bf077bd33f5423c638bf6d42a0e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="classpmem_1_1obj_1_1allocator.html#a45bf077bd33f5423c638bf6d42a0e3ff">More...</a><br /></td></tr>
<tr class="separator:a45bf077bd33f5423c638bf6d42a0e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743192610238562786b997b326b05bcf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a743192610238562786b997b326b05bcf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#a743192610238562786b997b326b05bcf">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;, <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T2 &gt; const &amp;)</td></tr>
<tr class="memdesc:a743192610238562786b997b326b05bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#a743192610238562786b997b326b05bcf">More...</a><br /></td></tr>
<tr class="separator:a743192610238562786b997b326b05bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98020734fae7141e5ea0d84934a6aca8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OtherAllocator &gt; </td></tr>
<tr class="memitem:a98020734fae7141e5ea0d84934a6aca8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#a98020734fae7141e5ea0d84934a6aca8">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;, OtherAllocator const &amp;)</td></tr>
<tr class="memdesc:a98020734fae7141e5ea0d84934a6aca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#a98020734fae7141e5ea0d84934a6aca8">More...</a><br /></td></tr>
<tr class="separator:a98020734fae7141e5ea0d84934a6aca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Policy = standard_alloc_policy&lt;T&gt;, typename Traits = object_traits&lt;T&gt;&gt;<br />
class pmem::obj::allocator&lt; T, Policy, Traits &gt;</h3>

<p>(EXPERIMENTAL) Encapsulates the information about the persistent memory allocation model using PMDK's libpmemobj. </p>
<p>This information includes the knowledge of the pointer type, their difference type, the type of the size of objects in this allocation model as well as memory allocation and deallocation primitives. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a97ba80d5a80a7f18d689816c334ae3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ba80d5a80a7f18d689816c334ae3dc">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a> <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">pmem::obj::standard_alloc_policy</a>&lt; T &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr_3_01const_01void_01_4.html">const_void_pointer</a>&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate storage for cnt objects of type T. </p>
<p>Does not construct the objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>the number of objects to allocate memory for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">transaction_out_of_memory</a></td><td>if there is no free memory of requested size. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">transaction_alloc_error</a></td><td>on transactional allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3d7cc8a0b8ae83717143530b792b5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d7cc8a0b8ae83717143530b792b5dc">&#9670;&nbsp;</a></span>construct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1object__traits.html">pmem::obj::object_traits</a>&lt; T &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an object at a specific address. </p>
<p>This should be called only within a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the pointer to where the object will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>parameters passed to the object's constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>exception from T constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95742ee582bc789f4811766ae12052d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95742ee582bc789f4811766ae12052d3">&#9670;&nbsp;</a></span>construct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1object__traits.html">pmem::obj::object_traits</a>&lt; T &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an object at a specific address. </p>
<p>This should be called only within a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the pointer to where the object will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the object reference for copy construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>exception from T constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf9ce43199d07cbea95de2fc0e552df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9ce43199d07cbea95de2fc0e552df1">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">pmem::obj::standard_alloc_policy</a>&lt; T &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates storage pointed to p, which must be a value returned by a previous call to allocate that has not been invalidated by an intervening call to deallocate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>pointer to the memory to be deallocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a></td><td>on transactional free failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7149caf1374071bfe6c6af99bf5d9f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7149caf1374071bfe6c6af99bf5d9f3b">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1object__traits.html">pmem::obj::object_traits</a>&lt; T &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy an object based on a pointer. </p>
<p>This should be called only within a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the pointer to the object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f7716374e2114a8e72d0ab54c08ed5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7716374e2114a8e72d0ab54c08ed5a">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">pmem::obj::standard_alloc_policy</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest value that can meaningfully be passed to <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html#a97ba80d5a80a7f18d689816c334ae3dc" title="Allocate storage for cnt objects of type T.">allocate()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>largest value that can be passed to allocate. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a45bf077bd33f5423c638bf6d42a0e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bf077bd33f5423c638bf6d42a0e3ff">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename Tr , typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherAllocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if allocators are equivalent in terms of deallocation, true otherwise. </dd></dl>

</div>
</div>
<a id="a9e0c28b3312273692904de7e6298519e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0c28b3312273692904de7e6298519e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename Tr , typename T2 , typename P2 , typename Tr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T2, P2, Tr2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allocators are equivalent in terms of deallocation, false otherwise. </dd></dl>

</div>
</div>
<a id="a98020734fae7141e5ea0d84934a6aca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98020734fae7141e5ea0d84934a6aca8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherAllocator const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="section return"><dt>Returns</dt><dd>false. </dd></dl>

</div>
</div>
<a id="a743192610238562786b997b326b05bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743192610238562786b997b326b05bcf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/<a class="el" href="allocator_8hpp_source.html">allocator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
