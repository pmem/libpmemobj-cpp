<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::concurrent_hash_map&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git65.g668e8cb6</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpmem_1_1obj_1_1concurrent__hash__map.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpmem_1_1obj_1_1concurrent__hash__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::concurrent_hash_map&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__containers.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent memory aware implementation of Intel TBB <a href="https://spec.oneapi.io/versions/0.5.0/oneTBB/containers/concurrent_hash_map_cls.html">concurrent_hash_map</a>  
 <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concurrent__hash__map_8hpp_source.html">libpmemobj++/container/concurrent_hash_map.hpp</a>&gt;</code></p>

<p>Inherits concurrent_hash_map_internal::hash_map_base&lt; Key, T, MutexType, ScopedLockType &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1bucket__accessor.html">bucket_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket accessor is to find, rehash, acquire a lock, and access a bucket.  <a href="classpmem_1_1obj_1_1concurrent__hash__map_1_1bucket__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1mutex__vector.html">mutex_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of locks to be unlocked at the destruction time.  <a href="classpmem_1_1obj_1_1concurrent__hash__map_1_1mutex__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1serial__bucket__accessor.html">serial_bucket_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial bucket accessor used to access bucket in a serial operations.  <a href="classpmem_1_1obj_1_1concurrent__hash__map_1_1serial__bucket__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a552d39532fa9a53d4891a6b33ba8eba4"><td class="memItemLeft" align="right" valign="top"><a id="a552d39532fa9a53d4891a6b33ba8eba4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename concurrent_hash_map_internal::hash_map_base&lt; Key, T, MutexType, ScopedLockType &gt;::size_type</td></tr>
<tr class="separator:a552d39532fa9a53d4891a6b33ba8eba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eba698e613daa0047be27cf06b5f5b4"><td class="memItemLeft" align="right" valign="top"><a id="a9eba698e613daa0047be27cf06b5f5b4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashcode_type</b> = typename concurrent_hash_map_internal::hash_map_base&lt; Key, T, MutexType, ScopedLockType &gt;::hashcode_type</td></tr>
<tr class="separator:a9eba698e613daa0047be27cf06b5f5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94d6747e506dfab8a3b7f8b5b7eddb"><td class="memItemLeft" align="right" valign="top"><a id="a0e94d6747e506dfab8a3b7f8b5b7eddb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="separator:a0e94d6747e506dfab8a3b7f8b5b7eddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7cb0b3705a1186c1a173cabe1b714"><td class="memItemLeft" align="right" valign="top"><a id="a19f7cb0b3705a1186c1a173cabe1b714"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = T</td></tr>
<tr class="separator:a19f7cb0b3705a1186c1a173cabe1b714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c93b0b0923adc90efef12f1132ee907"><td class="memItemLeft" align="right" valign="top"><a id="a8c93b0b0923adc90efef12f1132ee907"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename concurrent_hash_map_internal::hash_map_base&lt; Key, T, MutexType, ScopedLockType &gt;::node::value_type</td></tr>
<tr class="separator:a8c93b0b0923adc90efef12f1132ee907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dafe49ecdf0057afa9e61b06ddc930e"><td class="memItemLeft" align="right" valign="top"><a id="a1dafe49ecdf0057afa9e61b06ddc930e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = ptrdiff_t</td></tr>
<tr class="separator:a1dafe49ecdf0057afa9e61b06ddc930e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095049a2ca7df9078e5c0003f61eaa8e"><td class="memItemLeft" align="right" valign="top"><a id="a095049a2ca7df9078e5c0003f61eaa8e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = value_type *</td></tr>
<tr class="separator:a095049a2ca7df9078e5c0003f61eaa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268af3f5edfc1137cd3943080132957d"><td class="memItemLeft" align="right" valign="top"><a id="a268af3f5edfc1137cd3943080132957d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const value_type *</td></tr>
<tr class="separator:a268af3f5edfc1137cd3943080132957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c78886dd83278a5d4b9b565bdbf3fe"><td class="memItemLeft" align="right" valign="top"><a id="a66c78886dd83278a5d4b9b565bdbf3fe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a66c78886dd83278a5d4b9b565bdbf3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1e5172d3e4a3cd6fcb4e9ab6c707e1"><td class="memItemLeft" align="right" valign="top"><a id="abf1e5172d3e4a3cd6fcb4e9ab6c707e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:abf1e5172d3e4a3cd6fcb4e9ab6c707e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11edd4ed1f9e72eb22c3de65b4ca8a15"><td class="memItemLeft" align="right" valign="top"><a id="a11edd4ed1f9e72eb22c3de65b4ca8a15"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = concurrent_hash_map_internal::hash_map_iterator&lt; <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>, false &gt;</td></tr>
<tr class="separator:a11edd4ed1f9e72eb22c3de65b4ca8a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7d66581a5f670a32d13267b863a8eb"><td class="memItemLeft" align="right" valign="top"><a id="a4d7d66581a5f670a32d13267b863a8eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = concurrent_hash_map_internal::hash_map_iterator&lt; <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>, true &gt;</td></tr>
<tr class="separator:a4d7d66581a5f670a32d13267b863a8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f6a65eafe1226df544360078578193"><td class="memItemLeft" align="right" valign="top"><a id="ab5f6a65eafe1226df544360078578193"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = Hash</td></tr>
<tr class="separator:ab5f6a65eafe1226df544360078578193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690bda7ecc105dead313a9eae3a9397d"><td class="memItemLeft" align="right" valign="top"><a id="a690bda7ecc105dead313a9eae3a9397d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = typename concurrent_hash_map_internal::key_equal_type&lt; Hash, KeyEqual &gt;::type</td></tr>
<tr class="separator:a690bda7ecc105dead313a9eae3a9397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9eb2a2a8c193cc8b4141a1540bd5f1db"><td class="memItemLeft" align="right" valign="top"><a id="a9eb2a2a8c193cc8b4141a1540bd5f1db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9eb2a2a8c193cc8b4141a1540bd5f1db">concurrent_hash_map</a> ()</td></tr>
<tr class="memdesc:a9eb2a2a8c193cc8b4141a1540bd5f1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty table. <br /></td></tr>
<tr class="separator:a9eb2a2a8c193cc8b4141a1540bd5f1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af413fb72ac263c4c72edccdf0123a973"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#af413fb72ac263c4c72edccdf0123a973">concurrent_hash_map</a> (size_type n)</td></tr>
<tr class="memdesc:af413fb72ac263c4c72edccdf0123a973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty table with n preallocated buckets.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#af413fb72ac263c4c72edccdf0123a973">More...</a><br /></td></tr>
<tr class="separator:af413fb72ac263c4c72edccdf0123a973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320249891ddc52c45458b2902c086bb"><td class="memItemLeft" align="right" valign="top"><a id="af320249891ddc52c45458b2902c086bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#af320249891ddc52c45458b2902c086bb">concurrent_hash_map</a> (const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;table)</td></tr>
<tr class="memdesc:af320249891ddc52c45458b2902c086bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:af320249891ddc52c45458b2902c086bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44e64ad87adcd2c7c45368deec80d7e"><td class="memItemLeft" align="right" valign="top"><a id="ad44e64ad87adcd2c7c45368deec80d7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#ad44e64ad87adcd2c7c45368deec80d7e">concurrent_hash_map</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;&amp;table)</td></tr>
<tr class="memdesc:ad44e64ad87adcd2c7c45368deec80d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:ad44e64ad87adcd2c7c45368deec80d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0960e708cdaed8368f3a1192403c846"><td class="memTemplParams" colspan="2"><a id="aa0960e708cdaed8368f3a1192403c846"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:aa0960e708cdaed8368f3a1192403c846"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aa0960e708cdaed8368f3a1192403c846">concurrent_hash_map</a> (I first, I last)</td></tr>
<tr class="memdesc:aa0960e708cdaed8368f3a1192403c846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction table with copying iteration range. <br /></td></tr>
<tr class="separator:aa0960e708cdaed8368f3a1192403c846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e66209a73f1839ad11c6a77c80be42"><td class="memItemLeft" align="right" valign="top"><a id="ac8e66209a73f1839ad11c6a77c80be42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#ac8e66209a73f1839ad11c6a77c80be42">concurrent_hash_map</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:ac8e66209a73f1839ad11c6a77c80be42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct table with initializer list. <br /></td></tr>
<tr class="separator:ac8e66209a73f1839ad11c6a77c80be42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ca0393b5537618390728c764544a2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#af1ca0393b5537618390728c764544a2e">runtime_initialize</a> ()</td></tr>
<tr class="memdesc:af1ca0393b5537618390728c764544a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize persistent concurrent hash map after process restart.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#af1ca0393b5537618390728c764544a2e">More...</a><br /></td></tr>
<tr class="separator:af1ca0393b5537618390728c764544a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39148a573f6ed2009885b97f13f5538"><td class="memItemLeft" align="right" valign="top"><a id="ac39148a573f6ed2009885b97f13f5538"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_initialize</b> (bool graceful_shutdown)</td></tr>
<tr class="separator:ac39148a573f6ed2009885b97f13f5538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cef0fd273e35db65f8247a851792df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a43cef0fd273e35db65f8247a851792df">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;table)</td></tr>
<tr class="memdesc:a43cef0fd273e35db65f8247a851792df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Not thread safe.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a43cef0fd273e35db65f8247a851792df">More...</a><br /></td></tr>
<tr class="separator:a43cef0fd273e35db65f8247a851792df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6170c8fb3fc6ae98fd251c4b32fbf28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#ac6170c8fb3fc6ae98fd251c4b32fbf28">operator=</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:ac6170c8fb3fc6ae98fd251c4b32fbf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Not thread safe.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#ac6170c8fb3fc6ae98fd251c4b32fbf28">More...</a><br /></td></tr>
<tr class="separator:ac6170c8fb3fc6ae98fd251c4b32fbf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0d57542ac5e239ef908a2740216ad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a6b0d57542ac5e239ef908a2740216ad2">rehash</a> (size_type n=0)</td></tr>
<tr class="memdesc:a6b0d57542ac5e239ef908a2740216ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehashes and optionally resizes the whole table.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a6b0d57542ac5e239ef908a2740216ad2">More...</a><br /></td></tr>
<tr class="separator:a6b0d57542ac5e239ef908a2740216ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595cebdbdb8c398fc1819810c0c1fb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a595cebdbdb8c398fc1819810c0c1fb6d">clear</a> ()</td></tr>
<tr class="memdesc:a595cebdbdb8c398fc1819810c0c1fb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear hash map content Not thread safe.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a595cebdbdb8c398fc1819810c0c1fb6d">More...</a><br /></td></tr>
<tr class="separator:a595cebdbdb8c398fc1819810c0c1fb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfa5210cdb1478e396abd30079e75db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a5bfa5210cdb1478e396abd30079e75db">free_data</a> ()</td></tr>
<tr class="memdesc:a5bfa5210cdb1478e396abd30079e75db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a>.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a5bfa5210cdb1478e396abd30079e75db">More...</a><br /></td></tr>
<tr class="separator:a5bfa5210cdb1478e396abd30079e75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c9f358e07869c1db977f9ef53110e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a52c9f358e07869c1db977f9ef53110e9">~concurrent_hash_map</a> ()</td></tr>
<tr class="memdesc:a52c9f358e07869c1db977f9ef53110e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">free_data should be called before <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a> destructor is called.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a52c9f358e07869c1db977f9ef53110e9">More...</a><br /></td></tr>
<tr class="separator:a52c9f358e07869c1db977f9ef53110e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f6e9c07c17e495e4f30795b489baae"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a61f6e9c07c17e495e4f30795b489baae">begin</a> ()</td></tr>
<tr class="separator:a61f6e9c07c17e495e4f30795b489baae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220b355c69455540d727273fab4e74c6"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a220b355c69455540d727273fab4e74c6">end</a> ()</td></tr>
<tr class="separator:a220b355c69455540d727273fab4e74c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4799242ff6e1c952e6080949a76f53b0"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a4799242ff6e1c952e6080949a76f53b0">begin</a> () const</td></tr>
<tr class="separator:a4799242ff6e1c952e6080949a76f53b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073b006ced36f5522a3ff6eddf07d782"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a073b006ced36f5522a3ff6eddf07d782">end</a> () const</td></tr>
<tr class="separator:a073b006ced36f5522a3ff6eddf07d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee3ca27184f2269b66b4a931dc2bef8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a4ee3ca27184f2269b66b4a931dc2bef8">size</a> () const</td></tr>
<tr class="separator:a4ee3ca27184f2269b66b4a931dc2bef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01df888ef5e52616a7dc0b716ca5df17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a01df888ef5e52616a7dc0b716ca5df17">empty</a> () const</td></tr>
<tr class="separator:a01df888ef5e52616a7dc0b716ca5df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9a7ab9997031886f471ddde1a6b7f1"><td class="memItemLeft" align="right" valign="top"><a id="a9f9a7ab9997031886f471ddde1a6b7f1"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9f9a7ab9997031886f471ddde1a6b7f1">max_size</a> () const</td></tr>
<tr class="memdesc:a9f9a7ab9997031886f471ddde1a6b7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper bound on size. <br /></td></tr>
<tr class="separator:a9f9a7ab9997031886f471ddde1a6b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bf7627c35886e4461c1e4925cb0668"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a26bf7627c35886e4461c1e4925cb0668">bucket_count</a> () const</td></tr>
<tr class="separator:a26bf7627c35886e4461c1e4925cb0668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bd24c69feb5210ee752dc95e062987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a61bd24c69feb5210ee752dc95e062987">swap</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;table)</td></tr>
<tr class="memdesc:a61bd24c69feb5210ee752dc95e062987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two instances.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a61bd24c69feb5210ee752dc95e062987">More...</a><br /></td></tr>
<tr class="separator:a61bd24c69feb5210ee752dc95e062987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e39fc5b4319660dea3626685276e78"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a45e39fc5b4319660dea3626685276e78">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a45e39fc5b4319660dea3626685276e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875d9173c9c46b1ccbc907d30b0d7a06"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </td></tr>
<tr class="memitem:a875d9173c9c46b1ccbc907d30b0d7a06"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a875d9173c9c46b1ccbc907d30b0d7a06">count</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a875d9173c9c46b1ccbc907d30b0d7a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload only participates in overload resolution if the qualified-id Hash::transparent_key_equal is valid and denotes a type.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a875d9173c9c46b1ccbc907d30b0d7a06">More...</a><br /></td></tr>
<tr class="separator:a875d9173c9c46b1ccbc907d30b0d7a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442339a16de9b2b28bfb319186a6bca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a442339a16de9b2b28bfb319186a6bca8">find</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;result, const Key &amp;key) const</td></tr>
<tr class="memdesc:a442339a16de9b2b28bfb319186a6bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a442339a16de9b2b28bfb319186a6bca8">More...</a><br /></td></tr>
<tr class="separator:a442339a16de9b2b28bfb319186a6bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7691a64fa90bc502da756a5af899b2a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </td></tr>
<tr class="memitem:aa7691a64fa90bc502da756a5af899b2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aa7691a64fa90bc502da756a5af899b2a">find</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;result, const K &amp;key) const</td></tr>
<tr class="memdesc:aa7691a64fa90bc502da756a5af899b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#aa7691a64fa90bc502da756a5af899b2a">More...</a><br /></td></tr>
<tr class="separator:aa7691a64fa90bc502da756a5af899b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0f6b2a5caa0bb160e1cc1307d474b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a3a0f6b2a5caa0bb160e1cc1307d474b5">find</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>
<tr class="memdesc:a3a0f6b2a5caa0bb160e1cc1307d474b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a3a0f6b2a5caa0bb160e1cc1307d474b5">More...</a><br /></td></tr>
<tr class="separator:a3a0f6b2a5caa0bb160e1cc1307d474b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c29fc066dd61996d9d35b28f71807b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </td></tr>
<tr class="memitem:a94c29fc066dd61996d9d35b28f71807b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a94c29fc066dd61996d9d35b28f71807b">find</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;result, const K &amp;key)</td></tr>
<tr class="memdesc:a94c29fc066dd61996d9d35b28f71807b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a94c29fc066dd61996d9d35b28f71807b">More...</a><br /></td></tr>
<tr class="separator:a94c29fc066dd61996d9d35b28f71807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dbd0a198de4bdd2ee05fd7d78d7b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aa6dbd0a198de4bdd2ee05fd7d78d7b83">insert</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;result, const Key &amp;key)</td></tr>
<tr class="memdesc:aa6dbd0a198de4bdd2ee05fd7d78d7b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item (if not already present) and acquire a read lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#aa6dbd0a198de4bdd2ee05fd7d78d7b83">More...</a><br /></td></tr>
<tr class="separator:aa6dbd0a198de4bdd2ee05fd7d78d7b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae303e98457fb155f45f299e86f7454d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#ae303e98457fb155f45f299e86f7454d0">insert</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>
<tr class="memdesc:ae303e98457fb155f45f299e86f7454d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item (if not already present) and acquire a write lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#ae303e98457fb155f45f299e86f7454d0">More...</a><br /></td></tr>
<tr class="separator:ae303e98457fb155f45f299e86f7454d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9672cd28747ecc81ee86729639aea619"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9672cd28747ecc81ee86729639aea619">insert</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;result, const value_type &amp;value)</td></tr>
<tr class="memdesc:a9672cd28747ecc81ee86729639aea619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9672cd28747ecc81ee86729639aea619">More...</a><br /></td></tr>
<tr class="separator:a9672cd28747ecc81ee86729639aea619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b0e925e6b1a0029a849d8c16e4759"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a987b0e925e6b1a0029a849d8c16e4759">insert</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;result, const value_type &amp;value)</td></tr>
<tr class="memdesc:a987b0e925e6b1a0029a849d8c16e4759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a987b0e925e6b1a0029a849d8c16e4759">More...</a><br /></td></tr>
<tr class="separator:a987b0e925e6b1a0029a849d8c16e4759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d68ccf746ec0c312365fd36d09d241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a51d68ccf746ec0c312365fd36d09d241">insert</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:a51d68ccf746ec0c312365fd36d09d241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a51d68ccf746ec0c312365fd36d09d241">More...</a><br /></td></tr>
<tr class="separator:a51d68ccf746ec0c312365fd36d09d241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5098ef8b17d61ece83398c724794a83c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a5098ef8b17d61ece83398c724794a83c">insert</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;result, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a5098ef8b17d61ece83398c724794a83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a5098ef8b17d61ece83398c724794a83c">More...</a><br /></td></tr>
<tr class="separator:a5098ef8b17d61ece83398c724794a83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9c170158aca8fd28f26befda080833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a3a9c170158aca8fd28f26befda080833">insert</a> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;result, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a3a9c170158aca8fd28f26befda080833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a3a9c170158aca8fd28f26befda080833">More...</a><br /></td></tr>
<tr class="separator:a3a9c170158aca8fd28f26befda080833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c673b6a3961cbe801e81186638b0c2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9c673b6a3961cbe801e81186638b0c2b">insert</a> (value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a9c673b6a3961cbe801e81186638b0c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9c673b6a3961cbe801e81186638b0c2b">More...</a><br /></td></tr>
<tr class="separator:a9c673b6a3961cbe801e81186638b0c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf85c810e76c2c5c2dba09b0160bd945"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:adf85c810e76c2c5c2dba09b0160bd945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#adf85c810e76c2c5c2dba09b0160bd945">insert</a> (I first, I last)</td></tr>
<tr class="memdesc:adf85c810e76c2c5c2dba09b0160bd945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert range [first, last)  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#adf85c810e76c2c5c2dba09b0160bd945">More...</a><br /></td></tr>
<tr class="separator:adf85c810e76c2c5c2dba09b0160bd945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b253de73883188f578ddad2ef88838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a32b253de73883188f578ddad2ef88838">insert</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a32b253de73883188f578ddad2ef88838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert initializer list.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a32b253de73883188f578ddad2ef88838">More...</a><br /></td></tr>
<tr class="separator:a32b253de73883188f578ddad2ef88838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded92bc959c27193d8a4b966171a3a19"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:aded92bc959c27193d8a4b966171a3a19"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aded92bc959c27193d8a4b966171a3a19">insert_or_assign</a> (const key_type &amp;key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aded92bc959c27193d8a4b966171a3a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts item if there is no such key present already, assigns provided value otherwise.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#aded92bc959c27193d8a4b966171a3a19">More...</a><br /></td></tr>
<tr class="separator:aded92bc959c27193d8a4b966171a3a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdefd9e84690758cc0c6803e1be1cf0"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:aebdefd9e84690758cc0c6803e1be1cf0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aebdefd9e84690758cc0c6803e1be1cf0">insert_or_assign</a> (key_type &amp;&amp;key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aebdefd9e84690758cc0c6803e1be1cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts item if there is no such key present already, assigns provided value otherwise.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#aebdefd9e84690758cc0c6803e1be1cf0">More...</a><br /></td></tr>
<tr class="separator:aebdefd9e84690758cc0c6803e1be1cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eac81173be23680ca9d7ce613133e4c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename M , typename  = typename std::enable_if&lt;			concurrent_hash_map_internal::has_transparent_key_equal&lt;				hasher&gt;::value &amp;&amp;				std::is_constructible&lt;key_type, K&gt;::value,			K&gt;::type&gt; </td></tr>
<tr class="memitem:a7eac81173be23680ca9d7ce613133e4c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a7eac81173be23680ca9d7ce613133e4c">insert_or_assign</a> (K &amp;&amp;key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a7eac81173be23680ca9d7ce613133e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts item if there is no such key-comparable type present already, assigns provided value otherwise.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a7eac81173be23680ca9d7ce613133e4c">More...</a><br /></td></tr>
<tr class="separator:a7eac81173be23680ca9d7ce613133e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab79cba29a999871cfccf94fd6e203d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9ab79cba29a999871cfccf94fd6e203d">erase</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a9ab79cba29a999871cfccf94fd6e203d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element with corresponding key.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9ab79cba29a999871cfccf94fd6e203d">More...</a><br /></td></tr>
<tr class="separator:a9ab79cba29a999871cfccf94fd6e203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd573b5dd87d540652e9c63e9e195fd1"><td class="memItemLeft" align="right" valign="top">pobj_defrag_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#afd573b5dd87d540652e9c63e9e195fd1">defragment</a> (double start_percent=0, double amount_percent=100)</td></tr>
<tr class="memdesc:afd573b5dd87d540652e9c63e9e195fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defragment the given (by 'start_percent' and 'amount_percent') part of buckets of the hash map.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#afd573b5dd87d540652e9c63e9e195fd1">More...</a><br /></td></tr>
<tr class="separator:afd573b5dd87d540652e9c63e9e195fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad791334f451c680e445ba7be9a833de7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </td></tr>
<tr class="memitem:ad791334f451c680e445ba7be9a833de7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#ad791334f451c680e445ba7be9a833de7">erase</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ad791334f451c680e445ba7be9a833de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element with corresponding key.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#ad791334f451c680e445ba7be9a833de7">More...</a><br /></td></tr>
<tr class="separator:ad791334f451c680e445ba7be9a833de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a61af55d39eb356fe06e0740e2d0e7a29"><td class="memItemLeft" align="right" valign="top"><a id="a61af55d39eb356fe06e0740e2d0e7a29"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_t</b> = MutexType</td></tr>
<tr class="separator:a61af55d39eb356fe06e0740e2d0e7a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb49ccf677f8b573829a00ae9390b47"><td class="memItemLeft" align="right" valign="top"><a id="a5bb49ccf677f8b573829a00ae9390b47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>scoped_t</b> = ScopedLockType</td></tr>
<tr class="separator:a5bb49ccf677f8b573829a00ae9390b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcef1f656ac49a3d8859bd2df861ad69"><td class="memItemLeft" align="right" valign="top"><a id="abcef1f656ac49a3d8859bd2df861ad69"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hash_map_base</b> = concurrent_hash_map_internal::hash_map_base&lt; Key, T, mutex_t, scoped_t &gt;</td></tr>
<tr class="separator:abcef1f656ac49a3d8859bd2df861ad69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f62228263aa1f1b10d2c336b36c250e"><td class="memItemLeft" align="right" valign="top"><a id="a6f62228263aa1f1b10d2c336b36c250e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tls_t</b> = typename hash_map_base::tls_t</td></tr>
<tr class="separator:a6f62228263aa1f1b10d2c336b36c250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a91cd51eea0b658e0a02719e45b9cf"><td class="memItemLeft" align="right" valign="top"><a id="a28a91cd51eea0b658e0a02719e45b9cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node</b> = typename hash_map_base::node</td></tr>
<tr class="separator:a28a91cd51eea0b658e0a02719e45b9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58504ad4874d4742c6038a08ebb2d5d2"><td class="memItemLeft" align="right" valign="top"><a id="a58504ad4874d4742c6038a08ebb2d5d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_mutex_t</b> = typename node::mutex_t</td></tr>
<tr class="separator:a58504ad4874d4742c6038a08ebb2d5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9d403663ab149a41ada7862d10ea23"><td class="memItemLeft" align="right" valign="top"><a id="a7f9d403663ab149a41ada7862d10ea23"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr_t</b> = typename hash_map_base::node_ptr_t</td></tr>
<tr class="separator:a7f9d403663ab149a41ada7862d10ea23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18d9d3d8a1d2d22450bc799c5320100"><td class="memItemLeft" align="right" valign="top"><a id="ad18d9d3d8a1d2d22450bc799c5320100"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket</b> = typename hash_map_base::bucket</td></tr>
<tr class="separator:ad18d9d3d8a1d2d22450bc799c5320100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6a8aeeee6fc70b012737d2b9758559"><td class="memItemLeft" align="right" valign="top"><a id="adb6a8aeeee6fc70b012737d2b9758559"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_lock_type</b> = typename bucket::scoped_t</td></tr>
<tr class="separator:adb6a8aeeee6fc70b012737d2b9758559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2608bae528bc6157cbea482b4eb99b"><td class="memItemLeft" align="right" valign="top"><a id="a7f2608bae528bc6157cbea482b4eb99b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>segment_index_t</b> = typename hash_map_base::segment_index_t</td></tr>
<tr class="separator:a7f2608bae528bc6157cbea482b4eb99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1696431093f6278acdb6858eeaeb6b7f"><td class="memItemLeft" align="right" valign="top"><a id="a1696431093f6278acdb6858eeaeb6b7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>segment_traits_t</b> = typename hash_map_base::segment_traits_t</td></tr>
<tr class="separator:a1696431093f6278acdb6858eeaeb6b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a46cda69e4dedbc193037427fbfe8e4"><td class="memItemLeft" align="right" valign="top"><a id="a5a46cda69e4dedbc193037427fbfe8e4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>segment_facade_t</b> = typename hash_map_base::segment_facade_t</td></tr>
<tr class="separator:a5a46cda69e4dedbc193037427fbfe8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c91677098607b05c6e6c1ce60506514"><td class="memItemLeft" align="right" valign="top"><a id="a4c91677098607b05c6e6c1ce60506514"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>scoped_lock_traits_type</b> = concurrent_hash_map_internal::scoped_lock_traits&lt; scoped_t &gt;</td></tr>
<tr class="separator:a4c91677098607b05c6e6c1ce60506514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb820950345384ec48fef45443aa062a"><td class="memItemLeft" align="right" valign="top"><a id="adb820950345384ec48fef45443aa062a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>persistent_node_ptr_t</b> = detail::persistent_pool_ptr&lt; node &gt;</td></tr>
<tr class="separator:adb820950345384ec48fef45443aa062a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1bbc63762baa9dda628c890f18cbe951"><td class="memItemLeft" align="right" valign="top"><a id="a1bbc63762baa9dda628c890f18cbe951"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_node</b> (const node_ptr_t &amp;n)</td></tr>
<tr class="separator:a1bbc63762baa9dda628c890f18cbe951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9971206b929c87d0566c1a24898c3d"><td class="memTemplParams" colspan="2"><a id="abc9971206b929c87d0566c1a24898c3d"></a>
template&lt;typename K &gt; </td></tr>
<tr class="memitem:abc9971206b929c87d0566c1a24898c3d"><td class="memTemplItemLeft" align="right" valign="top">persistent_node_ptr_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>search_bucket</b> (const K &amp;key, bucket *b) const</td></tr>
<tr class="separator:abc9971206b929c87d0566c1a24898c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159c8c9d1ed1c9cbd4e571e464bffd43"><td class="memItemLeft" align="right" valign="top"><a id="a159c8c9d1ed1c9cbd4e571e464bffd43"></a>
hashcode_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_hash_code</b> (node_ptr_t &amp;n)</td></tr>
<tr class="separator:a159c8c9d1ed1c9cbd4e571e464bffd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81a42e90eb16b9594290da175a72a05"><td class="memTemplParams" colspan="2"><a id="ad81a42e90eb16b9594290da175a72a05"></a>
template&lt;bool serial&gt; </td></tr>
<tr class="memitem:ad81a42e90eb16b9594290da175a72a05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rehash_bucket</b> (bucket *b_new, const hashcode_type h)</td></tr>
<tr class="separator:ad81a42e90eb16b9594290da175a72a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17fb9f66fa218dc17e8a505c855eda6"><td class="memItemLeft" align="right" valign="top"><a id="aa17fb9f66fa218dc17e8a505c855eda6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_incompat_features</b> ()</td></tr>
<tr class="separator:aa17fb9f66fa218dc17e8a505c855eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4f69d2e6647ae1a48e04c041cf76d7"><td class="memItemLeft" align="right" valign="top"><a id="aae4f69d2e6647ae1a48e04c041cf76d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>try_acquire_item</b> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> *result, node_mutex_t &amp;<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a>, bool write)</td></tr>
<tr class="separator:aae4f69d2e6647ae1a48e04c041cf76d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab603cc1e2be565af03997979dc49c5c4"><td class="memTemplParams" colspan="2"><a id="ab603cc1e2be565af03997979dc49c5c4"></a>
template&lt;typename K &gt; </td></tr>
<tr class="memitem:ab603cc1e2be565af03997979dc49c5c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal_find</b> (const K &amp;key, <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> *result, bool write)</td></tr>
<tr class="separator:ab603cc1e2be565af03997979dc49c5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5d4f96fdc9725cd56cc1da996b826e"><td class="memTemplParams" colspan="2"><a id="a6c5d4f96fdc9725cd56cc1da996b826e"></a>
template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a6c5d4f96fdc9725cd56cc1da996b826e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal_insert</b> (const K &amp;key, <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> *result, bool write, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6c5d4f96fdc9725cd56cc1da996b826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eda04ec35865ca09ac7b5242d490ef"><td class="memTemplParams" colspan="2"><a id="a85eda04ec35865ca09ac7b5242d490ef"></a>
template&lt;bool Bucket_rw_lock, typename K &gt; </td></tr>
<tr class="memitem:a85eda04ec35865ca09ac7b5242d490ef"><td class="memTemplItemLeft" align="right" valign="top">persistent_node_ptr_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_node</b> (const K &amp;key, <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1bucket__accessor.html">bucket_accessor</a> &amp;b)</td></tr>
<tr class="separator:a85eda04ec35865ca09ac7b5242d490ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f091d6487bca2b69a879a459359d8bb"><td class="memTemplParams" colspan="2"><a id="a4f091d6487bca2b69a879a459359d8bb"></a>
template&lt;typename K &gt; </td></tr>
<tr class="memitem:a4f091d6487bca2b69a879a459359d8bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal_erase</b> (const K &amp;key)</td></tr>
<tr class="separator:a4f091d6487bca2b69a879a459359d8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe96de19caace1aba31831bfd3a73ba"><td class="memItemLeft" align="right" valign="top"><a id="aebe96de19caace1aba31831bfd3a73ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_segment</b> (segment_index_t s)</td></tr>
<tr class="separator:aebe96de19caace1aba31831bfd3a73ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9e7ffb5390d7994e724ea7ce2fda22"><td class="memItemLeft" align="right" valign="top"><a id="aac9e7ffb5390d7994e724ea7ce2fda22"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aac9e7ffb5390d7994e724ea7ce2fda22">internal_copy</a> (const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> &amp;source)</td></tr>
<tr class="memdesc:aac9e7ffb5390d7994e724ea7ce2fda22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy "source" to *this, where *this must start out empty. <br /></td></tr>
<tr class="separator:aac9e7ffb5390d7994e724ea7ce2fda22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d1de076d525d07a7308134f034635e"><td class="memTemplParams" colspan="2"><a id="a14d1de076d525d07a7308134f034635e"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:a14d1de076d525d07a7308134f034635e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal_copy</b> (I first, I last)</td></tr>
<tr class="separator:a14d1de076d525d07a7308134f034635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854c72fb2c1466b7f7e5fc26cf94f374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a854c72fb2c1466b7f7e5fc26cf94f374">defrag_save_nodes</a> (bucket *b, <a class="el" href="classpmem_1_1obj_1_1defrag.html">pmem::obj::defrag</a> &amp;<a class="el" href="classpmem_1_1obj_1_1defrag.html">defrag</a>)</td></tr>
<tr class="memdesc:a854c72fb2c1466b7f7e5fc26cf94f374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#afd573b5dd87d540652e9c63e9e195fd1" title="Defragment the given (by &#39;start_percent&#39; and &#39;amount_percent&#39;) part of buckets of the hash map.">defragment()</a>.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#a854c72fb2c1466b7f7e5fc26cf94f374">More...</a><br /></td></tr>
<tr class="separator:a854c72fb2c1466b7f7e5fc26cf94f374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0c92175688973e4ae138835c70653705"><td class="memTemplParams" colspan="2"><a id="a0c92175688973e4ae138835c70653705"></a>
template&lt;typename Container , bool is_const&gt; </td></tr>
<tr class="memitem:a0c92175688973e4ae138835c70653705"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concurrent_hash_map_internal::hash_map_iterator</b></td></tr>
<tr class="separator:a0c92175688973e4ae138835c70653705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584bf754a8408612d4bfd33a3eafd80d"><td class="memItemLeft" align="right" valign="top"><a id="a584bf754a8408612d4bfd33a3eafd80d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_accessor</b></td></tr>
<tr class="separator:a584bf754a8408612d4bfd33a3eafd80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T, typename Hash, typename KeyEqual, typename MutexType, typename ScopedLockType&gt;<br />
class pmem::obj::concurrent_hash_map&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;</h3>

<p>Persistent memory aware implementation of Intel TBB <a href="https://spec.oneapi.io/versions/0.5.0/oneTBB/containers/concurrent_hash_map_cls.html">concurrent_hash_map</a> </p>
<p>The implementation is based on a concurrent hash table algorithm (<a href="https://arxiv.org/ftp/arxiv/papers/1509/1509.02235.pdf">https://arxiv.org/ftp/arxiv/papers/1509/1509.02235.pdf</a>) where elements are assigned to buckets based on a hash code calculated from a key. In addition to concurrent find, insert, and erase operations, the algorithm employs resizing and on-demand per-bucket rehashing. The hash table consists of an array of buckets, and each bucket consists of a list of nodes and a read-write lock to control concurrent access by multiple threads.</p>
<p>There's no STL counterpart for this container (only the TBB's implementation).</p>
<p>Each time, the pool with <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a> is being opened, the <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a> requires <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#af1ca0393b5537618390728c764544a2e" title="Initialize persistent concurrent hash map after process restart.">runtime_initialize()</a> to be called (in order to recalculate mask and restore the size).</p>
<p><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a442339a16de9b2b28bfb319186a6bca8" title="Find item and acquire a read lock on the item.">find()</a>, <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#aa6dbd0a198de4bdd2ee05fd7d78d7b83" title="Insert item (if not already present) and acquire a read lock on the item.">insert()</a>, <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a9ab79cba29a999871cfccf94fd6e203d" title="Remove element with corresponding key.">erase()</a> (and all overloads) are guaranteed to be thread-safe.</p>
<p>When a thread holds accessor to an element with a certain key, it is not allowed to call find, insert nor erase with that key.</p>
<p>MutexType defines type of read write lock used in <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a>. ScopedLockType defines a mutex wrapper that provides RAII-style mechanism for owning a mutex. It should implement following methods and constructors: ScopedLockType() ScopedLockType(rw_mutex_type &amp;m, bool write = true) void acquire(rw_mutex_type &amp;m, bool write) void release() bool try_acquire(rw_mutex_type &amp;m, bool write)</p>
<p>and optionally: bool upgrade_to_writer() bool downgrade_to_reader() bool is_writer (variable)</p>
<p>Implementing all optional methods and supplying is_writer variable can improve performance if MutexType supports efficient upgrading and downgrading operations.</p>
<dl class="section note"><dt>Note</dt><dd>In some cases, when testing with Valgrind, helgrind and drd might report lock ordering errors. This might happen when calling find, insert or erase while already holding an accessor to some element.</dd></dl>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concurrent__hash__map_8hpp.html">libpmemobj++/container/concurrent_hash_map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="p_8hpp.html">libpmemobj++/p.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* In this example we use concurrent_hash_map with p&lt;int&gt; type as</span></div>
<div class="line"><span class="comment"> * both key and value. */</span></div>
<div class="line"><span class="keyword">using</span> hashmap_type = concurrent_hash_map&lt;p&lt;int&gt;, p&lt;int&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> THREADS_NUM = 30;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* This is basic example and we only need to use concurrent_hash_map. Hence we</span></div>
<div class="line"><span class="comment"> * correlate memory pool root object with a single instance of persistent</span></div>
<div class="line"><span class="comment"> * pointer to hashmap_type. */</span></div>
<div class="line"><span class="keyword">struct </span>root {</div>
<div class="line">    persistent_ptr&lt;hashmap_type&gt; pptr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Before running this example, run:</span></div>
<div class="line"><span class="comment"> * pmempool create obj --layout=&quot;concurrent_hash_map&quot; --size 1G path_to_a_pool</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    pool&lt;root&gt; pop;</div>
<div class="line">    <span class="keywordtype">bool</span> remove_hashmap = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (argc &lt; 2)</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0]</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; file-name [remove_hashmap]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> path = argv[1];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (argc == 3)</div>
<div class="line">        remove_hashmap = <a class="code" href="group__containers.html#ga0d1bf59e796791b4e701e11d5e364cbc">std::string</a>(argv[2]) == <span class="stringliteral">&quot;1&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pool&lt;root&gt;::open</a>(path, <span class="stringliteral">&quot;concurrent_hash_map&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1pool__error.html">pmem::pool_error</a> &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keyword">auto</span> &amp;r = pop.root()-&gt;pptr;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (r == <span class="keyword">nullptr</span>) {</div>
<div class="line">            <span class="comment">/* Logic when file was first opened. First, we have to</span></div>
<div class="line"><span class="comment">             * allocate object of hashmap_type and attach it to the</span></div>
<div class="line"><span class="comment">             * root object. */</span></div>
<div class="line">            <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                r = make_persistent&lt;hashmap_type&gt;();</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">            r-&gt;runtime_initialize();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">/* Logic when hash_map already exists. After opening of</span></div>
<div class="line"><span class="comment">             * the pool we have to call runtime_initialize()</span></div>
<div class="line"><span class="comment">             * function in order to recalculate mask and check for</span></div>
<div class="line"><span class="comment">             * consistency. */</span></div>
<div class="line"> </div>
<div class="line">            r-&gt;runtime_initialize();</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Defragment the whole pool at the beginning. */</span></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                r-&gt;defragment();</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1defrag__error.html">pmem::defrag_error</a> &amp;e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span></div>
<div class="line">                      &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> &amp;map = *r;</div>
<div class="line">        std::cout &lt;&lt; map.size() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::thread&gt; threads;</div>
<div class="line">        threads.reserve(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(THREADS_NUM));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Start THREADS_NUM/3 threads to insert key-value pairs</span></div>
<div class="line"><span class="comment">         * to the hashmap. This operation is thread-safe. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; THREADS_NUM / 3; ++i) {</div>
<div class="line">            threads.emplace_back([&amp;]() {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10 * THREADS_NUM; ++i) {</div>
<div class="line">                    map.insert(</div>
<div class="line">                        hashmap_type::value_type(i, i));</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Start THREADS_NUM/3 threads to erase key-value pairs</span></div>
<div class="line"><span class="comment">         * from the hashmap. This operation is thread-safe. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; THREADS_NUM / 3; ++i) {</div>
<div class="line">            threads.emplace_back([&amp;]() {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10 * THREADS_NUM; ++i) {</div>
<div class="line">                    map.erase(i);</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Start THREADS_NUM/3 threads to check if given key is</span></div>
<div class="line"><span class="comment">         * in the hashmap. For the time of an accessor life,</span></div>
<div class="line"><span class="comment">         * the read-write lock is taken on the item. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; THREADS_NUM / 3; ++i) {</div>
<div class="line">            threads.emplace_back([&amp;]() {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10 * THREADS_NUM; ++i) {</div>
<div class="line">                    hashmap_type::accessor acc;</div>
<div class="line">                    <span class="keywordtype">bool</span> res = map.find(acc, i);</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span> (res) {</div>
<div class="line">                        assert(acc-&gt;first == i);</div>
<div class="line">                        assert(acc-&gt;second &gt;= i);</div>
<div class="line">                        acc-&gt;second.get_rw() += 1;</div>
<div class="line">                        pop.persist(acc-&gt;second);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;t : threads) {</div>
<div class="line">            t.join();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">/* Defragment the whole pool at the end. */</span></div>
<div class="line">            map.defragment();</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1defrag__error.html">pmem::defrag_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1lock__error.html">pmem::lock_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::range_error &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (remove_hashmap) {</div>
<div class="line">            <span class="comment">/* Firstly, erase remaining items in the map. This</span></div>
<div class="line"><span class="comment">             * function is not thread-safe, hence the function is</span></div>
<div class="line"><span class="comment">             * being called only after thread execution has</span></div>
<div class="line"><span class="comment">             * completed. */</span></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                map.clear();</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1transaction__out__of__memory.html">pmem::transaction_out_of_memory</a> &amp;e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Clear exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                      &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a> &amp;e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Clear exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                      &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If hash map is to be removed, free_data() method</span></div>
<div class="line"><span class="comment">             * should be called first. Otherwise, if deallocating</span></div>
<div class="line"><span class="comment">             * internal hash map metadata in a destructor fails</span></div>
<div class="line"><span class="comment">             * program might terminate. */</span></div>
<div class="line">            map.free_data();</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* map.clear() // WRONG</span></div>
<div class="line"><span class="comment">             * After free_data() hash map cannot be used anymore! */</span></div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                delete_persistent&lt;hashmap_type&gt;(r);</div>
<div class="line">                r = <span class="keyword">nullptr</span>;</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1transaction__out__of__memory.html">pmem::transaction_out_of_memory</a> &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (std::exception &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        pop.close();</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::logic_error &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1defrag__error_html"><div class="ttname"><a href="classpmem_1_1defrag__error.html">pmem::defrag_error</a></div><div class="ttdoc">Custom defrag error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:209</div></div>
<div class="ttc" id="aclasspmem_1_1lock__error_html"><div class="ttname"><a href="classpmem_1_1lock__error.html">pmem::lock_error</a></div><div class="ttdoc">Custom lock error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:118</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_a9564707de1779ca1bce7041fb7c9855c"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::basic_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:676</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a1dcc1ec8833d4a9215ce3b6d24f51a79"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pmem::obj::pool::open</a></div><div class="ttdeci">static pool&lt; T &gt; open(const std::string &amp;path, const std::string &amp;layout)</div><div class="ttdoc">Opens an existing object store memory pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:672</div></div>
<div class="ttc" id="aclasspmem_1_1pool__error_html"><div class="ttname"><a href="classpmem_1_1pool__error.html">pmem::pool_error</a></div><div class="ttdoc">Custom pool error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:84</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__free__error_html"><div class="ttname"><a href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:153</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__out__of__memory_html"><div class="ttname"><a href="classpmem_1_1transaction__out__of__memory.html">pmem::transaction_out_of_memory</a></div><div class="ttdoc">Custom out of memory error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:141</div></div>
<div class="ttc" id="aconcurrent__hash__map_8hpp_html"><div class="ttname"><a href="concurrent__hash__map_8hpp.html">concurrent_hash_map.hpp</a></div><div class="ttdoc">A persistent version of concurrent hash map implementation Ref: https://arxiv.org/abs/1509....</div></div>
<div class="ttc" id="agroup__containers_html_ga0d1bf59e796791b4e701e11d5e364cbc"><div class="ttname"><a href="group__containers.html#ga0d1bf59e796791b4e701e11d5e364cbc">pmem::obj::string</a></div><div class="ttdeci">basic_string&lt; char &gt; string</div><div class="ttdoc">The most typical string usage - the char specialization.</div><div class="ttdef"><b>Definition:</b> string.hpp:24</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="ap_8hpp_html"><div class="ttname"><a href="p_8hpp.html">p.hpp</a></div><div class="ttdoc">Resides on pmem property template.</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
</div><!-- fragment --><p> The example of storing strings without necessity of using transactions would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concurrent__hash__map_8hpp.html">libpmemobj++/container/concurrent_hash_map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">libpmemobj++/container/string.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="p_8hpp.html">libpmemobj++/p.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* In this example we use concurrent_hash_map with p&lt;int&gt; type as</span></div>
<div class="line"><span class="comment"> * keys and pmem::obj::string type for values. It shows, there is no need to</span></div>
<div class="line"><span class="comment"> * explicitly use transacions if strings are stored in concurrent_hash_map. */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> hashmap_type =</div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map&lt;pmem::obj::p&lt;int&gt;</a>, <a class="code" href="classpmem_1_1obj_1_1basic__string.html">pmem::obj::string</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> THREADS_NUM = 30;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* In this example we need to place concurrent_hash_map in the pool. Hence</span></div>
<div class="line"><span class="comment"> * correlate memory pool root object with a single instance of persistent</span></div>
<div class="line"><span class="comment"> * pointer to hashmap_type */</span></div>
<div class="line"><span class="keyword">struct </span>root {</div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr&lt;hashmap_type&gt;</a> pptr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool&lt;root&gt;</a> pop;</div>
<div class="line">    <span class="keywordtype">bool</span> remove_hashmap = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">int</span> retval = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (argc &lt; 2) {</div>
<div class="line">            std::cerr</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0]</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot; file-name [remove_hashmap]&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Before running this example, run:&quot;</span></div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;pmempool create obj --layout=\&quot;cmap_string\&quot; --size 1G path_to_a_pool&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> -1;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> path = argv[1];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (argc == 3)</div>
<div class="line">            remove_hashmap = <a class="code" href="group__containers.html#ga0d1bf59e796791b4e701e11d5e364cbc">std::string</a>(argv[2]) == <span class="stringliteral">&quot;1&quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pmem::obj::pool&lt;root&gt;::open</a>(path, <span class="stringliteral">&quot;cmap_string&quot;</span>);</div>
<div class="line">        } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1pool__error.html">pmem::pool_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> -1;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> &amp;r = pop.<a class="code" href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">root</a>()-&gt;pptr;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (r == <span class="keyword">nullptr</span>) {</div>
<div class="line">            <span class="comment">/* Logic when file was first opened. First, we have to</span></div>
<div class="line"><span class="comment">             * allocate object of hashmap_type and attach it to the</span></div>
<div class="line"><span class="comment">             * root object. */</span></div>
<div class="line">            <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                r = pmem::obj::make_persistent&lt;hashmap_type&gt;();</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">            r-&gt;runtime_initialize();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">/* Logic when hash_map already exists. After opening of</span></div>
<div class="line"><span class="comment">             * the pool we have to call runtime_initialize()</span></div>
<div class="line"><span class="comment">             * function in order to recalculate mask and check for</span></div>
<div class="line"><span class="comment">             * consistency. */</span></div>
<div class="line">            r-&gt;runtime_initialize();</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Defragment the whole pool at the beginning */</span></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                r-&gt;defragment();</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1defrag__error.html">pmem::defrag_error</a> &amp;e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span></div>
<div class="line">                      &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> &amp;map = *r;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Number of elements at application startup: &quot;</span></div>
<div class="line">              &lt;&lt; map.size() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::thread&gt; threads;</div>
<div class="line">        threads.reserve(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(THREADS_NUM));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Start THREADS_NUM/3 threads to insert key-value pairs</span></div>
<div class="line"><span class="comment">         * to the hashmap. This operation is thread-safe. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; THREADS_NUM / 3; ++j) {</div>
<div class="line">            threads.emplace_back([&amp;]() {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10 * THREADS_NUM; ++i) {</div>
<div class="line">                    <span class="comment">/* Implicit conversion from std::string</span></div>
<div class="line"><span class="comment">                     * to pmem::obj::string. */</span></div>
<div class="line">                    map.insert_or_assign(i,</div>
<div class="line">                                 std::to_string(i));</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Start THREADS_NUM/3 threads to check if given key is</span></div>
<div class="line"><span class="comment">         * in the hashmap. For the time of an accessor life,</span></div>
<div class="line"><span class="comment">         * the read-write lock is taken on the item. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; THREADS_NUM / 3; ++j) {</div>
<div class="line">            threads.emplace_back([&amp;]() {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10 * THREADS_NUM; ++i) {</div>
<div class="line">                    <span class="comment">/* Usage of const_accessor, indicates</span></div>
<div class="line"><span class="comment">                     * read-only access */</span></div>
<div class="line">                    hashmap_type::const_accessor acc;</div>
<div class="line">                    <span class="keywordtype">bool</span> res = map.find(acc, i);</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span> (res) {</div>
<div class="line">                        assert(acc-&gt;first == i);</div>
<div class="line">                        <span class="comment">/* Pointer to the value may be</span></div>
<div class="line"><span class="comment">                         * used as long as the accessor</span></div>
<div class="line"><span class="comment">                         * object exists. */</span></div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classpmem_1_1obj_1_1basic__string.html">pmem::obj::string</a></div>
<div class="line">                            *element = &amp;acc-&gt;second;</div>
<div class="line">                        std::cout &lt;&lt; element-&gt;<a class="code" href="classpmem_1_1obj_1_1basic__string.html#ad1038c13c40f765ffa5bc0c5c2e84022">c_str</a>()</div>
<div class="line">                              &lt;&lt; std::endl;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Start THREADS_NUM/3 threads to erase key-value pairs</span></div>
<div class="line"><span class="comment">         * from the hashmap. This operation is thread-safe. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; THREADS_NUM / 3; ++j) {</div>
<div class="line">            threads.emplace_back([&amp;]() {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10 * THREADS_NUM; ++i) {</div>
<div class="line">                    map.erase(i);</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;t : threads) {</div>
<div class="line">            t.join();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">/* Defragment the whole pool at the end */</span></div>
<div class="line">            map.defragment();</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1defrag__error.html">pmem::defrag_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1lock__error.html">pmem::lock_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::range_error &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Defragmentation exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (remove_hashmap) {</div>
<div class="line">            <span class="comment">/* Firstly, erase remaining items in the map. This</span></div>
<div class="line"><span class="comment">             * function is not thread-safe, hence the function is</span></div>
<div class="line"><span class="comment">             * being called only after thread execution has</span></div>
<div class="line"><span class="comment">             * completed. */</span></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                map.clear();</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1transaction__out__of__memory.html">pmem::transaction_out_of_memory</a> &amp;e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Clear exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                      &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a> &amp;e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Clear exception: &quot;</span> &lt;&lt; e.what()</div>
<div class="line">                      &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If hash map is to be removed, free_data() method</span></div>
<div class="line"><span class="comment">             * should be called first. Otherwise, if deallocating</span></div>
<div class="line"><span class="comment">             * internal hash map metadata in a destructor fails</span></div>
<div class="line"><span class="comment">             * program might terminate. */</span></div>
<div class="line">            map.free_data();</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* map.clear() // WRONG</span></div>
<div class="line"><span class="comment">             * After free_data() concurrent hash map cannot be used</span></div>
<div class="line"><span class="comment">             * anymore! */</span></div>
<div class="line"> </div>
<div class="line">            <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                pmem::obj::delete_persistent&lt;hashmap_type&gt;(r);</div>
<div class="line">                r = <span class="keyword">nullptr</span>;</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classpmem_1_1transaction__out__of__memory.html">pmem::transaction_out_of_memory</a> &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        retval = -127;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        retval = -1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        pop.<a class="code" href="classpmem_1_1obj_1_1pool__base.html#a54af0122ce7be0754305b7b27f4e2fc6">close</a>();</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::logic_error &amp;e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        retval = -2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> retval;</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__string_html"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__string.html">pmem::obj::basic_string</a></div><div class="ttdoc">Persistent string container with std::basic_string compatible interface.</div><div class="ttdef"><b>Definition:</b> basic_string.hpp:48</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__string_html_ad1038c13c40f765ffa5bc0c5c2e84022"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__string.html#ad1038c13c40f765ffa5bc0c5c2e84022">pmem::obj::basic_string::c_str</a></div><div class="ttdeci">const CharT * c_str() const noexcept</div><div class="ttdef"><b>Definition:</b> basic_string.hpp:3687</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1concurrent__hash__map_html"><div class="ttname"><a href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a></div><div class="ttdoc">Persistent memory aware implementation of Intel TBB concurrent_hash_map</div><div class="ttdef"><b>Definition:</b> concurrent_hash_map.hpp:1633</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr_html"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a></div><div class="ttdoc">Persistent pointer class.</div><div class="ttdef"><b>Definition:</b> persistent_ptr.hpp:153</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool__base_html_a54af0122ce7be0754305b7b27f4e2fc6"><div class="ttname"><a href="classpmem_1_1obj_1_1pool__base.html#a54af0122ce7be0754305b7b27f4e2fc6">pmem::obj::pool_base::close</a></div><div class="ttdeci">void close()</div><div class="ttdoc">Closes the pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:256</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a></div><div class="ttdoc">PMEMobj pool class.</div><div class="ttdef"><b>Definition:</b> pool.hpp:482</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a85b71b78e8229b009639835a5ad159d2"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">pmem::obj::pool::root</a></div><div class="ttdeci">persistent_ptr&lt; T &gt; root()</div><div class="ttdoc">Retrieves pool's root object.</div><div class="ttdef"><b>Definition:</b> pool.hpp:644</div></div>
<div class="ttc" id="astring_8hpp_html"><div class="ttname"><a href="string_8hpp.html">string.hpp</a></div><div class="ttdoc">String typedefs for common character types.</div></div>
</div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af413fb72ac263c4c72edccdf0123a973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af413fb72ac263c4c72edccdf0123a973">&#9670;&nbsp;</a></span>concurrent_hash_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct empty table with n preallocated buckets. </p>
<p>This number serves also as initial concurrency level. </p>

</div>
</div>
<a id="a52c9f358e07869c1db977f9ef53110e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c9f358e07869c1db977f9ef53110e9">&#9670;&nbsp;</a></span>~concurrent_hash_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::~<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>free_data should be called before <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a> destructor is called. </p>
<p>Otherwise, program can terminate if an exception occurs while freeing memory inside dtor.</p>
<p>Hash map can NOT be used after <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a5bfa5210cdb1478e396abd30079e75db" title="Destroys the concurrent_hash_map.">free_data()</a> was called (unless it was called in a transaction and that transaction aborted). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61f6e9c07c17e495e4f30795b489baae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f6e9c07c17e495e4f30795b489baae">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator to the beginning Not thread safe.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4799242ff6e1c952e6080949a76f53b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4799242ff6e1c952e6080949a76f53b0">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator to the beginning Not thread safe. </dd></dl>

</div>
</div>
<a id="a26bf7627c35886e4461c1e4925cb0668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bf7627c35886e4461c1e4925cb0668">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current number of buckets </dd></dl>

</div>
</div>
<a id="a595cebdbdb8c398fc1819810c0c1fb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595cebdbdb8c398fc1819810c0c1fb6d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear hash map content Not thread safe. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>in case of PMDK transaction failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a875d9173c9c46b1ccbc907d30b0d7a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875d9173c9c46b1ccbc907d30b0d7a06">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This overload only participates in overload resolution if the qualified-id Hash::transparent_key_equal is valid and denotes a type. </p>
<p>This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of Key</p>
<dl class="section return"><dt>Returns</dt><dd>count of items (0 or 1)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e39fc5b4319660dea3626685276e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e39fc5b4319660dea3626685276e78">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>count of items (0 or 1)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854c72fb2c1466b7f7e5fc26cf94f374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854c72fb2c1466b7f7e5fc26cf94f374">&#9670;&nbsp;</a></span>defrag_save_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::defrag_save_nodes </td>
          <td>(</td>
          <td class="paramtype">bucket *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1defrag.html">pmem::obj::defrag</a> &amp;&#160;</td>
          <td class="paramname"><em>defrag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#afd573b5dd87d540652e9c63e9e195fd1" title="Defragment the given (by &#39;start_percent&#39; and &#39;amount_percent&#39;) part of buckets of the hash map.">defragment()</a>. </p>
<p>Adds nodes to the defragmentation list. </p>

</div>
</div>
<a id="afd573b5dd87d540652e9c63e9e195fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd573b5dd87d540652e9c63e9e195fd1">&#9670;&nbsp;</a></span>defragment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pobj_defrag_result <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::defragment </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start_percent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amount_percent</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defragment the given (by 'start_percent' and 'amount_percent') part of buckets of the hash map. </p>
<p>The algorithm is 'opportunistic' - if it is not able to lock a bucket it will just skip it.</p>
<dl class="section return"><dt>Returns</dt><dd>result struct containing a number of relocated and total processed objects.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::range_error</td><td>if the range: [start_percent, start_percent + amount_percent] is incorrect.</td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1defrag__error.html" title="Custom defrag error class.">pmem::defrag_error</a></td><td>rethrows <a class="el" href="classpmem_1_1defrag__error.html" title="Custom defrag error class.">defrag_error</a> when a failure during defragmentation occurs. Even if this error is thrown, some of objects could have been relocated, see in such case <a class="el" href="classpmem_1_1defrag__error.html#a1a50dcf9b7eec99e293bd3cdc3f876b7" title="Results of the defragmentation run.">defrag_error.result</a> for summary stats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01df888ef5e52616a7dc0b716ca5df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01df888ef5e52616a7dc0b716ca5df17">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a4ee3ca27184f2269b66b4a931dc2bef8">size()</a>==0. </dd></dl>

</div>
</div>
<a id="a220b355c69455540d727273fab4e74c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220b355c69455540d727273fab4e74c6">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end Not thread safe. </dd></dl>

</div>
</div>
<a id="a073b006ced36f5522a3ff6eddf07d782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073b006ced36f5522a3ff6eddf07d782">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end Not thread safe. </dd></dl>

</div>
</div>
<a id="ad791334f451c680e445ba7be9a833de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad791334f451c680e445ba7be9a833de7">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element with corresponding key. </p>
<p>This overload only participates in overload resolution if the qualified-id Hash::transparent_key_equal is valid and denotes a type. This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of Key</p>
<dl class="section return"><dt>Returns</dt><dd>true if element was deleted by this call </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>in case of PMDK unable to free the memory </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab79cba29a999871cfccf94fd6e203d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab79cba29a999871cfccf94fd6e203d">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element with corresponding key. </p>
<dl class="section return"><dt>Returns</dt><dd>true if element was deleted by this call </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>in case of PMDK unable to free the memory </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94c29fc066dd61996d9d35b28f71807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c29fc066dd61996d9d35b28f71807b">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find item and acquire a write lock on the item. </p>
<p>This overload only participates in overload resolution if the qualified-id Hash::transparent_key_equal is valid and denotes a type. This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of Key</p>
<dl class="section return"><dt>Returns</dt><dd>true if item is found, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a0f6b2a5caa0bb160e1cc1307d474b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0f6b2a5caa0bb160e1cc1307d474b5">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find item and acquire a write lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is found, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7691a64fa90bc502da756a5af899b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7691a64fa90bc502da756a5af899b2a">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  concurrent_hash_map_internal::				  has_transparent_key_equal&lt;hasher&gt;::value,			  K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find item and acquire a read lock on the item. </p>
<p>This overload only participates in overload resolution if the qualified-id Hash::transparent_key_equal is valid and denotes a type. This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of Key</p>
<dl class="section return"><dt>Returns</dt><dd>true if item is found, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a442339a16de9b2b28bfb319186a6bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442339a16de9b2b28bfb319186a6bca8">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find item and acquire a read lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is found, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bfa5210cdb1478e396abd30079e75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfa5210cdb1478e396abd30079e75db">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a>. </p>
<p>Unlike destructor it will throw an exception in case of any failure (e.g. not enough space for a transactional data). If that happens, it might be necessary to free some other data in the pool.</p>
<p>Should be called before <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map">concurrent_hash_map</a> destructor is called. Otherwise, program can terminate if an exception occurs while freeing memory inside dtor.</p>
<p>Hash map can NOT be used after <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html#a5bfa5210cdb1478e396abd30079e75db" title="Destroys the concurrent_hash_map.">free_data()</a> was called (unless this was done in a transaction and transaction aborted).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::transaction_error</td><td>in case of PMDK transaction failure </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae303e98457fb155f45f299e86f7454d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae303e98457fb155f45f299e86f7454d0">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item (if not already present) and acquire a write lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is new. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a987b0e925e6b1a0029a849d8c16e4759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987b0e925e6b1a0029a849d8c16e4759">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a write lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is new.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a9c170158aca8fd28f26befda080833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9c170158aca8fd28f26befda080833">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1accessor.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a write lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is new. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51d68ccf746ec0c312365fd36d09d241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d68ccf746ec0c312365fd36d09d241">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is inserted.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6dbd0a198de4bdd2ee05fd7d78d7b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dbd0a198de4bdd2ee05fd7d78d7b83">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item (if not already present) and acquire a read lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is new. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9672cd28747ecc81ee86729639aea619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9672cd28747ecc81ee86729639aea619">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a read lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is new. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5098ef8b17d61ece83398c724794a83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5098ef8b17d61ece83398c724794a83c">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map_1_1const__accessor.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a read lock on the item. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is new. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf85c810e76c2c5c2dba09b0160bd945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf85c810e76c2c5c2dba09b0160bd945">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert range [first, last) </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b253de73883188f578ddad2ef88838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b253de73883188f578ddad2ef88838">&#9670;&nbsp;</a></span>insert() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert initializer list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c673b6a3961cbe801e81186638b0c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c673b6a3961cbe801e81186638b0c2b">&#9670;&nbsp;</a></span>insert() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already. </p>
<dl class="section return"><dt>Returns</dt><dd>true if item is inserted. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aded92bc959c27193d8a4b966171a3a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded92bc959c27193d8a4b966171a3a19">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts item if there is no such key present already, assigns provided value otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>return true if the insertion took place and false if the assignment took place. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eac81173be23680ca9d7ce613133e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eac81173be23680ca9d7ce613133e4c">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename M , typename  = typename std::enable_if&lt;			concurrent_hash_map_internal::has_transparent_key_equal&lt;				hasher&gt;::value &amp;&amp;				std::is_constructible&lt;key_type, K&gt;::value,			K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts item if there is no such key-comparable type present already, assigns provided value otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>return true if the insertion took place and false if the assignment took place. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebdefd9e84690758cc0c6803e1be1cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdefd9e84690758cc0c6803e1be1cf0">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts item if there is no such key present already, assigns provided value otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>return true if the insertion took place and false if the assignment took place. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>on allocation failure. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43cef0fd273e35db65f8247a851792df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cef0fd273e35db65f8247a851792df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&amp; <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment Not thread safe. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::transaction_error</td><td>in case of PMDK transaction failure </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor's exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6170c8fb3fc6ae98fd251c4b32fbf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6170c8fb3fc6ae98fd251c4b32fbf28">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&amp; <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment Not thread safe. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::transaction_error</td><td>in case of PMDK transaction failure </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor's exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0d57542ac5e239ef908a2740216ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0d57542ac5e239ef908a2740216ad2">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rehashes and optionally resizes the whole table. </p>
<p>Useful to optimize performance before or after concurrent operations. Not thread safe.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1ca0393b5537618390728c764544a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ca0393b5537618390728c764544a2e">&#9670;&nbsp;</a></span>runtime_initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::runtime_initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize persistent concurrent hash map after process restart. </p>
<p>MUST be called every time after process restart. Not thread safe.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1layout__error.html" title="Custom layout error class.">pmem::layout_error</a></td><td>if hashmap was created using incompatible version of libpmemobj-cpp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ee3ca27184f2269b66b4a931dc2bef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee3ca27184f2269b66b4a931dc2bef8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of items in table. </dd></dl>

</div>
</div>
<a id="a61bd24c69feb5210ee752dc95e062987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bd24c69feb5210ee752dc95e062987">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two instances. </p>
<p>Iterators are invalidated. Not thread safe. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/container/<a class="el" href="concurrent__hash__map_8hpp_source.html">concurrent_hash_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
