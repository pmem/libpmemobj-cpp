<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::condition_variable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git107.g7e59f08f</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpmem_1_1obj_1_1condition__variable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1condition__variable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::condition_variable Class Reference<div class="ingroups"><a class="el" href="group__synchronization.html">Synchronization Primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent memory resident condition variable.  
 <a href="classpmem_1_1obj_1_1condition__variable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="condition__variable_8hpp_source.html">libpmemobj++/condition_variable.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5d6f2b49f88a03db9e9f3a2b49f6bf6d"><td class="memItemLeft" align="right" valign="top"><a id="a5d6f2b49f88a03db9e9f3a2b49f6bf6d"></a>
typedef PMEMcond *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a5d6f2b49f88a03db9e9f3a2b49f6bf6d">native_handle_type</a></td></tr>
<tr class="memdesc:a5d6f2b49f88a03db9e9f3a2b49f6bf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle typedef to the underlying basic type. <br /></td></tr>
<tr class="separator:a5d6f2b49f88a03db9e9f3a2b49f6bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f35240b1f5ab91e74f41a46628d588b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a4f35240b1f5ab91e74f41a46628d588b">condition_variable</a> ()</td></tr>
<tr class="memdesc:a4f35240b1f5ab91e74f41a46628d588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classpmem_1_1obj_1_1condition__variable.html#a4f35240b1f5ab91e74f41a46628d588b">More...</a><br /></td></tr>
<tr class="separator:a4f35240b1f5ab91e74f41a46628d588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c1d8e61ca3913f79257ff09094c694"><td class="memItemLeft" align="right" valign="top"><a id="a02c1d8e61ca3913f79257ff09094c694"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a02c1d8e61ca3913f79257ff09094c694">~condition_variable</a> ()=default</td></tr>
<tr class="memdesc:a02c1d8e61ca3913f79257ff09094c694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted destructor. <br /></td></tr>
<tr class="separator:a02c1d8e61ca3913f79257ff09094c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bb6885b36cd6b24961e33c5a184db9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#ae8bb6885b36cd6b24961e33c5a184db9">notify_one</a> ()</td></tr>
<tr class="memdesc:ae8bb6885b36cd6b24961e33c5a184db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify and unblock one thread waiting on <code>*this</code> condition.  <a href="classpmem_1_1obj_1_1condition__variable.html#ae8bb6885b36cd6b24961e33c5a184db9">More...</a><br /></td></tr>
<tr class="separator:ae8bb6885b36cd6b24961e33c5a184db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe698f5498498eaf15251c0bb877405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a7fe698f5498498eaf15251c0bb877405">notify_all</a> ()</td></tr>
<tr class="memdesc:a7fe698f5498498eaf15251c0bb877405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify and unblock all threads waiting on <code>*this</code> condition.  <a href="classpmem_1_1obj_1_1condition__variable.html#a7fe698f5498498eaf15251c0bb877405">More...</a><br /></td></tr>
<tr class="separator:a7fe698f5498498eaf15251c0bb877405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a4af1d034c91723c6c3ef48e059de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#af2a4af1d034c91723c6c3ef48e059de3">wait</a> (<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;lock)</td></tr>
<tr class="memdesc:af2a4af1d034c91723c6c3ef48e059de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or it is woken up by some other measure.  <a href="classpmem_1_1obj_1_1condition__variable.html#af2a4af1d034c91723c6c3ef48e059de3">More...</a><br /></td></tr>
<tr class="separator:af2a4af1d034c91723c6c3ef48e059de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af291e7ea73afea27847266a0d44ddfe1"><td class="memTemplParams" colspan="2">template&lt;typename Lock &gt; </td></tr>
<tr class="memitem:af291e7ea73afea27847266a0d44ddfe1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#af291e7ea73afea27847266a0d44ddfe1">wait</a> (Lock &amp;lock)</td></tr>
<tr class="memdesc:af291e7ea73afea27847266a0d44ddfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or it is woken up by some other measure.  <a href="classpmem_1_1obj_1_1condition__variable.html#af291e7ea73afea27847266a0d44ddfe1">More...</a><br /></td></tr>
<tr class="separator:af291e7ea73afea27847266a0d44ddfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ad0aac624644b783b7d1d1176d159e"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:ad5ad0aac624644b783b7d1d1176d159e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#ad5ad0aac624644b783b7d1d1176d159e">wait</a> (<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;lock, Predicate pred)</td></tr>
<tr class="memdesc:ad5ad0aac624644b783b7d1d1176d159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified.  <a href="classpmem_1_1obj_1_1condition__variable.html#ad5ad0aac624644b783b7d1d1176d159e">More...</a><br /></td></tr>
<tr class="separator:ad5ad0aac624644b783b7d1d1176d159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f14748e16f22057532d1d953b47554"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Predicate &gt; </td></tr>
<tr class="memitem:a05f14748e16f22057532d1d953b47554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a05f14748e16f22057532d1d953b47554">wait</a> (Lock &amp;lock, Predicate pred)</td></tr>
<tr class="memdesc:a05f14748e16f22057532d1d953b47554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified.  <a href="classpmem_1_1obj_1_1condition__variable.html#a05f14748e16f22057532d1d953b47554">More...</a><br /></td></tr>
<tr class="separator:a05f14748e16f22057532d1d953b47554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d1fb0fac201f5d5d851da39a96e80f"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:af9d1fb0fac201f5d5d851da39a96e80f"><td class="memTemplItemLeft" align="right" valign="top">std::cv_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#af9d1fb0fac201f5d5d851da39a96e80f">wait_until</a> (<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:af9d1fb0fac201f5d5d851da39a96e80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure.  <a href="classpmem_1_1obj_1_1condition__variable.html#af9d1fb0fac201f5d5d851da39a96e80f">More...</a><br /></td></tr>
<tr class="separator:af9d1fb0fac201f5d5d851da39a96e80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3ea4df8540d6a6f4861be9f35f7ac2"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:abc3ea4df8540d6a6f4861be9f35f7ac2"><td class="memTemplItemLeft" align="right" valign="top">std::cv_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#abc3ea4df8540d6a6f4861be9f35f7ac2">wait_until</a> (Lock &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:abc3ea4df8540d6a6f4861be9f35f7ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure.  <a href="classpmem_1_1obj_1_1condition__variable.html#abc3ea4df8540d6a6f4861be9f35f7ac2">More...</a><br /></td></tr>
<tr class="separator:abc3ea4df8540d6a6f4861be9f35f7ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16d2eb393b49957e1e34cf9b0972dc7"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration , typename Predicate &gt; </td></tr>
<tr class="memitem:ac16d2eb393b49957e1e34cf9b0972dc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#ac16d2eb393b49957e1e34cf9b0972dc7">wait_until</a> (<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout, Predicate pred)</td></tr>
<tr class="memdesc:ac16d2eb393b49957e1e34cf9b0972dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or a specific time is reached.  <a href="classpmem_1_1obj_1_1condition__variable.html#ac16d2eb393b49957e1e34cf9b0972dc7">More...</a><br /></td></tr>
<tr class="separator:ac16d2eb393b49957e1e34cf9b0972dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d10f30c70bf4dbf7e69e28ec56c4cf"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Clock , typename Duration , typename Predicate &gt; </td></tr>
<tr class="memitem:af9d10f30c70bf4dbf7e69e28ec56c4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#af9d10f30c70bf4dbf7e69e28ec56c4cf">wait_until</a> (Lock &amp;lock, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout, Predicate pred)</td></tr>
<tr class="memdesc:af9d10f30c70bf4dbf7e69e28ec56c4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or a specific time is reached.  <a href="classpmem_1_1obj_1_1condition__variable.html#af9d10f30c70bf4dbf7e69e28ec56c4cf">More...</a><br /></td></tr>
<tr class="separator:af9d10f30c70bf4dbf7e69e28ec56c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798061b7259954e9215e202d8262816f"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a798061b7259954e9215e202d8262816f"><td class="memTemplItemLeft" align="right" valign="top">std::cv_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a798061b7259954e9215e202d8262816f">wait_for</a> (Lock &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a798061b7259954e9215e202d8262816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure.  <a href="classpmem_1_1obj_1_1condition__variable.html#a798061b7259954e9215e202d8262816f">More...</a><br /></td></tr>
<tr class="separator:a798061b7259954e9215e202d8262816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de096677650bbf1debf17dae1c24ec3"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Rep , typename Period , typename Predicate &gt; </td></tr>
<tr class="memitem:a5de096677650bbf1debf17dae1c24ec3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a5de096677650bbf1debf17dae1c24ec3">wait_for</a> (Lock &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Predicate pred)</td></tr>
<tr class="memdesc:a5de096677650bbf1debf17dae1c24ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or the specified amount of time passes.  <a href="classpmem_1_1obj_1_1condition__variable.html#a5de096677650bbf1debf17dae1c24ec3">More...</a><br /></td></tr>
<tr class="separator:a5de096677650bbf1debf17dae1c24ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae277124f54fbe0c4af5cc4d10cccbbca"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:ae277124f54fbe0c4af5cc4d10cccbbca"><td class="memTemplItemLeft" align="right" valign="top">std::cv_status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#ae277124f54fbe0c4af5cc4d10cccbbca">wait_for</a> (<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:ae277124f54fbe0c4af5cc4d10cccbbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure.  <a href="classpmem_1_1obj_1_1condition__variable.html#ae277124f54fbe0c4af5cc4d10cccbbca">More...</a><br /></td></tr>
<tr class="separator:ae277124f54fbe0c4af5cc4d10cccbbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e217260e5656ae0fe130395fec85fba"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename Predicate &gt; </td></tr>
<tr class="memitem:a7e217260e5656ae0fe130395fec85fba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a7e217260e5656ae0fe130395fec85fba">wait_for</a> (<a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;lock, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Predicate pred)</td></tr>
<tr class="memdesc:a7e217260e5656ae0fe130395fec85fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current thread block until the condition variable is notified or the specified amount of time passes.  <a href="classpmem_1_1obj_1_1condition__variable.html#a7e217260e5656ae0fe130395fec85fba">More...</a><br /></td></tr>
<tr class="separator:a7e217260e5656ae0fe130395fec85fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a0e13cb4b1601f1416cca92ac59e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a5d6f2b49f88a03db9e9f3a2b49f6bf6d">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a50a0e13cb4b1601f1416cca92ac59e4c">native_handle</a> () noexcept</td></tr>
<tr class="memdesc:a50a0e13cb4b1601f1416cca92ac59e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a native handle to this condition variable.  <a href="classpmem_1_1obj_1_1condition__variable.html#a50a0e13cb4b1601f1416cca92ac59e4c">More...</a><br /></td></tr>
<tr class="separator:a50a0e13cb4b1601f1416cca92ac59e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07acd157f367291badab5680f71a3893"><td class="memItemLeft" align="right" valign="top"><a id="a07acd157f367291badab5680f71a3893"></a>
<a class="el" href="classpmem_1_1obj_1_1condition__variable.html">condition_variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a07acd157f367291badab5680f71a3893">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1condition__variable.html">condition_variable</a> &amp;)=delete</td></tr>
<tr class="memdesc:a07acd157f367291badab5680f71a3893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted assignment operator. <br /></td></tr>
<tr class="separator:a07acd157f367291badab5680f71a3893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b48f7dc5c7e598127738586a838bc4f"><td class="memItemLeft" align="right" valign="top"><a id="a0b48f7dc5c7e598127738586a838bc4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a0b48f7dc5c7e598127738586a838bc4f">condition_variable</a> (const <a class="el" href="classpmem_1_1obj_1_1condition__variable.html">condition_variable</a> &amp;)=delete</td></tr>
<tr class="memdesc:a0b48f7dc5c7e598127738586a838bc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor. <br /></td></tr>
<tr class="separator:a0b48f7dc5c7e598127738586a838bc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Persistent memory resident condition variable. </p>
<p>This class is an implementation of a PMEM-resident condition variable which mimics in behavior the C++11 <a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a>. The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="condition__variable_8hpp.html">libpmemobj++/condition_variable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">cond_var_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1mutex.html">pmem::obj::mutex</a> pmutex;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1condition__variable.html">pmem::obj::condition_variable</a> cond;</div>
<div class="line">        <span class="keywordtype">int</span> counter;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>,</div>
<div class="line">                         PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* run worker to bump up the counter */</span></div>
<div class="line">    std::thread worker([&amp;] {</div>
<div class="line">        std::unique_lock&lt;pmem::obj::mutex&gt; lock(proot-&gt;pmutex);</div>
<div class="line">        <span class="keywordflow">while</span> (proot-&gt;counter &lt; 1000)</div>
<div class="line">            ++proot-&gt;counter;</div>
<div class="line">        <span class="comment">/* unlock before notifying to avoid blocking on waiting thread</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        lock.unlock();</div>
<div class="line">        <span class="comment">/* notify the waiting thread */</span></div>
<div class="line">        proot-&gt;cond.notify_one();</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    std::unique_lock&lt;pmem::obj::mutex&gt; lock(proot-&gt;pmutex);</div>
<div class="line">    <span class="comment">/* wait on condition variable */</span></div>
<div class="line">    proot-&gt;cond.wait(lock, [&amp;] { <span class="keywordflow">return</span> proot-&gt;counter &gt;= 1000; });</div>
<div class="line"> </div>
<div class="line">    worker.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1condition__variable_html"><div class="ttname"><a href="classpmem_1_1obj_1_1condition__variable.html">pmem::obj::condition_variable</a></div><div class="ttdoc">Persistent memory resident condition variable.</div><div class="ttdef"><b>Definition:</b> condition_variable.hpp:35</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1mutex_html"><div class="ttname"><a href="classpmem_1_1obj_1_1mutex.html">pmem::obj::mutex</a></div><div class="ttdoc">Persistent memory resident mutex implementation.</div><div class="ttdef"><b>Definition:</b> mutex.hpp:33</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:694</div></div>
<div class="ttc" id="acondition__variable_8hpp_html"><div class="ttname"><a href="condition__variable_8hpp.html">condition_variable.hpp</a></div><div class="ttdoc">Pmem-resident condition variable.</div></div>
<div class="ttc" id="amutex_8hpp_html"><div class="ttname"><a href="mutex_8hpp.html">mutex.hpp</a></div><div class="ttdoc">Pmem-resident mutex.</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
</div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f35240b1f5ab91e74f41a46628d588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f35240b1f5ab91e74f41a46628d588b">&#9670;&nbsp;</a></span>condition_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::obj::condition_variable::condition_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when the <a class="el" href="classpmem_1_1obj_1_1condition__variable.html" title="Persistent memory resident condition variable.">condition_variable</a> is not from persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50a0e13cb4b1601f1416cca92ac59e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a0e13cb4b1601f1416cca92ac59e4c">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html#a5d6f2b49f88a03db9e9f3a2b49f6bf6d">native_handle_type</a> pmem::obj::condition_variable::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a native handle to this condition variable. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to PMEMcond. </dd></dl>

</div>
</div>
<a id="a7fe698f5498498eaf15251c0bb877405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe698f5498498eaf15251c0bb877405">&#9670;&nbsp;</a></span>notify_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::condition_variable::notify_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify and unblock all threads waiting on <code>*this</code> condition. </p>
<p>Does nothing when no threads are waiting. </p>

</div>
</div>
<a id="ae8bb6885b36cd6b24961e33c5a184db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bb6885b36cd6b24961e33c5a184db9">&#9670;&nbsp;</a></span>notify_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::condition_variable::notify_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify and unblock one thread waiting on <code>*this</code> condition. </p>
<p>Does nothing when no threads are waiting. It is unspecified which thread is selected for unblocking.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when the signal fails on the #pcond. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af291e7ea73afea27847266a0d44ddfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af291e7ea73afea27847266a0d44ddfe1">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified or it is woken up by some other measure. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f14748e16f22057532d1d953b47554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f14748e16f22057532d1d953b47554">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait. This version is immune to spurious wake ups due to the provided predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate which returns <code>false</code> if waiting is to be continued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2a4af1d034c91723c6c3ef48e059de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a4af1d034c91723c6c3ef48e059de3">&#9670;&nbsp;</a></span>wait() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified or it is woken up by some other measure. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5ad0aac624644b783b7d1d1176d159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ad0aac624644b783b7d1d1176d159e">&#9670;&nbsp;</a></span>wait() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait. This version is immune to spurious wake ups due to the provided predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate which returns <code>false</code> if waiting is to be continued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a798061b7259954e9215e202d8262816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798061b7259954e9215e202d8262816f">&#9670;&nbsp;</a></span>wait_for() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::cv_status pmem::obj::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_time</td><td>a specific duration, which when expired unblocks the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5de096677650bbf1debf17dae1c24ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de096677650bbf1debf17dae1c24ec3">&#9670;&nbsp;</a></span>wait_for() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Rep , typename Period , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified or the specified amount of time passes. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_time</td><td>a specific duration, which when expired unblocks the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate which returns <code>false</code> if waiting is to be continued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if pred evaluates to <code>false</code> after timeout expired, otherwise <code>true</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae277124f54fbe0c4af5cc4d10cccbbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae277124f54fbe0c4af5cc4d10cccbbca">&#9670;&nbsp;</a></span>wait_for() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::cv_status pmem::obj::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified, the specified amount of time passes or it is woken up by some other measure. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_time</td><td>a specific duration, which when expired unblocks the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e217260e5656ae0fe130395fec85fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e217260e5656ae0fe130395fec85fba">&#9670;&nbsp;</a></span>wait_for() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::condition_variable::wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified or the specified amount of time passes. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_time</td><td>a specific duration, which when expired unblocks the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate which returns <code>false</code> if waiting is to be continued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if pred evaluates to <code>false</code> after timeout expired, otherwise <code>true</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3ea4df8540d6a6f4861be9f35f7ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3ea4df8540d6a6f4861be9f35f7ac2">&#9670;&nbsp;</a></span>wait_until() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::cv_status pmem::obj::condition_variable::wait_until </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a specific point in time, which when reached unblocks the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9d10f30c70bf4dbf7e69e28ec56c4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d10f30c70bf4dbf7e69e28ec56c4cf">&#9670;&nbsp;</a></span>wait_until() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Clock , typename Duration , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::condition_variable::wait_until </td>
          <td>(</td>
          <td class="paramtype">Lock &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified or a specific time is reached. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a Lock object which meets the BasicLockableConcept. Needs to be based on a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a specific point in time, which when reached unblocks the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate which returns <code>false</code> if waiting is to be continued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if pred evaluates to <code>false</code> after timeout expired, otherwise <code>true</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9d1fb0fac201f5d5d851da39a96e80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d1fb0fac201f5d5d851da39a96e80f">&#9670;&nbsp;</a></span>wait_until() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::cv_status pmem::obj::condition_variable::wait_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified, a specific time is reached or it is woken up by some other measure. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a specific point in time, which when reached unblocks the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::cv_status::timeout on timeout, std::cv_status::no_timeout otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac16d2eb393b49957e1e34cf9b0972dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16d2eb393b49957e1e34cf9b0972dc7">&#9670;&nbsp;</a></span>wait_until() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename Duration , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::condition_variable::wait_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the current thread block until the condition variable is notified or a specific time is reached. </p>
<p>This releases the lock, blocks the current thread and adds it to the list of threads waiting on <code>*this</code> condition variable. The lock needs to be acquired and owned by the calling thread. The lock is automatically reacquired after the call to wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>a PMEM-resident <a class="el" href="classpmem_1_1obj_1_1mutex.html" title="Persistent memory resident mutex implementation.">obj::mutex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a specific point in time, which when reached unblocks the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>predicate which returns <code>false</code> if waiting is to be continued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if pred evaluates to <code>false</code> after timeout expired, otherwise <code>true</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1lock__error.html" title="Custom lock error class.">lock_error</a></td><td>when unlocking the lock or waiting on #pcond fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/<a class="el" href="condition__variable_8hpp_source.html">condition_variable.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html">condition_variable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
