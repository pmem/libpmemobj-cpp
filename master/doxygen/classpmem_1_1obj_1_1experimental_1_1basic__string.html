<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::basic_string&lt; CharT, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.7</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::basic_string&lt; CharT, Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible interface.  
 <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__string_8hpp_source.html">libpmemobj++/experimental/basic_string.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d13876f6b7705e0dfdae08acacfaa7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7d13876f6b7705e0dfdae08acacfaa7f">basic_string</a> ()</td></tr>
<tr class="memdesc:a7d13876f6b7705e0dfdae08acacfaa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a7d13876f6b7705e0dfdae08acacfaa7f">More...</a><br /></td></tr>
<tr class="separator:a7d13876f6b7705e0dfdae08acacfaa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c936dff4606f9e09cf178c0d3359e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a49c936dff4606f9e09cf178c0d3359e2">basic_string</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:a49c936dff4606f9e09cf178c0d3359e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the container with count copies of elements with value ch.  <a href="#a49c936dff4606f9e09cf178c0d3359e2">More...</a><br /></td></tr>
<tr class="separator:a49c936dff4606f9e09cf178c0d3359e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf58e1bcd43a7213f5fbd44bce006b21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf58e1bcd43a7213f5fbd44bce006b21">basic_string</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:aaf58e1bcd43a7213f5fbd44bce006b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with a substring [pos, min(pos+count, other.size()) of other.  <a href="#aaf58e1bcd43a7213f5fbd44bce006b21">More...</a><br /></td></tr>
<tr class="separator:aaf58e1bcd43a7213f5fbd44bce006b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8cd193ab8204565648bb5ca999cd50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2c8cd193ab8204565648bb5ca999cd50">basic_string</a> (const std::basic_string&lt; CharT &gt; &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:a2c8cd193ab8204565648bb5ca999cd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with a substring [pos, min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other.  <a href="#a2c8cd193ab8204565648bb5ca999cd50">More...</a><br /></td></tr>
<tr class="separator:a2c8cd193ab8204565648bb5ca999cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a255c1d207f2773e1d95c33fc57f4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a89a255c1d207f2773e1d95c33fc57f4b">basic_string</a> (const CharT *s, size_type count)</td></tr>
<tr class="memdesc:a89a255c1d207f2773e1d95c33fc57f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with the first count elements of C-style string s.  <a href="#a89a255c1d207f2773e1d95c33fc57f4b">More...</a><br /></td></tr>
<tr class="separator:a89a255c1d207f2773e1d95c33fc57f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f174d78e65b57d2a81cd3a31d677fca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0f174d78e65b57d2a81cd3a31d677fca">basic_string</a> (const CharT *s)</td></tr>
<tr class="memdesc:a0f174d78e65b57d2a81cd3a31d677fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with the contents of s.  <a href="#a0f174d78e65b57d2a81cd3a31d677fca">More...</a><br /></td></tr>
<tr class="separator:a0f174d78e65b57d2a81cd3a31d677fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46adde6ad12bdfd544e6e1d5204bc665"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a46adde6ad12bdfd544e6e1d5204bc665"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a46adde6ad12bdfd544e6e1d5204bc665">basic_string</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a46adde6ad12bdfd544e6e1d5204bc665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with the contents of the range [first, last).  <a href="#a46adde6ad12bdfd544e6e1d5204bc665">More...</a><br /></td></tr>
<tr class="separator:a46adde6ad12bdfd544e6e1d5204bc665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062405734d14101836de1617cfaa088c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a062405734d14101836de1617cfaa088c">basic_string</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other)</td></tr>
<tr class="memdesc:a062405734d14101836de1617cfaa088c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a062405734d14101836de1617cfaa088c">More...</a><br /></td></tr>
<tr class="separator:a062405734d14101836de1617cfaa088c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7b15b783291d3bd60ffbc7490e761c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4c7b15b783291d3bd60ffbc7490e761c">basic_string</a> (const std::basic_string&lt; CharT &gt; &amp;other)</td></tr>
<tr class="memdesc:a4c7b15b783291d3bd60ffbc7490e761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a4c7b15b783291d3bd60ffbc7490e761c">More...</a><br /></td></tr>
<tr class="separator:a4c7b15b783291d3bd60ffbc7490e761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4233c850af185b3c164d3749b0455fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa4233c850af185b3c164d3749b0455fe">basic_string</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa4233c850af185b3c164d3749b0455fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aa4233c850af185b3c164d3749b0455fe">More...</a><br /></td></tr>
<tr class="separator:aa4233c850af185b3c164d3749b0455fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1f3c8d134020fb77020005d68f6f7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6a1f3c8d134020fb77020005d68f6f7d">basic_string</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:a6a1f3c8d134020fb77020005d68f6f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the container with the contents of the initializer list init.  <a href="#a6a1f3c8d134020fb77020005d68f6f7d">More...</a><br /></td></tr>
<tr class="separator:a6a1f3c8d134020fb77020005d68f6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2846936f4c528d98782ac959020347a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af2846936f4c528d98782ac959020347a">~basic_string</a> ()</td></tr>
<tr class="memdesc:af2846936f4c528d98782ac959020347a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af2846936f4c528d98782ac959020347a">More...</a><br /></td></tr>
<tr class="separator:af2846936f4c528d98782ac959020347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25e9887350ba1e523c037e4299613f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae25e9887350ba1e523c037e4299613f0">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other)</td></tr>
<tr class="memdesc:ae25e9887350ba1e523c037e4299613f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ae25e9887350ba1e523c037e4299613f0">More...</a><br /></td></tr>
<tr class="separator:ae25e9887350ba1e523c037e4299613f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8880f3c3282290b40a1a548eeaac6395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8880f3c3282290b40a1a548eeaac6395">operator=</a> (const std::basic_string&lt; CharT &gt; &amp;other)</td></tr>
<tr class="memdesc:a8880f3c3282290b40a1a548eeaac6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a8880f3c3282290b40a1a548eeaac6395">More...</a><br /></td></tr>
<tr class="separator:a8880f3c3282290b40a1a548eeaac6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339651e065a2f36c8f505ff7bc55e689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a339651e065a2f36c8f505ff7bc55e689">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a339651e065a2f36c8f505ff7bc55e689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a339651e065a2f36c8f505ff7bc55e689">More...</a><br /></td></tr>
<tr class="separator:a339651e065a2f36c8f505ff7bc55e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2724d48368f4c61ab0797075031f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4f2724d48368f4c61ab0797075031f90">operator=</a> (const CharT *s)</td></tr>
<tr class="memdesc:a4f2724d48368f4c61ab0797075031f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with copy of C-style string s transactionally.  <a href="#a4f2724d48368f4c61ab0797075031f90">More...</a><br /></td></tr>
<tr class="separator:a4f2724d48368f4c61ab0797075031f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d3972852c0ca602af1388d0695c9c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a04d3972852c0ca602af1388d0695c9c2">operator=</a> (CharT ch)</td></tr>
<tr class="memdesc:a04d3972852c0ca602af1388d0695c9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with character ch transactionally.  <a href="#a04d3972852c0ca602af1388d0695c9c2">More...</a><br /></td></tr>
<tr class="separator:a04d3972852c0ca602af1388d0695c9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43c9ce280f65d22e0d01fd961c8fc27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac43c9ce280f65d22e0d01fd961c8fc27">operator=</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:ac43c9ce280f65d22e0d01fd961c8fc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with those of the initializer list ilist transactionally.  <a href="#ac43c9ce280f65d22e0d01fd961c8fc27">More...</a><br /></td></tr>
<tr class="separator:ac43c9ce280f65d22e0d01fd961c8fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01745c1b661b5977eda2f441e591cadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a01745c1b661b5977eda2f441e591cadf">assign</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:a01745c1b661b5977eda2f441e591cadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with count copies of character ch transactionally.  <a href="#a01745c1b661b5977eda2f441e591cadf">More...</a><br /></td></tr>
<tr class="separator:a01745c1b661b5977eda2f441e591cadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852c852210485a71e0827ed0e3037762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a852c852210485a71e0827ed0e3037762">assign</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other)</td></tr>
<tr class="memdesc:a852c852210485a71e0827ed0e3037762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string with the copy of the contents of other transactionally.  <a href="#a852c852210485a71e0827ed0e3037762">More...</a><br /></td></tr>
<tr class="separator:a852c852210485a71e0827ed0e3037762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd36b026a014784c8fd5a9ecb7fd5b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#acd36b026a014784c8fd5a9ecb7fd5b91">assign</a> (const std::basic_string&lt; CharT &gt; &amp;other)</td></tr>
<tr class="memdesc:acd36b026a014784c8fd5a9ecb7fd5b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string with the copy of the contents of std::basic_string&lt;CharT&gt; other.  <a href="#acd36b026a014784c8fd5a9ecb7fd5b91">More...</a><br /></td></tr>
<tr class="separator:acd36b026a014784c8fd5a9ecb7fd5b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d79b5ecc846ec185a33c4a4468312dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6d79b5ecc846ec185a33c4a4468312dc">assign</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:a6d79b5ecc846ec185a33c4a4468312dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with a substring [pos, std::min(pos+count, other.size()) of other transactionally.  <a href="#a6d79b5ecc846ec185a33c4a4468312dc">More...</a><br /></td></tr>
<tr class="separator:a6d79b5ecc846ec185a33c4a4468312dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0035d5d07c15fcedd54b5ede00e7c298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0035d5d07c15fcedd54b5ede00e7c298">assign</a> (const std::basic_string&lt; CharT &gt; &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:a0035d5d07c15fcedd54b5ede00e7c298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with a substring [pos, std::min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other transactionally.  <a href="#a0035d5d07c15fcedd54b5ede00e7c298">More...</a><br /></td></tr>
<tr class="separator:a0035d5d07c15fcedd54b5ede00e7c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabefb7329119f1f5d0e479bbe7f9668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adabefb7329119f1f5d0e479bbe7f9668">assign</a> (const CharT *s, size_type count)</td></tr>
<tr class="memdesc:adabefb7329119f1f5d0e479bbe7f9668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with the first count elements of C-style string s transactionally.  <a href="#adabefb7329119f1f5d0e479bbe7f9668">More...</a><br /></td></tr>
<tr class="separator:adabefb7329119f1f5d0e479bbe7f9668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe2bc8a8e9ca67e19e001ca6613d819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2fe2bc8a8e9ca67e19e001ca6613d819">assign</a> (const CharT *s)</td></tr>
<tr class="memdesc:a2fe2bc8a8e9ca67e19e001ca6613d819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with copy of C-style string s transactionally.  <a href="#a2fe2bc8a8e9ca67e19e001ca6613d819">More...</a><br /></td></tr>
<tr class="separator:a2fe2bc8a8e9ca67e19e001ca6613d819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4ce02d1ea4365b52365d4803410293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4e4ce02d1ea4365b52365d4803410293">assign</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a4e4ce02d1ea4365b52365d4803410293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string with the contents of other using move semantics transactionally.  <a href="#a4e4ce02d1ea4365b52365d4803410293">More...</a><br /></td></tr>
<tr class="separator:a4e4ce02d1ea4365b52365d4803410293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f97749d40640d52cebf64762a40c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac70f97749d40640d52cebf64762a40c7">assign</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:ac70f97749d40640d52cebf64762a40c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace_content the contents with those of the initializer list ilist transactionally.  <a href="#ac70f97749d40640d52cebf64762a40c7">More...</a><br /></td></tr>
<tr class="separator:ac70f97749d40640d52cebf64762a40c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ee8aa04b5200d10589ca9d8ace785"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a114ee8aa04b5200d10589ca9d8ace785">at</a> (size_type n)</td></tr>
<tr class="memdesc:a114ee8aa04b5200d10589ca9d8ace785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking and snapshot it if there is an active transaction.  <a href="#a114ee8aa04b5200d10589ca9d8ace785">More...</a><br /></td></tr>
<tr class="separator:a114ee8aa04b5200d10589ca9d8ace785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7c8867a952de3388819e8b911347d"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8bc7c8867a952de3388819e8b911347d">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a8bc7c8867a952de3388819e8b911347d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a8bc7c8867a952de3388819e8b911347d">More...</a><br /></td></tr>
<tr class="separator:a8bc7c8867a952de3388819e8b911347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6347729401d23409ae8e3c20cbbdfa4"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:ab6347729401d23409ae8e3c20cbbdfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#ab6347729401d23409ae8e3c20cbbdfa4">More...</a><br /></td></tr>
<tr class="separator:ab6347729401d23409ae8e3c20cbbdfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a43584f35e464b753766f263b98f6a"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a13a43584f35e464b753766f263b98f6a">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a13a43584f35e464b753766f263b98f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and snapshot it if there is an active transaction.  <a href="#a13a43584f35e464b753766f263b98f6a">More...</a><br /></td></tr>
<tr class="separator:a13a43584f35e464b753766f263b98f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f7eaab5e9a72d3c8794d8857576d3"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab59f7eaab5e9a72d3c8794d8857576d3">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ab59f7eaab5e9a72d3c8794d8857576d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#ab59f7eaab5e9a72d3c8794d8857576d3">More...</a><br /></td></tr>
<tr class="separator:ab59f7eaab5e9a72d3c8794d8857576d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a95614480a2ad9c7fa4279c7ff7a40f"><td class="memItemLeft" align="right" valign="top">CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0a95614480a2ad9c7fa4279c7ff7a40f">front</a> ()</td></tr>
<tr class="memdesc:a0a95614480a2ad9c7fa4279c7ff7a40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element and snapshot it if there is an active transaction.  <a href="#a0a95614480a2ad9c7fa4279c7ff7a40f">More...</a><br /></td></tr>
<tr class="separator:a0a95614480a2ad9c7fa4279c7ff7a40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1290019d34af257ce831aa51800f4c1f"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1290019d34af257ce831aa51800f4c1f">front</a> () const</td></tr>
<tr class="memdesc:a1290019d34af257ce831aa51800f4c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element.  <a href="#a1290019d34af257ce831aa51800f4c1f">More...</a><br /></td></tr>
<tr class="separator:a1290019d34af257ce831aa51800f4c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e2613e5b2cb491cddd071bc7d3b39"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39">cfront</a> () const</td></tr>
<tr class="memdesc:adb2e2613e5b2cb491cddd071bc7d3b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element.  <a href="#adb2e2613e5b2cb491cddd071bc7d3b39">More...</a><br /></td></tr>
<tr class="separator:adb2e2613e5b2cb491cddd071bc7d3b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf75feee0c5a6d8b5dec8dd9cde24bed"><td class="memItemLeft" align="right" valign="top">CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adf75feee0c5a6d8b5dec8dd9cde24bed">back</a> ()</td></tr>
<tr class="memdesc:adf75feee0c5a6d8b5dec8dd9cde24bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element and snapshot it if there is an active transaction.  <a href="#adf75feee0c5a6d8b5dec8dd9cde24bed">More...</a><br /></td></tr>
<tr class="separator:adf75feee0c5a6d8b5dec8dd9cde24bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dfa7c2d10786a2837a36981b4b1440"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac4dfa7c2d10786a2837a36981b4b1440">back</a> () const</td></tr>
<tr class="memdesc:ac4dfa7c2d10786a2837a36981b4b1440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element.  <a href="#ac4dfa7c2d10786a2837a36981b4b1440">More...</a><br /></td></tr>
<tr class="separator:ac4dfa7c2d10786a2837a36981b4b1440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b9e19d268d06cfbdae3d274a99da02"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02">cback</a> () const</td></tr>
<tr class="memdesc:a37b9e19d268d06cfbdae3d274a99da02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element.  <a href="#a37b9e19d268d06cfbdae3d274a99da02">More...</a><br /></td></tr>
<tr class="separator:a37b9e19d268d06cfbdae3d274a99da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ce85e96d0137d8407f1abe6bb74dd4"><td class="memItemLeft" align="right" valign="top">CharT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a19ce85e96d0137d8407f1abe6bb74dd4">data</a> ()</td></tr>
<tr class="separator:a19ce85e96d0137d8407f1abe6bb74dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26afd5f7d0bae52907053cd7bf96cf25"><td class="memItemLeft" align="right" valign="top">const CharT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a26afd5f7d0bae52907053cd7bf96cf25">data</a> () const noexcept</td></tr>
<tr class="separator:a26afd5f7d0bae52907053cd7bf96cf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924a8b0829e7c20a71a322f7507dc966"><td class="memItemLeft" align="right" valign="top">const CharT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a924a8b0829e7c20a71a322f7507dc966">cdata</a> () const noexcept</td></tr>
<tr class="separator:a924a8b0829e7c20a71a322f7507dc966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9ca34c0b5b017cd5817360930e152"><td class="memItemLeft" align="right" valign="top">const CharT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a92e9ca34c0b5b017cd5817360930e152">c_str</a> () const noexcept</td></tr>
<tr class="separator:a92e9ca34c0b5b017cd5817360930e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84575172811e6af3fa4735f6c98fb46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae84575172811e6af3fa4735f6c98fb46">begin</a> ()</td></tr>
<tr class="memdesc:ae84575172811e6af3fa4735f6c98fb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the beginning.  <a href="#ae84575172811e6af3fa4735f6c98fb46">More...</a><br /></td></tr>
<tr class="separator:ae84575172811e6af3fa4735f6c98fb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b726ea004e140eaedd644510a34fe4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae6b726ea004e140eaedd644510a34fe4">begin</a> () const noexcept</td></tr>
<tr class="memdesc:ae6b726ea004e140eaedd644510a34fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to the beginning.  <a href="#ae6b726ea004e140eaedd644510a34fe4">More...</a><br /></td></tr>
<tr class="separator:ae6b726ea004e140eaedd644510a34fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8faca84731379e1ff9c794643b2e33"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a5b8faca84731379e1ff9c794643b2e33">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a5b8faca84731379e1ff9c794643b2e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to the beginning.  <a href="#a5b8faca84731379e1ff9c794643b2e33">More...</a><br /></td></tr>
<tr class="separator:a5b8faca84731379e1ff9c794643b2e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ba2aa7a34084c46018888f67cc9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4">end</a> ()</td></tr>
<tr class="memdesc:a526ba2aa7a34084c46018888f67cc9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to past the end.  <a href="#a526ba2aa7a34084c46018888f67cc9d4">More...</a><br /></td></tr>
<tr class="separator:a526ba2aa7a34084c46018888f67cc9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c8133289e2290e7d476eb65294f4f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0e2c8133289e2290e7d476eb65294f4f">end</a> () const noexcept</td></tr>
<tr class="memdesc:a0e2c8133289e2290e7d476eb65294f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to past the end.  <a href="#a0e2c8133289e2290e7d476eb65294f4f">More...</a><br /></td></tr>
<tr class="separator:a0e2c8133289e2290e7d476eb65294f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f708491eb1ba92834e12a25b3b273f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa8f708491eb1ba92834e12a25b3b273f">cend</a> () const noexcept</td></tr>
<tr class="memdesc:aa8f708491eb1ba92834e12a25b3b273f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to past the end.  <a href="#aa8f708491eb1ba92834e12a25b3b273f">More...</a><br /></td></tr>
<tr class="separator:aa8f708491eb1ba92834e12a25b3b273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0930182af8a2448d010aa603c1495326"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0930182af8a2448d010aa603c1495326">rbegin</a> ()</td></tr>
<tr class="memdesc:a0930182af8a2448d010aa603c1495326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator to the beginning.  <a href="#a0930182af8a2448d010aa603c1495326">More...</a><br /></td></tr>
<tr class="separator:a0930182af8a2448d010aa603c1495326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa6e329ea0d45e17a74e880994f947e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8fa6e329ea0d45e17a74e880994f947e">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a8fa6e329ea0d45e17a74e880994f947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the beginning.  <a href="#a8fa6e329ea0d45e17a74e880994f947e">More...</a><br /></td></tr>
<tr class="separator:a8fa6e329ea0d45e17a74e880994f947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550ba03ad47efe24c30fff1b4c2548b7"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a550ba03ad47efe24c30fff1b4c2548b7">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a550ba03ad47efe24c30fff1b4c2548b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the beginning.  <a href="#a550ba03ad47efe24c30fff1b4c2548b7">More...</a><br /></td></tr>
<tr class="separator:a550ba03ad47efe24c30fff1b4c2548b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1ba265e840da1b926a621ee932e332"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aad1ba265e840da1b926a621ee932e332">rend</a> ()</td></tr>
<tr class="memdesc:aad1ba265e840da1b926a621ee932e332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator to the end.  <a href="#aad1ba265e840da1b926a621ee932e332">More...</a><br /></td></tr>
<tr class="separator:aad1ba265e840da1b926a621ee932e332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77ec7a6f29e8a004e4e8bbaa262a1c"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6e77ec7a6f29e8a004e4e8bbaa262a1c">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a6e77ec7a6f29e8a004e4e8bbaa262a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the end.  <a href="#a6e77ec7a6f29e8a004e4e8bbaa262a1c">More...</a><br /></td></tr>
<tr class="separator:a6e77ec7a6f29e8a004e4e8bbaa262a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d27e932b80a8f6572055fdbca5fa368"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2d27e932b80a8f6572055fdbca5fa368">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a2d27e932b80a8f6572055fdbca5fa368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the end.  <a href="#a2d27e932b80a8f6572055fdbca5fa368">More...</a><br /></td></tr>
<tr class="separator:a2d27e932b80a8f6572055fdbca5fa368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c0f6e18623b888cb65dae95a9d79d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abe1c0f6e18623b888cb65dae95a9d79d">empty</a> () const noexcept</td></tr>
<tr class="separator:abe1c0f6e18623b888cb65dae95a9d79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d70fe47d10ff8af64ece41610b0c2c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size</a> () const noexcept</td></tr>
<tr class="separator:a10d70fe47d10ff8af64ece41610b0c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad312f37adadcbbf3396945fa685165"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7ad312f37adadcbbf3396945fa685165">length</a> () const noexcept</td></tr>
<tr class="separator:a7ad312f37adadcbbf3396945fa685165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41f64c4d254dac34bde1a6e475e5585"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size</a> () const noexcept</td></tr>
<tr class="separator:aa41f64c4d254dac34bde1a6e475e5585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae688b8f07ddcd5314de694e4ef91dad8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity</a> () const noexcept</td></tr>
<tr class="separator:ae688b8f07ddcd5314de694e4ef91dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f2e06a142986d71fd4281d1a1c1e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac9f2e06a142986d71fd4281d1a1c1e67">resize</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:ac9f2e06a142986d71fd4281d1a1c1e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the string to count characters transactionally.  <a href="#ac9f2e06a142986d71fd4281d1a1c1e67">More...</a><br /></td></tr>
<tr class="separator:ac9f2e06a142986d71fd4281d1a1c1e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277ae71bc4e95ee236a187a9251f452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8277ae71bc4e95ee236a187a9251f452">resize</a> (size_type n)</td></tr>
<tr class="memdesc:a8277ae71bc4e95ee236a187a9251f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the string to count characters transactionally.  <a href="#a8277ae71bc4e95ee236a187a9251f452">More...</a><br /></td></tr>
<tr class="separator:a8277ae71bc4e95ee236a187a9251f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb5f5ee3bf50b379aea23497bbd1643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4eb5f5ee3bf50b379aea23497bbd1643">reserve</a> (size_type new_cap=0)</td></tr>
<tr class="memdesc:a4eb5f5ee3bf50b379aea23497bbd1643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the string to new_cap transactionally.  <a href="#a4eb5f5ee3bf50b379aea23497bbd1643">More...</a><br /></td></tr>
<tr class="separator:a4eb5f5ee3bf50b379aea23497bbd1643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce135d86a3cb44379de7d00d174d3d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abce135d86a3cb44379de7d00d174d3d5">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:abce135d86a3cb44379de7d00d174d3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused capacity transactionally.  <a href="#abce135d86a3cb44379de7d00d174d3d5">More...</a><br /></td></tr>
<tr class="separator:abce135d86a3cb44379de7d00d174d3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48a06395ce0af510bbea55c0805ce07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab48a06395ce0af510bbea55c0805ce07">clear</a> ()</td></tr>
<tr class="memdesc:ab48a06395ce0af510bbea55c0805ce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all characters from the string transactionally.  <a href="#ab48a06395ce0af510bbea55c0805ce07">More...</a><br /></td></tr>
<tr class="separator:ab48a06395ce0af510bbea55c0805ce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271994efb0040688a3feb7d5392c253b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a271994efb0040688a3feb7d5392c253b">erase</a> (size_type index=0, size_type count=npos)</td></tr>
<tr class="memdesc:a271994efb0040688a3feb7d5392c253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters from string starting at index transactionally.  <a href="#a271994efb0040688a3feb7d5392c253b">More...</a><br /></td></tr>
<tr class="separator:a271994efb0040688a3feb7d5392c253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94c51bfd094b006063e77603cad10f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad94c51bfd094b006063e77603cad10f3">erase</a> (const_iterator pos)</td></tr>
<tr class="memdesc:ad94c51bfd094b006063e77603cad10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove character from string at pos position transactionally.  <a href="#ad94c51bfd094b006063e77603cad10f3">More...</a><br /></td></tr>
<tr class="separator:ad94c51bfd094b006063e77603cad10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efe18b1b78afcfaf8b715daa3276a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2efe18b1b78afcfaf8b715daa3276a49">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:a2efe18b1b78afcfaf8b715daa3276a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters from string at [first, last) range transactionally.  <a href="#a2efe18b1b78afcfaf8b715daa3276a49">More...</a><br /></td></tr>
<tr class="separator:a2efe18b1b78afcfaf8b715daa3276a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a254b366ac8a14024171dafe32336b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;			  !std::is_convertible&lt;T, size_type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af4a254b366ac8a14024171dafe32336b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af4a254b366ac8a14024171dafe32336b">erase</a> (T param)</td></tr>
<tr class="memdesc:af4a254b366ac8a14024171dafe32336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Participate in overload resolution only if T is not convertible to size_type.  <a href="#af4a254b366ac8a14024171dafe32336b">More...</a><br /></td></tr>
<tr class="separator:af4a254b366ac8a14024171dafe32336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d659398a61aa62e67af30497d635388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8d659398a61aa62e67af30497d635388">pop_back</a> ()</td></tr>
<tr class="memdesc:a8d659398a61aa62e67af30497d635388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last character from the string transactionally.  <a href="#a8d659398a61aa62e67af30497d635388">More...</a><br /></td></tr>
<tr class="separator:a8d659398a61aa62e67af30497d635388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dbad2006284b8c56352fb3830223cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad8dbad2006284b8c56352fb3830223cc">append</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:ad8dbad2006284b8c56352fb3830223cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append count copies of character ch to the string transactionally.  <a href="#ad8dbad2006284b8c56352fb3830223cc">More...</a><br /></td></tr>
<tr class="separator:ad8dbad2006284b8c56352fb3830223cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa030fc48fb50b22f97b83dc92e3c0375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa030fc48fb50b22f97b83dc92e3c0375">append</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:aa030fc48fb50b22f97b83dc92e3c0375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append string str transactionally.  <a href="#aa030fc48fb50b22f97b83dc92e3c0375">More...</a><br /></td></tr>
<tr class="separator:aa030fc48fb50b22f97b83dc92e3c0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb74e7c883572ffd23212cc373a6ae21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aeb74e7c883572ffd23212cc373a6ae21">append</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:aeb74e7c883572ffd23212cc373a6ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append substring [pos, pos + count) of str string transactionally.  <a href="#aeb74e7c883572ffd23212cc373a6ae21">More...</a><br /></td></tr>
<tr class="separator:aeb74e7c883572ffd23212cc373a6ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc34ce145038070a7ff4236cd44f741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abdc34ce145038070a7ff4236cd44f741">append</a> (const CharT *s, size_type count)</td></tr>
<tr class="memdesc:abdc34ce145038070a7ff4236cd44f741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters in the range [s, s + count) transactionally.  <a href="#abdc34ce145038070a7ff4236cd44f741">More...</a><br /></td></tr>
<tr class="separator:abdc34ce145038070a7ff4236cd44f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab683cabdae64c92252c98aa6502be6ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab683cabdae64c92252c98aa6502be6ec">append</a> (const CharT *s)</td></tr>
<tr class="memdesc:ab683cabdae64c92252c98aa6502be6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append C-style string transactionally.  <a href="#ab683cabdae64c92252c98aa6502be6ec">More...</a><br /></td></tr>
<tr class="separator:ab683cabdae64c92252c98aa6502be6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1407ac483de831d458c605ead38a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf1407ac483de831d458c605ead38a88">append</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:aaf1407ac483de831d458c605ead38a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters from the ilist initializer list transactionally.  <a href="#aaf1407ac483de831d458c605ead38a88">More...</a><br /></td></tr>
<tr class="separator:aaf1407ac483de831d458c605ead38a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5e19b05069281877348ddd4db3628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a65a5e19b05069281877348ddd4db3628">push_back</a> (CharT ch)</td></tr>
<tr class="memdesc:a65a5e19b05069281877348ddd4db3628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append character ch at the end of the string transactionally.  <a href="#a65a5e19b05069281877348ddd4db3628">More...</a><br /></td></tr>
<tr class="separator:a65a5e19b05069281877348ddd4db3628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1002f2f69f122ed33b569df655d0c91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab1002f2f69f122ed33b569df655d0c91">operator+=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:ab1002f2f69f122ed33b569df655d0c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append string str transactionally.  <a href="#ab1002f2f69f122ed33b569df655d0c91">More...</a><br /></td></tr>
<tr class="separator:ab1002f2f69f122ed33b569df655d0c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9d5ff7baa72fe12bf94547095ce01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a5ca9d5ff7baa72fe12bf94547095ce01">operator+=</a> (const CharT *s)</td></tr>
<tr class="memdesc:a5ca9d5ff7baa72fe12bf94547095ce01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append C-style string transactionally.  <a href="#a5ca9d5ff7baa72fe12bf94547095ce01">More...</a><br /></td></tr>
<tr class="separator:a5ca9d5ff7baa72fe12bf94547095ce01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b261819c79a1fc515fda81fe866ae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af0b261819c79a1fc515fda81fe866ae5">operator+=</a> (CharT c)</td></tr>
<tr class="memdesc:af0b261819c79a1fc515fda81fe866ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append character ch at the end of the string transactionally.  <a href="#af0b261819c79a1fc515fda81fe866ae5">More...</a><br /></td></tr>
<tr class="separator:af0b261819c79a1fc515fda81fe866ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067720bf6200336e78a29a8ba385bf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a067720bf6200336e78a29a8ba385bf84">operator+=</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:a067720bf6200336e78a29a8ba385bf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters from the ilist initializer list transactionally.  <a href="#a067720bf6200336e78a29a8ba385bf84">More...</a><br /></td></tr>
<tr class="separator:a067720bf6200336e78a29a8ba385bf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc08ce035aefdca9c5902ea5daf69c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa8cc08ce035aefdca9c5902ea5daf69c">insert</a> (size_type index, size_type count, CharT ch)</td></tr>
<tr class="memdesc:aa8cc08ce035aefdca9c5902ea5daf69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert count copies of ch character at index transactionally.  <a href="#aa8cc08ce035aefdca9c5902ea5daf69c">More...</a><br /></td></tr>
<tr class="separator:aa8cc08ce035aefdca9c5902ea5daf69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4219eb8c6db9c309c40076d920a41a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4219eb8c6db9c309c40076d920a41a9b">insert</a> (size_type index, const CharT *s)</td></tr>
<tr class="memdesc:a4219eb8c6db9c309c40076d920a41a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert null-terminated C-style string pointed by s of the length determined by the first null character at index transactionally.  <a href="#a4219eb8c6db9c309c40076d920a41a9b">More...</a><br /></td></tr>
<tr class="separator:a4219eb8c6db9c309c40076d920a41a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791f57776354054d380f8cbb5dff8fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a791f57776354054d380f8cbb5dff8fe1">insert</a> (size_type index, const CharT *s, size_type count)</td></tr>
<tr class="memdesc:a791f57776354054d380f8cbb5dff8fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert characters in the range [s, s+ count) at index transactionally.  <a href="#a791f57776354054d380f8cbb5dff8fe1">More...</a><br /></td></tr>
<tr class="separator:a791f57776354054d380f8cbb5dff8fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f24dbfac5cb9144a0bf682b4afe9a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a35f24dbfac5cb9144a0bf682b4afe9a8">insert</a> (size_type index, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:a35f24dbfac5cb9144a0bf682b4afe9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert str string at index transactionally.  <a href="#a35f24dbfac5cb9144a0bf682b4afe9a8">More...</a><br /></td></tr>
<tr class="separator:a35f24dbfac5cb9144a0bf682b4afe9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98baa99c0ddef1a7799c103bc71e43b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a98baa99c0ddef1a7799c103bc71e43b3">insert</a> (size_type index1, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str, size_type index2, size_type count=npos)</td></tr>
<tr class="memdesc:a98baa99c0ddef1a7799c103bc71e43b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a str.substr(index2, count) string at index1 transactionally.  <a href="#a98baa99c0ddef1a7799c103bc71e43b3">More...</a><br /></td></tr>
<tr class="separator:a98baa99c0ddef1a7799c103bc71e43b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ce3312e00ca19d73f329139fb9dc4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad2ce3312e00ca19d73f329139fb9dc4c">insert</a> (const_iterator pos, CharT ch)</td></tr>
<tr class="memdesc:ad2ce3312e00ca19d73f329139fb9dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert character ch before the character pointed by pos transactionally.  <a href="#ad2ce3312e00ca19d73f329139fb9dc4c">More...</a><br /></td></tr>
<tr class="separator:ad2ce3312e00ca19d73f329139fb9dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb62bcf4fc3a19b34f573c948e9c8f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0fb62bcf4fc3a19b34f573c948e9c8f9">insert</a> (const_iterator pos, size_type count, CharT ch)</td></tr>
<tr class="memdesc:a0fb62bcf4fc3a19b34f573c948e9c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert count copies of character ch before the character pointed by pos transactionally.  <a href="#a0fb62bcf4fc3a19b34f573c948e9c8f9">More...</a><br /></td></tr>
<tr class="separator:a0fb62bcf4fc3a19b34f573c948e9c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6c82e794b70af46623aeec8d9a5182"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename pmem::detail::is_input_iterator&lt;			  InputIt&gt;::type&gt; </td></tr>
<tr class="memitem:a6d6c82e794b70af46623aeec8d9a5182"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6d6c82e794b70af46623aeec8d9a5182">insert</a> (const_iterator pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a6d6c82e794b70af46623aeec8d9a5182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert characters from [first, last) range before the character pointed by pos transactionally.  <a href="#a6d6c82e794b70af46623aeec8d9a5182">More...</a><br /></td></tr>
<tr class="separator:a6d6c82e794b70af46623aeec8d9a5182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f03f1c273cd028f6083c4bc45d8b525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a5f03f1c273cd028f6083c4bc45d8b525">insert</a> (const_iterator pos, std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:a5f03f1c273cd028f6083c4bc45d8b525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert characters from initializer list ilist before the character pointed by pos transactionally.  <a href="#a5f03f1c273cd028f6083c4bc45d8b525">More...</a><br /></td></tr>
<tr class="separator:a5f03f1c273cd028f6083c4bc45d8b525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482415e51110c3dda72cfa841be63661"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;			  !std::is_convertible&lt;T, size_type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a482415e51110c3dda72cfa841be63661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a482415e51110c3dda72cfa841be63661">insert</a> (T param, size_type count, CharT ch)</td></tr>
<tr class="memdesc:a482415e51110c3dda72cfa841be63661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Participate in overload resolution only if T is not convertible to size_type.  <a href="#a482415e51110c3dda72cfa841be63661">More...</a><br /></td></tr>
<tr class="separator:a482415e51110c3dda72cfa841be63661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adb85bb22cdfe364fd86522715b9cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7adb85bb22cdfe364fd86522715b9cc7">replace</a> (size_type index, size_type count, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:a7adb85bb22cdfe364fd86522715b9cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [index, index + count) with the content of str string transactionally.  <a href="#a7adb85bb22cdfe364fd86522715b9cc7">More...</a><br /></td></tr>
<tr class="separator:a7adb85bb22cdfe364fd86522715b9cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67fec31d082d87e37e4a2cfa1c305cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa67fec31d082d87e37e4a2cfa1c305cf">replace</a> (const_iterator first, const_iterator last, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:aa67fec31d082d87e37e4a2cfa1c305cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [first, last) with the content of str string transactionally.  <a href="#aa67fec31d082d87e37e4a2cfa1c305cf">More...</a><br /></td></tr>
<tr class="separator:aa67fec31d082d87e37e4a2cfa1c305cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce0713ff9aad5d746cfa900090c3526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0ce0713ff9aad5d746cfa900090c3526">replace</a> (size_type index, size_type count, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str, size_type index2, size_type count2=npos)</td></tr>
<tr class="memdesc:a0ce0713ff9aad5d746cfa900090c3526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [index, index + count) with the substring [index2, index2 + count2) of str string transactionally.  <a href="#a0ce0713ff9aad5d746cfa900090c3526">More...</a><br /></td></tr>
<tr class="separator:a0ce0713ff9aad5d746cfa900090c3526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7a7c666edcdb9c703887c5f69700da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aee7a7c666edcdb9c703887c5f69700da">replace</a> (const_iterator first, const_iterator last, const CharT *s, size_type count2)</td></tr>
<tr class="memdesc:aee7a7c666edcdb9c703887c5f69700da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [first, last) with the characters in [s, s + count2) range transactionally.  <a href="#aee7a7c666edcdb9c703887c5f69700da">More...</a><br /></td></tr>
<tr class="separator:aee7a7c666edcdb9c703887c5f69700da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a7b5a845d5adb851e3ba2da98151f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa4a7b5a845d5adb851e3ba2da98151f1">replace</a> (const_iterator first, const_iterator last, const CharT *s)</td></tr>
<tr class="memdesc:aa4a7b5a845d5adb851e3ba2da98151f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [first, last) with the characters in [s, s + traits::length(s)) range transactionally.  <a href="#aa4a7b5a845d5adb851e3ba2da98151f1">More...</a><br /></td></tr>
<tr class="separator:aa4a7b5a845d5adb851e3ba2da98151f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792d96269991f9bfc6f76e5de38a250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a3792d96269991f9bfc6f76e5de38a250">replace</a> (size_type index, size_type count, size_type count2, CharT ch)</td></tr>
<tr class="memdesc:a3792d96269991f9bfc6f76e5de38a250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [index, index + count) with count2 copies of ch character transactionally.  <a href="#a3792d96269991f9bfc6f76e5de38a250">More...</a><br /></td></tr>
<tr class="separator:a3792d96269991f9bfc6f76e5de38a250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2e1246319527843d218f342428a1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2a2e1246319527843d218f342428a1d8">replace</a> (const_iterator first, const_iterator last, size_type count2, CharT ch)</td></tr>
<tr class="memdesc:a2a2e1246319527843d218f342428a1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [first, last) with count2 copies of ch character transactionally.  <a href="#a2a2e1246319527843d218f342428a1d8">More...</a><br /></td></tr>
<tr class="separator:a2a2e1246319527843d218f342428a1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b0296c73c9a4ccd2bf1b5dd783257f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a17b0296c73c9a4ccd2bf1b5dd783257f">replace</a> (size_type index, size_type count, const CharT *s, size_type count2)</td></tr>
<tr class="memdesc:a17b0296c73c9a4ccd2bf1b5dd783257f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [index, index + count) with the characters in [s, s + count2) range transactionally.  <a href="#a17b0296c73c9a4ccd2bf1b5dd783257f">More...</a><br /></td></tr>
<tr class="separator:a17b0296c73c9a4ccd2bf1b5dd783257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23719386f4d96bb15a61f70b38ad1463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a23719386f4d96bb15a61f70b38ad1463">replace</a> (size_type index, size_type count, const CharT *s)</td></tr>
<tr class="memdesc:a23719386f4d96bb15a61f70b38ad1463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [index, index + count) with the characters in [s, s + traits::length(s)) range transactionally.  <a href="#a23719386f4d96bb15a61f70b38ad1463">More...</a><br /></td></tr>
<tr class="separator:a23719386f4d96bb15a61f70b38ad1463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e3b258bbc3e4516c549e521bac5396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a64e3b258bbc3e4516c549e521bac5396">replace</a> (const_iterator first, const_iterator last, std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:a64e3b258bbc3e4516c549e521bac5396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [first, last) with characters in initializer list ilist transactionally.  <a href="#a64e3b258bbc3e4516c549e521bac5396">More...</a><br /></td></tr>
<tr class="separator:a64e3b258bbc3e4516c549e521bac5396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2cc6b2a19aefdb0ae49fb42e217cb7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ada2cc6b2a19aefdb0ae49fb42e217cb7">copy</a> (CharT *s, size_type count, size_type index=0) const</td></tr>
<tr class="memdesc:ada2cc6b2a19aefdb0ae49fb42e217cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy [index, index + count) substring of *this to C-style string.  <a href="#ada2cc6b2a19aefdb0ae49fb42e217cb7">More...</a><br /></td></tr>
<tr class="separator:ada2cc6b2a19aefdb0ae49fb42e217cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037abcc78fa96219dc1a24587d628de6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a037abcc78fa96219dc1a24587d628de6">compare</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other) const</td></tr>
<tr class="memdesc:a037abcc78fa96219dc1a24587d628de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this string to other.  <a href="#a037abcc78fa96219dc1a24587d628de6">More...</a><br /></td></tr>
<tr class="separator:a037abcc78fa96219dc1a24587d628de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c804f16487c05db4208fe1d29224c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac74c804f16487c05db4208fe1d29224c">compare</a> (const std::basic_string&lt; CharT &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac74c804f16487c05db4208fe1d29224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this string to std::basic_string&lt;CharT&gt; other.  <a href="#ac74c804f16487c05db4208fe1d29224c">More...</a><br /></td></tr>
<tr class="separator:ac74c804f16487c05db4208fe1d29224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a06c0ef69676e35b6bd3cfdce3762e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa1a06c0ef69676e35b6bd3cfdce3762e">compare</a> (size_type pos, size_type count, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1a06c0ef69676e35b6bd3cfdce3762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count) substring of this to other.  <a href="#aa1a06c0ef69676e35b6bd3cfdce3762e">More...</a><br /></td></tr>
<tr class="separator:aa1a06c0ef69676e35b6bd3cfdce3762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcef57c33ff14f67e4651119c4d3d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a3bcef57c33ff14f67e4651119c4d3d55">compare</a> (size_type pos, size_type count, const std::basic_string&lt; CharT &gt; &amp;other) const</td></tr>
<tr class="memdesc:a3bcef57c33ff14f67e4651119c4d3d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count) substring of this to std::basic_string&lt;CharT&gt; other.  <a href="#a3bcef57c33ff14f67e4651119c4d3d55">More...</a><br /></td></tr>
<tr class="separator:a3bcef57c33ff14f67e4651119c4d3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3ed854a3ed1e5ebf5f7fb7569209e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aad3ed854a3ed1e5ebf5f7fb7569209e4">compare</a> (size_type pos1, size_type count1, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other, size_type pos2, size_type count2=npos) const</td></tr>
<tr class="memdesc:aad3ed854a3ed1e5ebf5f7fb7569209e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of other.  <a href="#aad3ed854a3ed1e5ebf5f7fb7569209e4">More...</a><br /></td></tr>
<tr class="separator:aad3ed854a3ed1e5ebf5f7fb7569209e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f371ce3428c15e1547a7b055c49850d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1f371ce3428c15e1547a7b055c49850d">compare</a> (size_type pos1, size_type count1, const std::basic_string&lt; CharT &gt; &amp;other, size_type pos2, size_type count2=npos) const</td></tr>
<tr class="memdesc:a1f371ce3428c15e1547a7b055c49850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of std::basic_string&lt;CharT&gt; other.  <a href="#a1f371ce3428c15e1547a7b055c49850d">More...</a><br /></td></tr>
<tr class="separator:a1f371ce3428c15e1547a7b055c49850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dfaa2fc3d30c4b615bb345c5a900ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a26dfaa2fc3d30c4b615bb345c5a900ac">compare</a> (const CharT *s) const</td></tr>
<tr class="memdesc:a26dfaa2fc3d30c4b615bb345c5a900ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this string to s.  <a href="#a26dfaa2fc3d30c4b615bb345c5a900ac">More...</a><br /></td></tr>
<tr class="separator:a26dfaa2fc3d30c4b615bb345c5a900ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769eb94ffb310cdc279191c27df73cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad769eb94ffb310cdc279191c27df73cd">compare</a> (size_type pos, size_type count, const CharT *s) const</td></tr>
<tr class="memdesc:ad769eb94ffb310cdc279191c27df73cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count) substring of this to s.  <a href="#ad769eb94ffb310cdc279191c27df73cd">More...</a><br /></td></tr>
<tr class="separator:ad769eb94ffb310cdc279191c27df73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763cffb1f2439ca5fb0a107142fb15f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a763cffb1f2439ca5fb0a107142fb15f5">compare</a> (size_type pos, size_type count1, const CharT *s, size_type count2) const</td></tr>
<tr class="memdesc:a763cffb1f2439ca5fb0a107142fb15f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count1) substring of this to [s, s + count2) substring of s.  <a href="#a763cffb1f2439ca5fb0a107142fb15f5">More...</a><br /></td></tr>
<tr class="separator:a763cffb1f2439ca5fb0a107142fb15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9454e658d7ff8cb2244bdcb2338e658"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable &gt; </td></tr>
<tr class="memitem:ae9454e658d7ff8cb2244bdcb2338e658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae9454e658d7ff8cb2244bdcb2338e658">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ae9454e658d7ff8cb2244bdcb2338e658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with copies of elements in the range [first, last) transactionally.  <a href="#ae9454e658d7ff8cb2244bdcb2338e658">More...</a><br /></td></tr>
<tr class="separator:ae9454e658d7ff8cb2244bdcb2338e658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb50bb73a285a1086ba23f7766b36f7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable &gt; </td></tr>
<tr class="memitem:aaeb50bb73a285a1086ba23f7766b36f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaeb50bb73a285a1086ba23f7766b36f7">append</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:aaeb50bb73a285a1086ba23f7766b36f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters in the range [first, last) transactionally.  <a href="#aaeb50bb73a285a1086ba23f7766b36f7">More...</a><br /></td></tr>
<tr class="separator:aaeb50bb73a285a1086ba23f7766b36f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81a9751029d6d8a80c529e1e977a586"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable &gt; </td></tr>
<tr class="memitem:ac81a9751029d6d8a80c529e1e977a586"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac81a9751029d6d8a80c529e1e977a586">replace</a> (const_iterator first, const_iterator last, InputIt first2, InputIt last2)</td></tr>
<tr class="memdesc:ac81a9751029d6d8a80c529e1e977a586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace range [first, last) with the characters in [first2, last2) range transactionally.  <a href="#ac81a9751029d6d8a80c529e1e977a586">More...</a><br /></td></tr>
<tr class="separator:ac81a9751029d6d8a80c529e1e977a586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdd408b3929ce784004ccc236c085f8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable &gt; </td></tr>
<tr class="memitem:a7bdd408b3929ce784004ccc236c085f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7bdd408b3929ce784004ccc236c085f8">erase</a> (T param)</td></tr>
<tr class="memdesc:a7bdd408b3929ce784004ccc236c085f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Participate in overload resolution only if T is convertible to size_type.  <a href="#a7bdd408b3929ce784004ccc236c085f8">More...</a><br /></td></tr>
<tr class="separator:a7bdd408b3929ce784004ccc236c085f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65fcd6dfc161897f32529f3144edd9f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable &gt; </td></tr>
<tr class="memitem:ab65fcd6dfc161897f32529f3144edd9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab65fcd6dfc161897f32529f3144edd9f">insert</a> (T param, size_type count, CharT ch)</td></tr>
<tr class="memdesc:ab65fcd6dfc161897f32529f3144edd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Participate in overload resolution only if T is convertible to size_type.  <a href="#ab65fcd6dfc161897f32529f3144edd9f">More...</a><br /></td></tr>
<tr class="separator:ab65fcd6dfc161897f32529f3144edd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7a73397ef9970aff7df1e67b3212a3ef"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7a73397ef9970aff7df1e67b3212a3ef"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7a73397ef9970aff7df1e67b3212a3ef">get_size</a> (InputIt first, InputIt last) const</td></tr>
<tr class="memdesc:a7a73397ef9970aff7df1e67b3212a3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of generic get_size method used to calculate size based on provided parameters.  <a href="#a7a73397ef9970aff7df1e67b3212a3ef">More...</a><br /></td></tr>
<tr class="separator:a7a73397ef9970aff7df1e67b3212a3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4e4fe677319c6477085637e5b178c3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1d4e4fe677319c6477085637e5b178c3">get_size</a> (size_type count, value_type ch) const</td></tr>
<tr class="memdesc:a1d4e4fe677319c6477085637e5b178c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of generic get_size method used to calculate size based on provided parameters.  <a href="#a1d4e4fe677319c6477085637e5b178c3">More...</a><br /></td></tr>
<tr class="separator:a1d4e4fe677319c6477085637e5b178c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a54981fd56128506298de2317e5b4f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a78a54981fd56128506298de2317e5b4f">get_size</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other) const</td></tr>
<tr class="memdesc:a78a54981fd56128506298de2317e5b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of generic get_size method used to calculate size based on provided parameters.  <a href="#a78a54981fd56128506298de2317e5b4f">More...</a><br /></td></tr>
<tr class="separator:a78a54981fd56128506298de2317e5b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4ec3a9d3097de676a19b090d2eadbc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7a4ec3a9d3097de676a19b090d2eadbc"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7a4ec3a9d3097de676a19b090d2eadbc">replace_content</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7a4ec3a9d3097de676a19b090d2eadbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function which replace_content current content based on provided parameters.  <a href="#a7a4ec3a9d3097de676a19b090d2eadbc">More...</a><br /></td></tr>
<tr class="separator:a7a4ec3a9d3097de676a19b090d2eadbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04af91240ccce74722307c1c8480be1e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a04af91240ccce74722307c1c8480be1e"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a04af91240ccce74722307c1c8480be1e">initialize</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a04af91240ccce74722307c1c8480be1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function which initializes memory based on provided parameters - forwards parameters to initialize function of either non_sso.data or sso.data.  <a href="#a04af91240ccce74722307c1c8480be1e">More...</a><br /></td></tr>
<tr class="separator:a04af91240ccce74722307c1c8480be1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e6cd3ac6395a99501919abe4091b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9b3e6cd3ac6395a99501919abe4091b5">allocate</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity</a>)</td></tr>
<tr class="memdesc:a9b3e6cd3ac6395a99501919abe4091b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for container of capacity bytes.  <a href="#a9b3e6cd3ac6395a99501919abe4091b5">More...</a><br /></td></tr>
<tr class="separator:a9b3e6cd3ac6395a99501919abe4091b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d811ceb9088d3cc3a21ab89195a492"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a11d811ceb9088d3cc3a21ab89195a492"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a11d811ceb9088d3cc3a21ab89195a492">assign_sso_data</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a11d811ceb9088d3cc3a21ab89195a492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sso data.  <a href="#a11d811ceb9088d3cc3a21ab89195a492">More...</a><br /></td></tr>
<tr class="separator:a11d811ceb9088d3cc3a21ab89195a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324dcc22b9a9645f6dda753b5dea1d0a"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a324dcc22b9a9645f6dda753b5dea1d0a">assign_sso_data</a> (size_type count, value_type ch)</td></tr>
<tr class="memdesc:a324dcc22b9a9645f6dda753b5dea1d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sso data.  <a href="#a324dcc22b9a9645f6dda753b5dea1d0a">More...</a><br /></td></tr>
<tr class="separator:a324dcc22b9a9645f6dda753b5dea1d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe08fb402d6b54fbeb39b37873a46438"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abe08fb402d6b54fbeb39b37873a46438">assign_sso_data</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:abe08fb402d6b54fbeb39b37873a46438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sso data.  <a href="#abe08fb402d6b54fbeb39b37873a46438">More...</a><br /></td></tr>
<tr class="separator:abe08fb402d6b54fbeb39b37873a46438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9a8a9b74ac31f6d51d3ec7bc39608d28">assign_large_data</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize non_sso.data - call constructor of non_sso.data.  <a href="#a9a8a9b74ac31f6d51d3ec7bc39608d28">More...</a><br /></td></tr>
<tr class="separator:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec5e26ebc171a87b8c2c1f86c478cd"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad3ec5e26ebc171a87b8c2c1f86c478cd">assign_large_data</a> (size_type count, value_type ch)</td></tr>
<tr class="memdesc:ad3ec5e26ebc171a87b8c2c1f86c478cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize non_sso.data - call constructor of non_sso.data.  <a href="#ad3ec5e26ebc171a87b8c2c1f86c478cd">More...</a><br /></td></tr>
<tr class="separator:ad3ec5e26ebc171a87b8c2c1f86c478cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf74f8756e3419052aaa769b6ddf6879"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf74f8756e3419052aaa769b6ddf6879">assign_large_data</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aaf74f8756e3419052aaa769b6ddf6879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize non_sso.data - call constructor of non_sso.data.  <a href="#aaf74f8756e3419052aaa769b6ddf6879">More...</a><br /></td></tr>
<tr class="separator:aaf74f8756e3419052aaa769b6ddf6879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d5a536acb228fc3beb1a90bf36658"><td class="memItemLeft" align="right" valign="top"><a id="a464d5a536acb228fc3beb1a90bf36658"></a>
<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a464d5a536acb228fc3beb1a90bf36658">get_pool</a> () const</td></tr>
<tr class="memdesc:a464d5a536acb228fc3beb1a90bf36658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pool_base</a> instance and assert that object is on pmem. <br /></td></tr>
<tr class="separator:a464d5a536acb228fc3beb1a90bf36658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e98e3724230ea38be1c64a5d37fcd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8e98e3724230ea38be1c64a5d37fcd23">check_pmem</a> () const</td></tr>
<tr class="separator:a8e98e3724230ea38be1c64a5d37fcd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe6cb60642353c8b1ced86492d94513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#acbe6cb60642353c8b1ced86492d94513">check_tx_stage_work</a> () const</td></tr>
<tr class="separator:acbe6cb60642353c8b1ced86492d94513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f220a35a83a3f4d1770b022c7d82043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9f220a35a83a3f4d1770b022c7d82043">check_pmem_tx</a> () const</td></tr>
<tr class="separator:a9f220a35a83a3f4d1770b022c7d82043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bdda99ef278b569dee0ee3bf5aac71"><td class="memItemLeft" align="right" valign="top"><a id="a97bdda99ef278b569dee0ee3bf5aac71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a97bdda99ef278b569dee0ee3bf5aac71">add_sso_to_tx</a> (size_type first, size_type num) const</td></tr>
<tr class="memdesc:a97bdda99ef278b569dee0ee3bf5aac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot sso data. <br /></td></tr>
<tr class="separator:a97bdda99ef278b569dee0ee3bf5aac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8ed5036d8df793db33592de6a946f7"><td class="memItemLeft" align="right" valign="top"><a id="a6e8ed5036d8df793db33592de6a946f7"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6e8ed5036d8df793db33592de6a946f7">get_sso_size</a> () const</td></tr>
<tr class="memdesc:a6e8ed5036d8df793db33592de6a946f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of sso string. <br /></td></tr>
<tr class="separator:a6e8ed5036d8df793db33592de6a946f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510f39d64c6f3385a834287d0810d88"><td class="memItemLeft" align="right" valign="top"><a id="ad510f39d64c6f3385a834287d0810d88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad510f39d64c6f3385a834287d0810d88">enable_sso</a> ()</td></tr>
<tr class="memdesc:ad510f39d64c6f3385a834287d0810d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable sso string. <br /></td></tr>
<tr class="separator:ad510f39d64c6f3385a834287d0810d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fe00a2770ad0554a4b156df49effc7"><td class="memItemLeft" align="right" valign="top"><a id="a94fe00a2770ad0554a4b156df49effc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a94fe00a2770ad0554a4b156df49effc7">disable_sso</a> ()</td></tr>
<tr class="memdesc:a94fe00a2770ad0554a4b156df49effc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sso string. <br /></td></tr>
<tr class="separator:a94fe00a2770ad0554a4b156df49effc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3bc6dde318282d9ebeb8a696678665"><td class="memItemLeft" align="right" valign="top"><a id="a7d3bc6dde318282d9ebeb8a696678665"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7d3bc6dde318282d9ebeb8a696678665">set_sso_size</a> (size_type new_size)</td></tr>
<tr class="memdesc:a7d3bc6dde318282d9ebeb8a696678665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size for sso. <br /></td></tr>
<tr class="separator:a7d3bc6dde318282d9ebeb8a696678665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2560487847d51b525572657ca25c0638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2560487847d51b525572657ca25c0638">sso_to_large</a> (size_t new_capacity)</td></tr>
<tr class="memdesc:a2560487847d51b525572657ca25c0638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize sso string to large string.  <a href="#a2560487847d51b525572657ca25c0638">More...</a><br /></td></tr>
<tr class="separator:a2560487847d51b525572657ca25c0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14112c493bbcf4cc127095cfc4c6f53e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a14112c493bbcf4cc127095cfc4c6f53e">large_to_sso</a> ()</td></tr>
<tr class="memdesc:a14112c493bbcf4cc127095cfc4c6f53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize large string to sso string of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> size.  <a href="#a14112c493bbcf4cc127095cfc4c6f53e">More...</a><br /></td></tr>
<tr class="separator:a14112c493bbcf4cc127095cfc4c6f53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="memItemLeft" >union {</td></tr>
<tr class="memitem:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This union holds sso data inside of an array and non sso data inside a vector.  <a href="#a87ed0f5bec8217c4235bd9e5185e1ffe">More...</a><br /></td></tr>
<tr class="separator:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt;<br />
class pmem::obj::experimental::basic_string&lt; CharT, Traits &gt;</h3>

<p>pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible interface. </p>
<p>The implementation is NOT complete. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7d13876f6b7705e0dfdae08acacfaa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d13876f6b7705e0dfdae08acacfaa7f">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Construct an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49c936dff4606f9e09cf178c0d3359e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c936dff4606f9e09cf178c0d3359e2">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the container with count copies of elements with value ch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf58e1bcd43a7213f5fbd44bce006b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf58e1bcd43a7213f5fbd44bce006b21">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with a substring [pos, min(pos+count, other.size()) of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8cd193ab8204565648bb5ca999cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8cd193ab8204565648bb5ca999cd50">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with a substring [pos, min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89a255c1d207f2773e1d95c33fc57f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a255c1d207f2773e1d95c33fc57f4b">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with the first count elements of C-style string s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the resulting string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f174d78e65b57d2a81cd3a31d677fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f174d78e65b57d2a81cd3a31d677fca">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with the contents of s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46adde6ad12bdfd544e6e1d5204bc665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46adde6ad12bdfd544e6e1d5204bc665">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with the contents of the range [first, last). </p>
<p>This constructor only participates in overload resolution if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to end of the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a062405734d14101836de1617cfaa088c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062405734d14101836de1617cfaa088c">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Construct the string with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c7b15b783291d3bd60ffbc7490e761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7b15b783291d3bd60ffbc7490e761c">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Construct the string with the copy of the contents of std::basic_string&lt;CharT&gt; other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the std::basic_string&lt;CharT&gt; to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4233c850af185b3c164d3749b0455fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4233c850af185b3c164d3749b0455fe">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Construct the string with the contents of other using move semantics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the string to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a1f3c8d134020fb77020005d68f6f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1f3c8d134020fb77020005d68f6f7d">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2846936f4c528d98782ac959020347a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2846936f4c528d98782ac959020347a">&#9670;&nbsp;</a></span>~basic_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::~<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>XXX: implement free_data() </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b3e6cd3ac6395a99501919abe4091b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3e6cd3ac6395a99501919abe4091b5">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate storage for container of capacity bytes. </p>
<p>Based on capacity determine if sso or large string is used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>data must be uninitialized. </dd>
<dd>
must be called in transaction scope.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8dbad2006284b8c56352fb3830223cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dbad2006284b8c56352fb3830223cc">&#9670;&nbsp;</a></span>append() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append count copies of character ch to the string transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character value to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa030fc48fb50b22f97b83dc92e3c0375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa030fc48fb50b22f97b83dc92e3c0375">&#9670;&nbsp;</a></span>append() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append string str transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + str.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb74e7c883572ffd23212cc373a6ae21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb74e7c883572ffd23212cc373a6ae21">&#9670;&nbsp;</a></span>append() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append substring [pos, pos + count) of str string transactionally. </p>
<p>Length of the string to append is determined as the smaller of count and str.size() - pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>index of the first character to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos &lt;= str.size()</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::min(count, str.size() - pos). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos &gt; str.size(). </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc34ce145038070a7ff4236cd44f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc34ce145038070a7ff4236cd44f741">&#9670;&nbsp;</a></span>append() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters in the range [s, s + count) transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab683cabdae64c92252c98aa6502be6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab683cabdae64c92252c98aa6502be6ec">&#9670;&nbsp;</a></span>append() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append C-style string transactionally. </p>
<p>Length of the string is determined by the first null character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + traits::length(s). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1407ac483de831d458c605ead38a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1407ac483de831d458c605ead38a88">&#9670;&nbsp;</a></span>append() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters from the ilist initializer list transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with characters to append from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::distance(<a class="el" href="array_8hpp.html#ad806dbb16c66eb3055bd249dbd675726" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a51fbfe71ad89d817a95b324aac1d4a1b" title="Non-member end.">ilist.end()</a>) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeb50bb73a285a1086ba23f7766b36f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb50bb73a285a1086ba23f7766b36f7">&#9670;&nbsp;</a></span>append() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters in the range [first, last) transactionally. </p>
<p>This overload participates in overload resolution only if InputIt qualifies as InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01745c1b661b5977eda2f441e591cadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01745c1b661b5977eda2f441e591cadf">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with count copies of character ch transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a852c852210485a71e0827ed0e3037762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852c852210485a71e0827ed0e3037762">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string with the copy of the contents of other transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd36b026a014784c8fd5a9ecb7fd5b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd36b026a014784c8fd5a9ecb7fd5b91">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string with the copy of the contents of std::basic_string&lt;CharT&gt; other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the std::basic_string&lt;CharT&gt; to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d79b5ecc846ec185a33c4a4468312dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d79b5ecc846ec185a33c4a4468312dc">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with a substring [pos, std::min(pos+count, other.size()) of other transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0035d5d07c15fcedd54b5ede00e7c298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0035d5d07c15fcedd54b5ede00e7c298">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with a substring [pos, std::min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adabefb7329119f1f5d0e479bbe7f9668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabefb7329119f1f5d0e479bbe7f9668">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with the first count elements of C-style string s transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fe2bc8a8e9ca67e19e001ca6613d819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe2bc8a8e9ca67e19e001ca6613d819">&#9670;&nbsp;</a></span>assign() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with copy of C-style string s transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4ce02d1ea4365b52365d4803410293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4ce02d1ea4365b52365d4803410293">&#9670;&nbsp;</a></span>assign() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string with the contents of other using move semantics transactionally. </p>
<p>Other is left in valid state with size equal to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the string to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac70f97749d40640d52cebf64762a40c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70f97749d40640d52cebf64762a40c7">&#9670;&nbsp;</a></span>assign() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replace_content the contents with those of the initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer_list of characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9454e658d7ff8cb2244bdcb2338e658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9454e658d7ff8cb2244bdcb2338e658">&#9670;&nbsp;</a></span>assign() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with copies of elements in the range [first, last) transactionally. </p>
<p>This function participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to end of the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8a9b74ac31f6d51d3ec7bc39608d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a9b74ac31f6d51d3ec7bc39608d28">&#9670;&nbsp;</a></span>assign_large_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_large_data </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize non_sso.data - call constructor of non_sso.data. </p>
<p>Overload for pair of iterators. </p>

</div>
</div>
<a id="ad3ec5e26ebc171a87b8c2c1f86c478cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ec5e26ebc171a87b8c2c1f86c478cd">&#9670;&nbsp;</a></span>assign_large_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_large_data </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize non_sso.data - call constructor of non_sso.data. </p>
<p>Overload for (count, value). </p>

</div>
</div>
<a id="aaf74f8756e3419052aaa769b6ddf6879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf74f8756e3419052aaa769b6ddf6879">&#9670;&nbsp;</a></span>assign_large_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_large_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize non_sso.data - call constructor of non_sso.data. </p>
<p>Overload for rvalue reference of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a>. </p>

</div>
</div>
<a id="a11d811ceb9088d3cc3a21ab89195a492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d811ceb9088d3cc3a21ab89195a492">&#9670;&nbsp;</a></span>assign_sso_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_sso_data </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sso data. </p>
<p>Overload for pair of iterators </p>

</div>
</div>
<a id="a324dcc22b9a9645f6dda753b5dea1d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324dcc22b9a9645f6dda753b5dea1d0a">&#9670;&nbsp;</a></span>assign_sso_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_sso_data </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sso data. </p>
<p>Overload for (count, value). </p>

</div>
</div>
<a id="abe08fb402d6b54fbeb39b37873a46438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe08fb402d6b54fbeb39b37873a46438">&#9670;&nbsp;</a></span>assign_sso_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_sso_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sso data. </p>
<p>Overload for rvalue reference of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a>. </p>

</div>
</div>
<a id="a114ee8aa04b5200d10589ca9d8ace785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114ee8aa04b5200d10589ca9d8ace785">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking and snapshot it if there is an active transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc7c8867a952de3388819e8b911347d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc7c8867a952de3388819e8b911347d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf75feee0c5a6d8b5dec8dd9cde24bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf75feee0c5a6d8b5dec8dd9cde24bed">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element and snapshot it if there is an active transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to last element in string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4dfa7c2d10786a2837a36981b4b1440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dfa7c2d10786a2837a36981b4b1440">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to last element in string. </dd></dl>

</div>
</div>
<a id="ae84575172811e6af3fa4735f6c98fb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84575172811e6af3fa4735f6c98fb46">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first element in the string. </dd></dl>

</div>
</div>
<a id="ae6b726ea004e140eaedd644510a34fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b726ea004e140eaedd644510a34fe4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const iterator pointing to the first element in the string. </dd></dl>

</div>
</div>
<a id="a92e9ca34c0b5b017cd5817360930e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e9ca34c0b5b017cd5817360930e152">&#9670;&nbsp;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>pointer to underlying data. </dd></dl>

</div>
</div>
<a id="ae688b8f07ddcd5314de694e4ef91dad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae688b8f07ddcd5314de694e4ef91dad8">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of characters that can be held in currently allocated storage. </dd></dl>

</div>
</div>
<a id="a37b9e19d268d06cfbdae3d274a99da02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b9e19d268d06cfbdae3d274a99da02">&#9670;&nbsp;</a></span>cback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adf75feee0c5a6d8b5dec8dd9cde24bed" title="Access last element and snapshot it if there is an active transaction.">back()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02" title="Access last element.">cback()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::basic_string doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02" title="Access last element.">cback()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const reference to last element in string. </dd></dl>

</div>
</div>
<a id="a5b8faca84731379e1ff9c794643b2e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8faca84731379e1ff9c794643b2e33">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const iterator pointing to the first element in the string. </dd></dl>

</div>
</div>
<a id="a924a8b0829e7c20a71a322f7507dc966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a8b0829e7c20a71a322f7507dc966">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const pointer to underlying data. </dd></dl>

</div>
</div>
<a id="aa8f708491eb1ba92834e12a25b3b273f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f708491eb1ba92834e12a25b3b273f">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the string. </dd></dl>

</div>
</div>
<a id="adb2e2613e5b2cb491cddd071bc7d3b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e2613e5b2cb491cddd071bc7d3b39">&#9670;&nbsp;</a></span>cfront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cfront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0a95614480a2ad9c7fa4279c7ff7a40f" title="Access first element and snapshot it if there is an active transaction.">front()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39" title="Access first element.">cfront()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::basic_string doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39" title="Access first element.">cfront()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const reference to first element in string. </dd></dl>

</div>
</div>
<a id="a8e98e3724230ea38be1c64a5d37fcd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e98e3724230ea38be1c64a5d37fcd23">&#9670;&nbsp;</a></span>check_pmem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::check_pmem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f220a35a83a3f4d1770b022c7d82043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f220a35a83a3f4d1770b022c7d82043">&#9670;&nbsp;</a></span>check_pmem_tx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::check_pmem_tx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called outside of a transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbe6cb60642353c8b1ced86492d94513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe6cb60642353c8b1ced86492d94513">&#9670;&nbsp;</a></span>check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::check_tx_stage_work </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called outside of a transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab48a06395ce0af510bbea55c0805ce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48a06395ce0af510bbea55c0805ce07">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all characters from the string transactionally. </p>
<p>All pointers, references, and iterators are invalidated.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037abcc78fa96219dc1a24587d628de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037abcc78fa96219dc1a24587d628de6">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this string to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if *this &lt; other in lexicographical order, zero if *this == other and positive value if *this &gt; other. </dd></dl>

</div>
</div>
<a id="ac74c804f16487c05db4208fe1d29224c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c804f16487c05db4208fe1d29224c">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this string to std::basic_string&lt;CharT&gt; other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if *this &lt; other in lexicographical order, zero if *this == other and positive value if *this &gt; other. </dd></dl>

</div>
</div>
<a id="aa1a06c0ef69676e35b6bd3cfdce3762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a06c0ef69676e35b6bd3cfdce3762e">&#9670;&nbsp;</a></span>compare() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count) substring of this to other. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring &lt; other in lexicographical order, zero if substring == other and positive value if substring &gt; other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bcef57c33ff14f67e4651119c4d3d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcef57c33ff14f67e4651119c4d3d55">&#9670;&nbsp;</a></span>compare() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count) substring of this to std::basic_string&lt;CharT&gt; other. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring &lt; other in lexicographical order, zero if substring == other and positive value if substring &gt; other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad3ed854a3ed1e5ebf5f7fb7569209e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3ed854a3ed1e5ebf5f7fb7569209e4">&#9670;&nbsp;</a></span>compare() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of other. </p>
<p>If count1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos1, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos1</td><td>beginning of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count1</td><td>length of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos2</td><td>beginning of substring of other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of substring of other.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring of *this &lt; substring of other in lexicographical order, zero if substring of *this == substring of other and positive value if substring of *this &gt; substring of other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> or pos2 &gt; other.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f371ce3428c15e1547a7b055c49850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f371ce3428c15e1547a7b055c49850d">&#9670;&nbsp;</a></span>compare() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of std::basic_string&lt;CharT&gt; other. </p>
<p>If count1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos1, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos1</td><td>beginning of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count1</td><td>length of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos2</td><td>beginning of substring of other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of substring of other.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring of *this &lt; substring of other in lexicographical order, zero if substring of *this == substring of other and positive value if substring of *this &gt; substring of other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> or pos2 &gt; other.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26dfaa2fc3d30c4b615bb345c5a900ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dfaa2fc3d30c4b615bb345c5a900ac">&#9670;&nbsp;</a></span>compare() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this string to s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>C-style string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if *this &lt; s in lexicographical order, zero if *this == s and positive value if *this &gt; s. </dd></dl>

</div>
</div>
<a id="ad769eb94ffb310cdc279191c27df73cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad769eb94ffb310cdc279191c27df73cd">&#9670;&nbsp;</a></span>compare() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count) substring of this to s. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>C-style string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring &lt; s in lexicographical order, zero if substring == s and positive value if substring &gt; s.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a763cffb1f2439ca5fb0a107142fb15f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763cffb1f2439ca5fb0a107142fb15f5">&#9670;&nbsp;</a></span>compare() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count1) substring of this to [s, s + count2) substring of s. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count1</td><td>length of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>C-style string to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of substring of s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring of *this &lt; substring of s in lexicographical order, zero if substring of *this == substring of s and positive value if substring of *this &gt; substring of s.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6347729401d23409ae8e3c20cbbdfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6347729401d23409ae8e3c20cbbdfa4">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a114ee8aa04b5200d10589ca9d8ace785" title="Access element at specific index with bounds checking and snapshot it if there is an active transacti...">at()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4" title="Access element at specific index with bounds checking.">const_at()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::basic_string doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4" title="Access element at specific index with bounds checking.">const_at()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada2cc6b2a19aefdb0ae49fb42e217cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2cc6b2a19aefdb0ae49fb42e217cb7">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy [index, index + count) substring of *this to C-style string. </p>
<p>If either count == npos or count exceeds size of *this string then substring [index, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>) is used. Resulting C-style string is not null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to destination C-style string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>start of the substring that will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of copied characters.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a550ba03ad47efe24c30fff1b4c2548b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ba03ad47efe24c30fff1b4c2548b7">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reverse iterator pointing to the last element in non-reversed string. </dd></dl>

</div>
</div>
<a id="a2d27e932b80a8f6572055fdbca5fa368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d27e932b80a8f6572055fdbca5fa368">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const reverse iterator referring to character preceding first character in the non-reversed string. </dd></dl>

</div>
</div>
<a id="a19ce85e96d0137d8407f1abe6bb74dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ce85e96d0137d8407f1abe6bb74dd4">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>pointer to underlying data.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding data to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26afd5f7d0bae52907053cd7bf96cf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26afd5f7d0bae52907053cd7bf96cf25">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>pointer to underlying data. </dd></dl>

</div>
</div>
<a id="abe1c0f6e18623b888cb65dae95a9d79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1c0f6e18623b888cb65dae95a9d79d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if string is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a526ba2aa7a34084c46018888f67cc9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526ba2aa7a34084c46018888f67cc9d4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the string. </dd></dl>

</div>
</div>
<a id="a0e2c8133289e2290e7d476eb65294f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c8133289e2290e7d476eb65294f4f">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the string. </dd></dl>

</div>
</div>
<a id="a271994efb0040688a3feb7d5392c253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271994efb0040688a3feb7d5392c253b">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove characters from string starting at index transactionally. </p>
<p>Length of the string to erase is determined as the smaller of count and <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>first character to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>index &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::min(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad94c51bfd094b006063e77603cad10f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94c51bfd094b006063e77603cad10f3">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove character from string at pos position transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>position of character to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the removed element. If the iterator pos refers to the last element, the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4" title="Return an iterator to past the end.">end()</a> iterator is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - 1</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2efe18b1b78afcfaf8b715daa3276a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efe18b1b78afcfaf8b715daa3276a49">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove characters from string at [first, last) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator which points to the element pointed by the last iterator before the erase operation. If no such element exists then <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4" title="Return an iterator to past the end.">end()</a> iterator is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>first and last are valid iterators on *this.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if [first, last) is not a valid range of *this. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4a254b366ac8a14024171dafe32336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a254b366ac8a14024171dafe32336b">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Participate in overload resolution only if T is not convertible to size_type. </p>
<p>Call iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad94c51bfd094b006063e77603cad10f3" title="Remove character from string at pos position transactionally.">erase(const_iterator pos)</a> if enabled. </p>

</div>
</div>
<a id="a7bdd408b3929ce784004ccc236c085f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdd408b3929ce784004ccc236c085f8">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Participate in overload resolution only if T is convertible to size_type. </p>
<p>Call <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;erase(size_type index, size_type count = npos) if enabled. </p>

</div>
</div>
<a id="a0a95614480a2ad9c7fa4279c7ff7a40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a95614480a2ad9c7fa4279c7ff7a40f">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element and snapshot it if there is an active transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1290019d34af257ce831aa51800f4c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1290019d34af257ce831aa51800f4c1f">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to first element in string. </dd></dl>

</div>
</div>
<a id="a7a73397ef9970aff7df1e67b3212a3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a73397ef9970aff7df1e67b3212a3ef">&#9670;&nbsp;</a></span>get_size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of generic get_size method used to calculate size based on provided parameters. </p>
<p>Return std::distance(first, last) for pair of iterators. </p>

</div>
</div>
<a id="a1d4e4fe677319c6477085637e5b178c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4e4fe677319c6477085637e5b178c3">&#9670;&nbsp;</a></span>get_size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of generic get_size method used to calculate size based on provided parameters. </p>
<p>Return count for (count, value) </p>

</div>
</div>
<a id="a78a54981fd56128506298de2317e5b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a54981fd56128506298de2317e5b4f">&#9670;&nbsp;</a></span>get_size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of generic get_size method used to calculate size based on provided parameters. </p>
<p>Return size of other <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> </p>

</div>
</div>
<a id="a04af91240ccce74722307c1c8480be1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04af91240ccce74722307c1c8480be1e">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function which initializes memory based on provided parameters - forwards parameters to initialize function of either non_sso.data or sso.data. </p>
<p>Allowed parameters are:</p><ul>
<li>size_type count, CharT value</li>
<li>InputIt first, InputIt last</li>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;&amp;</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
memory must be allocated before initialization. </dd></dl>

</div>
</div>
<a id="aa8cc08ce035aefdca9c5902ea5daf69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cc08ce035aefdca9c5902ea5daf69c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert count copies of ch character at index transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>position at which the content will be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4219eb8c6db9c309c40076d920a41a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4219eb8c6db9c309c40076d920a41a9b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert null-terminated C-style string pointed by s of the length determined by the first null character at index transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>position at which the content will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + traits::length(s). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a791f57776354054d380f8cbb5dff8fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791f57776354054d380f8cbb5dff8fe1">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert characters in the range [s, s+ count) at index transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>position at which the content will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35f24dbfac5cb9144a0bf682b4afe9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f24dbfac5cb9144a0bf682b4afe9a8">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert str string at index transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>position at which the content will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + str.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98baa99c0ddef1a7799c103bc71e43b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98baa99c0ddef1a7799c103bc71e43b3">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a str.substr(index2, count) string at index1 transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index1</td><td>position at which the content will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index2</td><td>position of the first character in str to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::min(count, str.size() - index2) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> or str.size() &gt; index2. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2ce3312e00ca19d73f329139fb9dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ce3312e00ca19d73f329139fb9dc4c">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert character ch before the character pointed by pos transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the character will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the copy of the first inserted character or pos if no characters were inserted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos is valid iterator on *this.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + 1 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fb62bcf4fc3a19b34f573c948e9c8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb62bcf4fc3a19b34f573c948e9c8f9">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert count copies of character ch before the character pointed by pos transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the character will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the copy of the first inserted character or pos if no characters were inserted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos is valid iterator on *this.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d6c82e794b70af46623aeec8d9a5182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6c82e794b70af46623aeec8d9a5182">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert characters from [first, last) range before the character pointed by pos transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the character will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the copy of the first inserted character or pos if no characters were inserted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos is valid iterator on *this.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f03f1c273cd028f6083c4bc45d8b525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f03f1c273cd028f6083c4bc45d8b525">&#9670;&nbsp;</a></span>insert() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert characters from initializer list ilist before the character pointed by pos transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the character will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list of characters to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the copy of the first inserted character or pos if no characters were inserted.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos is valid iterator on *this.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + ilist.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a482415e51110c3dda72cfa841be63661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482415e51110c3dda72cfa841be63661">&#9670;&nbsp;</a></span>insert() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Participate in overload resolution only if T is not convertible to size_type. </p>
<p>Call iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0fb62bcf4fc3a19b34f573c948e9c8f9" title="Insert count copies of character ch before the character pointed by pos transactionally.">insert(const_iterator pos, size_type count, CharT ch)</a> if enabled. </p>

</div>
</div>
<a id="ab65fcd6dfc161897f32529f3144edd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65fcd6dfc161897f32529f3144edd9f">&#9670;&nbsp;</a></span>insert() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Participate in overload resolution only if T is convertible to size_type. </p>
<p>Call <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa8cc08ce035aefdca9c5902ea5daf69c" title="Insert count copies of ch character at index transactionally.">insert(size_type index, size_type count, CharT ch)</a> if enabled. </p>

</div>
</div>
<a id="a14112c493bbcf4cc127095cfc4c6f53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14112c493bbcf4cc127095cfc4c6f53e">&#9670;&nbsp;</a></span>large_to_sso()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::large_to_sso </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize large string to sso string of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> size. </p>
<p>Content of large string is preserved and copied to the sso string.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> of large string must be less than or equal sso_capacity</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sso is used. </dd></dl>

</div>
</div>
<a id="a7ad312f37adadcbbf3396945fa685165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad312f37adadcbbf3396945fa685165">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of CharT elements in the string. </dd></dl>

</div>
</div>
<a id="aa41f64c4d254dac34bde1a6e475e5585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41f64c4d254dac34bde1a6e475e5585">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the string is able to hold. </dd></dl>

</div>
</div>
<a id="ab1002f2f69f122ed33b569df655d0c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1002f2f69f122ed33b569df655d0c91">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append string str transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + str.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ca9d5ff7baa72fe12bf94547095ce01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca9d5ff7baa72fe12bf94547095ce01">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append C-style string transactionally. </p>
<p>Length of the string is determined by the first null character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + traits::length(s). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0b261819c79a1fc515fda81fe866ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b261819c79a1fc515fda81fe866ae5">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append character ch at the end of the string transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + 1 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new_size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a067720bf6200336e78a29a8ba385bf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067720bf6200336e78a29a8ba385bf84">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters from the ilist initializer list transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with characters to append from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + ilist.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae25e9887350ba1e523c037e4299613f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25e9887350ba1e523c037e4299613f0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replace the string with contents of other transactionally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8880f3c3282290b40a1a548eeaac6395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8880f3c3282290b40a1a548eeaac6395">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replace the string with contents of std::basic_string&lt;CharT&gt; other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the std::basic_string&lt;CharT&gt; to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339651e065a2f36c8f505ff7bc55e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339651e065a2f36c8f505ff7bc55e689">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replace the string with the contents of other using move semantics transactionally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the string to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f2724d48368f4c61ab0797075031f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2724d48368f4c61ab0797075031f90">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with copy of C-style string s transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04d3972852c0ca602af1388d0695c9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d3972852c0ca602af1388d0695c9c2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with character ch transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43c9ce280f65d22e0d01fd961c8fc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43c9ce280f65d22e0d01fd961c8fc27">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with those of the initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer_list of characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13a43584f35e464b753766f263b98f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a43584f35e464b753766f263b98f6a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and snapshot it if there is an active transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab59f7eaab5e9a72d3c8794d8857576d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59f7eaab5e9a72d3c8794d8857576d3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array. </dd></dl>

</div>
</div>
<a id="a8d659398a61aa62e67af30497d635388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d659398a61aa62e67af30497d635388">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last character from the string transactionally. </p>
<dl class="section pre"><dt>Precondition</dt><dd>!empty()</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - 1</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65a5e19b05069281877348ddd4db3628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a5e19b05069281877348ddd4db3628">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append character ch at the end of the string transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + 1 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0930182af8a2448d010aa603c1495326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0930182af8a2448d010aa603c1495326">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>a reverse iterator pointing to the last element in non-reversed string. </dd></dl>

</div>
</div>
<a id="a8fa6e329ea0d45e17a74e880994f947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa6e329ea0d45e17a74e880994f947e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reverse iterator pointing to the last element in non-reversed string. </dd></dl>

</div>
</div>
<a id="aad1ba265e840da1b926a621ee932e332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1ba265e840da1b926a621ee932e332">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse iterator referring to character preceding first character in the non-reversed string. </dd></dl>

</div>
</div>
<a id="a6e77ec7a6f29e8a004e4e8bbaa262a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e77ec7a6f29e8a004e4e8bbaa262a1c">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const reverse iterator referring to character preceding first character in the non-reversed string. </dd></dl>

</div>
</div>
<a id="a7adb85bb22cdfe364fd86522715b9cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adb85bb22cdfe364fd86522715b9cc7">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [index, index + count) with the content of str string transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>start of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>that is used for the replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - (std::min)(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index) + str.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa67fec31d082d87e37e4a2cfa1c305cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67fec31d082d87e37e4a2cfa1c305cf">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [first, last) with the content of str string transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>that that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last) + str.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce0713ff9aad5d746cfa900090c3526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce0713ff9aad5d746cfa900090c3526">&#9670;&nbsp;</a></span>replace() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [index, index + count) with the substring [index2, index2 + count2) of str string transactionally. </p>
<p>If either count2 == npos or count2 exceeds size of str string then substring [index2, str.size()) is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>start of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>that is used for the replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index2</td><td>start of the substring that will be used for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of the substring that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - (std::min)(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index) + (std::min)(count2, str.size() - index2) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> or index2 &gt; str.size(). </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee7a7c666edcdb9c703887c5f69700da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7a7c666edcdb9c703887c5f69700da">&#9670;&nbsp;</a></span>replace() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [first, last) with the characters in [s, s + count2) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string that will be used for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>number of characters that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last) + count2. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4a7b5a845d5adb851e3ba2da98151f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a7b5a845d5adb851e3ba2da98151f1">&#9670;&nbsp;</a></span>replace() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [first, last) with the characters in [s, s + traits::length(s)) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last) + traits::length(s). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3792d96269991f9bfc6f76e5de38a250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3792d96269991f9bfc6f76e5de38a250">&#9670;&nbsp;</a></span>replace() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [index, index + count) with count2 copies of ch character transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>start of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>number of characters that will be used for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - (std::min)(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index) + count2. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a2e1246319527843d218f342428a1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2e1246319527843d218f342428a1d8">&#9670;&nbsp;</a></span>replace() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [first, last) with count2 copies of ch character transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>number of characters that will be used for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last) + count2. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b0296c73c9a4ccd2bf1b5dd783257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b0296c73c9a4ccd2bf1b5dd783257f">&#9670;&nbsp;</a></span>replace() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [index, index + count) with the characters in [s, s + count2) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>start of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string that will be used for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>number of characters that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - (std::min)(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index) + count2. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23719386f4d96bb15a61f70b38ad1463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23719386f4d96bb15a61f70b38ad1463">&#9670;&nbsp;</a></span>replace() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [index, index + count) with the characters in [s, s + traits::length(s)) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>start of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - (std::min)(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index) + traits::length(s). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e3b258bbc3e4516c549e521bac5396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e3b258bbc3e4516c549e521bac5396">&#9670;&nbsp;</a></span>replace() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [first, last) with characters in initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list of characters that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last) + ilist.size(). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac81a9751029d6d8a80c529e1e977a586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81a9751029d6d8a80c529e1e977a586">&#9670;&nbsp;</a></span>replace() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace range [first, last) with the characters in [first2, last2) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters that will be replaced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>begin of the range of characters that will be used for replacement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last2</td><td>end of the range of characters that will be used for replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last) + std::distance(first2, last2). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a4ec3a9d3097de676a19b090d2eadbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4ec3a9d3097de676a19b090d2eadbc">&#9670;&nbsp;</a></span>replace_content()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace_content </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function which replace_content current content based on provided parameters. </p>
<p>Allowed parameters are:</p><ul>
<li>size_type count, CharT value</li>
<li>InputIt first, InputIt last</li>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;&amp; </li>
</ul>

</div>
</div>
<a id="a4eb5f5ee3bf50b379aea23497bbd1643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb5f5ee3bf50b379aea23497bbd1643">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_cap</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the capacity of the string to new_cap transactionally. </p>
<p>If new_cap is greater than the current <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a>, new storage is allocated, otherwise the method does nothing. If new_cap is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_cap</td><td>new capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == max(capacity(), capacity_new)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new_cap &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9f2e06a142986d71fd4281d1a1c1e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f2e06a142986d71fd4281d1a1c1e67">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the string to count characters transactionally. </p>
<p>If the current size is greater than count, the string is reduced to its first count elements. If the current size is less than count, additional characters of ch value are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to initialize elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == std::max(count, capacity()) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a> </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8277ae71bc4e95ee236a187a9251f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8277ae71bc4e95ee236a187a9251f452">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT, typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the string to count characters transactionally. </p>
<p>If the current size is greater than count, the string is reduced to its first count elements. If the current size is less than count, additional default-initialized characters are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == std::max(count, capacity()) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a> </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce135d86a3cb44379de7d00d174d3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce135d86a3cb44379de7d00d174d3d5">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unused capacity transactionally. </p>
<p>If large string is used capacity will be set to current size. If sso is used nothing happens.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == std::min(sso_capacity, capacity())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when reallocating failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10d70fe47d10ff8af64ece41610b0c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d70fe47d10ff8af64ece41610b0c2c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of CharT elements in the string. </dd></dl>

</div>
</div>
<a id="a2560487847d51b525572657ca25c0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2560487847d51b525572657ca25c0638">&#9670;&nbsp;</a></span>sso_to_large()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::sso_to_large </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize sso string to large string. </p>
<p>Capacity is equal new_capacity plus sizeof(CharT) bytes for null character. Content of sso string is preserved and copied to the large string object.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sso is not used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_capacity</td><td>capacity of constructed large string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a87ed0f5bec8217c4235bd9e5185e1ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ed0f5bec8217c4235bd9e5185e1ffe">&#9670;&nbsp;</a></span>@3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... } </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This union holds sso data inside of an array and non sso data inside a vector. </p>
<p>If vector is used, it must be manually created and destroyed.</p>
<p>_size is used to store length in case when SSO is used. It is the same type as first member of data field. This means that it can be safely accessed through both sso (_size variable) and non_sso (as size in a vector) no matter which one is used.</p>
<p>C++11 §9.2/18 says: If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="basic__string_8hpp_source.html">basic_string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
