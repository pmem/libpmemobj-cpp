<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::self_relative_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git107.g7e59f08f</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::self_relative_ptr&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__primitives.html">Primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent self-relative pointer class.  
 <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="self__relative__ptr_8hpp_source.html">libpmemobj++/experimental/self_relative_ptr.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pmem::obj::experimental::self_relative_ptr&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr__inherit__graph.png" border="0" usemap="#apmem_1_1obj_1_1experimental_1_1self__relative__ptr_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="apmem_1_1obj_1_1experimental_1_1self__relative__ptr_3_01T_01_4_inherit__map" id="apmem_1_1obj_1_1experimental_1_1self__relative__ptr_3_01T_01_4_inherit__map">
<area shape="rect" title="Persistent self&#45;relative pointer class." alt="" coords="5,80,171,121"/>
<area shape="rect" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html" title="self_relative_ptr base template class" alt="" coords="14,5,162,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad0630266cfe0ed6e39268f4fc2309eec"><td class="memItemLeft" align="right" valign="top"><a id="ad0630266cfe0ed6e39268f4fc2309eec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>base_type</b> = <a class="el" href="namespacepmem_1_1obj_1_1experimental.html#af58574af7907e31bc547b8b79afbb9cc">self_relative_ptr_base</a></td></tr>
<tr class="separator:ad0630266cfe0ed6e39268f4fc2309eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8561a13cf93b6955a24c3f14a55731"><td class="memItemLeft" align="right" valign="top"><a id="a3a8561a13cf93b6955a24c3f14a55731"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a></td></tr>
<tr class="separator:a3a8561a13cf93b6955a24c3f14a55731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130fab846aa69aa5c89a19c6ac995afb"><td class="memItemLeft" align="right" valign="top"><a id="a130fab846aa69aa5c89a19c6ac995afb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_type</b> = typename pmem::detail::sp_element&lt; T &gt;::type</td></tr>
<tr class="separator:a130fab846aa69aa5c89a19c6ac995afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59315a07c5d3bfd6a761ac17007b23a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">iterator_category</a> = std::random_access_iterator_tag</td></tr>
<tr class="memdesc:ad59315a07c5d3bfd6a761ac17007b23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator requirements (members)  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">More...</a><br /></td></tr>
<tr class="separator:ad59315a07c5d3bfd6a761ac17007b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51ab4e13db7e2fb4e9ffae1cc49ca78"><td class="memItemLeft" align="right" valign="top"><a id="ac51ab4e13db7e2fb4e9ffae1cc49ca78"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a> = typename base_type::difference_type</td></tr>
<tr class="memdesc:ac51ab4e13db7e2fb4e9ffae1cc49ca78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> difference type. <br /></td></tr>
<tr class="separator:ac51ab4e13db7e2fb4e9ffae1cc49ca78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd724ab1b48eea1fdf7ca077e10078"><td class="memItemLeft" align="right" valign="top"><a id="a48dd724ab1b48eea1fdf7ca077e10078"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a48dd724ab1b48eea1fdf7ca077e10078">value_type</a> = T</td></tr>
<tr class="memdesc:a48dd724ab1b48eea1fdf7ca077e10078"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a>. <br /></td></tr>
<tr class="separator:a48dd724ab1b48eea1fdf7ca077e10078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e38c1e94f1f6e44e06fa69361b8902"><td class="memItemLeft" align="right" valign="top"><a id="a14e38c1e94f1f6e44e06fa69361b8902"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a14e38c1e94f1f6e44e06fa69361b8902">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a14e38c1e94f1f6e44e06fa69361b8902"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a>. <br /></td></tr>
<tr class="separator:a14e38c1e94f1f6e44e06fa69361b8902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff9353df4900b52759394918b326d3f"><td class="memItemLeft" align="right" valign="top"><a id="adff9353df4900b52759394918b326d3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>offset_type</b> = OffsetType</td></tr>
<tr class="separator:adff9353df4900b52759394918b326d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f161e15b3ec4e440d4f9f0a44df58e"><td class="memItemLeft" align="right" valign="top"><a id="a84f161e15b3ec4e440d4f9f0a44df58e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>byte_type</b> = uint8_t</td></tr>
<tr class="separator:a84f161e15b3ec4e440d4f9f0a44df58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347de0fe1ae5b455b029c26fb6b0345c"><td class="memItemLeft" align="right" valign="top"><a id="a347de0fe1ae5b455b029c26fb6b0345c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>byte_ptr_type</b> = byte_type *</td></tr>
<tr class="separator:a347de0fe1ae5b455b029c26fb6b0345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf8ea18e8c59139dea683c5cb257e9b"><td class="memItemLeft" align="right" valign="top"><a id="adaf8ea18e8c59139dea683c5cb257e9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_byte_ptr_type</b> = const byte_type *</td></tr>
<tr class="separator:adaf8ea18e8c59139dea683c5cb257e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="memItemLeft" align="right" valign="top"><a id="ac76f6b18f3ff9361c1c71227e5bf2234"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac76f6b18f3ff9361c1c71227e5bf2234">self_relative_ptr</a> () noexcept=default</td></tr>
<tr class="memdesc:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, equal the nullptr. <br /></td></tr>
<tr class="separator:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56034ec07863366fd5354b28e9a18a"><td class="memItemLeft" align="right" valign="top"><a id="acd56034ec07863366fd5354b28e9a18a"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd56034ec07863366fd5354b28e9a18a">self_relative_ptr</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:acd56034ec07863366fd5354b28e9a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr constructor. <br /></td></tr>
<tr class="separator:acd56034ec07863366fd5354b28e9a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0b186cde38f990d3b7c1a9fd7f68c793">self_relative_ptr</a> (element_type *ptr) noexcept</td></tr>
<tr class="memdesc:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile pointer constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0b186cde38f990d3b7c1a9fd7f68c793">More...</a><br /></td></tr>
<tr class="separator:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a00f5397ca70925714e517ef7e5cc66"><td class="memItemLeft" align="right" valign="top"><a id="a4a00f5397ca70925714e517ef7e5cc66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4a00f5397ca70925714e517ef7e5cc66">self_relative_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; ptr) noexcept</td></tr>
<tr class="memdesc:a4a00f5397ca70925714e517ef7e5cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from persistent_ptr&lt;T&gt; <br /></td></tr>
<tr class="separator:a4a00f5397ca70925714e517ef7e5cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6b76812c31a4b81859d25846add4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4ad6b76812c31a4b81859d25846add4b">self_relative_ptr</a> (PMEMoid oid) noexcept</td></tr>
<tr class="memdesc:a4ad6b76812c31a4b81859d25846add4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMEMoid constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4ad6b76812c31a4b81859d25846add4b">More...</a><br /></td></tr>
<tr class="separator:a4ad6b76812c31a4b81859d25846add4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="memItemLeft" align="right" valign="top"><a id="abe947cc99e3e59a738bfa4f3a624fcd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abe947cc99e3e59a738bfa4f3a624fcd9">self_relative_ptr</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;ptr) noexcept</td></tr>
<tr class="memdesc:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </td></tr>
<tr class="memitem:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586">self_relative_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; U &gt; const &amp;r) noexcept</td></tr>
<tr class="memdesc:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a different self_relative_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586">More...</a><br /></td></tr>
<tr class="separator:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c550851f90b7139e588445913fdfb48"><td class="memItemLeft" align="right" valign="top">element_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a9c550851f90b7139e588445913fdfb48">get</a> () const noexcept</td></tr>
<tr class="memdesc:a9c550851f90b7139e588445913fdfb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direct pointer.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a9c550851f90b7139e588445913fdfb48">More...</a><br /></td></tr>
<tr class="separator:a9c550851f90b7139e588445913fdfb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="memItemLeft" align="right" valign="top"><a id="a7cd65672ed7c3bca1cb5eba00f0f89b2"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7cd65672ed7c3bca1cb5eba00f0f89b2">to_persistent_ptr</a> () const</td></tr>
<tr class="memdesc:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to persitent ptr. <br /></td></tr>
<tr class="separator:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="memItemLeft" align="right" valign="top"><a id="ae55b818d5a1bebba2cec1c14b5b03c4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ae55b818d5a1bebba2cec1c14b5b03c4d">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bool conversion operator. <br /></td></tr>
<tr class="separator:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdc2ba22f7b28676888f087f82ae20"><td class="memItemLeft" align="right" valign="top"><a id="a2ecdc2ba22f7b28676888f087f82ae20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2ecdc2ba22f7b28676888f087f82ae20">operator persistent_ptr&lt; T &gt;</a> () const</td></tr>
<tr class="memdesc:a2ecdc2ba22f7b28676888f087f82ae20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:a2ecdc2ba22f7b28676888f087f82ae20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="memItemLeft" align="right" valign="top"><a id="a0988ed48e3632d8c2483d10f94e5b4c7"></a>
pmem::detail::sp_dereference&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0988ed48e3632d8c2483d10f94e5b4c7">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator. <br /></td></tr>
<tr class="separator:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ceb1160a93cf67b2d80ab329757ac"><td class="memItemLeft" align="right" valign="top"><a id="ac52ceb1160a93cf67b2d80ab329757ac"></a>
pmem::detail::sp_member_access&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac52ceb1160a93cf67b2d80ab329757ac">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:ac52ceb1160a93cf67b2d80ab329757ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator. <br /></td></tr>
<tr class="separator:ac52ceb1160a93cf67b2d80ab329757ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb880992038e280590f619cbe8b041"><td class="memTemplParams" colspan="2">template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a95fb880992038e280590f619cbe8b041"><td class="memTemplItemLeft" align="right" valign="top">pmem::detail::sp_array_access&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a95fb880992038e280590f619cbe8b041">operator[]</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a> i) const noexcept</td></tr>
<tr class="memdesc:a95fb880992038e280590f619cbe8b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array access operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a95fb880992038e280590f619cbe8b041">More...</a><br /></td></tr>
<tr class="separator:a95fb880992038e280590f619cbe8b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2283fb5e5ba26aa3a7443a353d062f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2283fb5e5ba26aa3a7443a353d062f49">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;r)</td></tr>
<tr class="memdesc:a2283fb5e5ba26aa3a7443a353d062f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2283fb5e5ba26aa3a7443a353d062f49">More...</a><br /></td></tr>
<tr class="separator:a2283fb5e5ba26aa3a7443a353d062f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70042cf9bf7619af8f9f48409e34cf26"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a70042cf9bf7619af8f9f48409e34cf26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;r)</td></tr>
<tr class="memdesc:a70042cf9bf7619af8f9f48409e34cf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting assignment operator from a different self_relative_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26">More...</a><br /></td></tr>
<tr class="separator:a70042cf9bf7619af8f9f48409e34cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd01402f0ef7b1c9197aede9a9fa1a1c">operator=</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr move assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd01402f0ef7b1c9197aede9a9fa1a1c">More...</a><br /></td></tr>
<tr class="separator:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002055eb8589d7119aef75c62e652e8"><td class="memItemLeft" align="right" valign="top"><a id="a6002055eb8589d7119aef75c62e652e8"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a6002055eb8589d7119aef75c62e652e8">operator++</a> ()</td></tr>
<tr class="memdesc:a6002055eb8589d7119aef75c62e652e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator. <br /></td></tr>
<tr class="separator:a6002055eb8589d7119aef75c62e652e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019147ec67e67e2d0f9844e3356bd549"><td class="memItemLeft" align="right" valign="top"><a id="a019147ec67e67e2d0f9844e3356bd549"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a019147ec67e67e2d0f9844e3356bd549">operator++</a> (int)</td></tr>
<tr class="memdesc:a019147ec67e67e2d0f9844e3356bd549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator. <br /></td></tr>
<tr class="separator:a019147ec67e67e2d0f9844e3356bd549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94e965b7ac0482e796ef889f5222d0"><td class="memItemLeft" align="right" valign="top"><a id="a5b94e965b7ac0482e796ef889f5222d0"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a5b94e965b7ac0482e796ef889f5222d0">operator--</a> ()</td></tr>
<tr class="memdesc:a5b94e965b7ac0482e796ef889f5222d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator. <br /></td></tr>
<tr class="separator:a5b94e965b7ac0482e796ef889f5222d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38720d3605a098774d9aa448d7b70f"><td class="memItemLeft" align="right" valign="top"><a id="a7b38720d3605a098774d9aa448d7b70f"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7b38720d3605a098774d9aa448d7b70f">operator--</a> (int)</td></tr>
<tr class="memdesc:a7b38720d3605a098774d9aa448d7b70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator. <br /></td></tr>
<tr class="separator:a7b38720d3605a098774d9aa448d7b70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04705aad40b6516a6fd81823fe756f95"><td class="memItemLeft" align="right" valign="top"><a id="a04705aad40b6516a6fd81823fe756f95"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a04705aad40b6516a6fd81823fe756f95">operator+=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a04705aad40b6516a6fd81823fe756f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. <br /></td></tr>
<tr class="separator:a04705aad40b6516a6fd81823fe756f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7159febd82754998c2902084de5413a8"><td class="memItemLeft" align="right" valign="top"><a id="a7159febd82754998c2902084de5413a8"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7159febd82754998c2902084de5413a8">operator-=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a7159febd82754998c2902084de5413a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator. <br /></td></tr>
<tr class="separator:a7159febd82754998c2902084de5413a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc1dd29d634c370a0fa8ed352d7b734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#abbc1dd29d634c370a0fa8ed352d7b734">swap</a> (<a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ad713d7670532e8f872f9ff4ba022a705">self_relative_ptr_base_impl</a> &amp;other)</td></tr>
<tr class="memdesc:abbc1dd29d634c370a0fa8ed352d7b734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two self_relative_ptr_base objects of the same type.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#abbc1dd29d634c370a0fa8ed352d7b734">More...</a><br /></td></tr>
<tr class="separator:abbc1dd29d634c370a0fa8ed352d7b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657ec0425124c86d3403495d3e95c486"><td class="memItemLeft" align="right" valign="top"><a id="a657ec0425124c86d3403495d3e95c486"></a>
byte_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a657ec0425124c86d3403495d3e95c486">to_byte_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a657ec0425124c86d3403495d3e95c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to byte pointer. <br /></td></tr>
<tr class="separator:a657ec0425124c86d3403495d3e95c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54699d0bc903b2f02c892b43ac14b991"><td class="memItemLeft" align="right" valign="top"><a id="a54699d0bc903b2f02c892b43ac14b991"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a54699d0bc903b2f02c892b43ac14b991">to_void_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a54699d0bc903b2f02c892b43ac14b991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to void*. <br /></td></tr>
<tr class="separator:a54699d0bc903b2f02c892b43ac14b991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e05e732319e690352d80cb7a6b6447"><td class="memItemLeft" align="right" valign="top"><a id="a47e05e732319e690352d80cb7a6b6447"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a47e05e732319e690352d80cb7a6b6447">operator void *</a> () const noexcept</td></tr>
<tr class="memdesc:a47e05e732319e690352d80cb7a6b6447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion operator to void*. <br /></td></tr>
<tr class="separator:a47e05e732319e690352d80cb7a6b6447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662bad10baca6180b80069c0a1bbf5e0"><td class="memItemLeft" align="right" valign="top"><a id="a662bad10baca6180b80069c0a1bbf5e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a662bad10baca6180b80069c0a1bbf5e0">operator byte_ptr_type</a> () const noexcept</td></tr>
<tr class="memdesc:a662bad10baca6180b80069c0a1bbf5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion operator to byte pointer. <br /></td></tr>
<tr class="separator:a662bad10baca6180b80069c0a1bbf5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760fdb659416dc28baa265f1930283b0"><td class="memItemLeft" align="right" valign="top"><a id="a760fdb659416dc28baa265f1930283b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a760fdb659416dc28baa265f1930283b0">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a760fdb659416dc28baa265f1930283b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast null checking without conversion to void*. <br /></td></tr>
<tr class="separator:a760fdb659416dc28baa265f1930283b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ea6a340a0bed6771e811c9264fd8131"><td class="memItemLeft" align="right" valign="top"><a id="a1ea6a340a0bed6771e811c9264fd8131"></a>
static <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a1ea6a340a0bed6771e811c9264fd8131">distance_between</a> (const <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ad713d7670532e8f872f9ff4ba022a705">self_relative_ptr_base_impl</a> &amp;first, const <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ad713d7670532e8f872f9ff4ba022a705">self_relative_ptr_base_impl</a> &amp;second)</td></tr>
<tr class="memdesc:a1ea6a340a0bed6771e811c9264fd8131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte distance between two relative pointers. <br /></td></tr>
<tr class="separator:a1ea6a340a0bed6771e811c9264fd8131"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a61b645d35e63b21aa63373251da3fd4d"><td class="memItemLeft" align="right" valign="top"><a id="a61b645d35e63b21aa63373251da3fd4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a61b645d35e63b21aa63373251da3fd4d">verify_type</a> ()</td></tr>
<tr class="memdesc:a61b645d35e63b21aa63373251da3fd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if element_type is not polymorphic. <br /></td></tr>
<tr class="separator:a61b645d35e63b21aa63373251da3fd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb5f5adce1968be8558bf21b190a823"><td class="memItemLeft" align="right" valign="top"><a id="a5bb5f5adce1968be8558bf21b190a823"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a5bb5f5adce1968be8558bf21b190a823">offset_to_pointer</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a> other_offset) const noexcept</td></tr>
<tr class="memdesc:a5bb5f5adce1968be8558bf21b190a823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to void* use other offset. <br /></td></tr>
<tr class="separator:a5bb5f5adce1968be8558bf21b190a823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142914472e5c0fbe3405c62d96e4b69"><td class="memItemLeft" align="right" valign="top"><a id="af142914472e5c0fbe3405c62d96e4b69"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#af142914472e5c0fbe3405c62d96e4b69">pointer_to_offset</a> (const <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ad713d7670532e8f872f9ff4ba022a705">self_relative_ptr_base_impl</a> &amp;ptr) const noexcept</td></tr>
<tr class="memdesc:af142914472e5c0fbe3405c62d96e4b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion self_relative_ptr_base to offset from itself. <br /></td></tr>
<tr class="separator:af142914472e5c0fbe3405c62d96e4b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55695b88f5b6ed57c637b5821786d3ce"><td class="memItemLeft" align="right" valign="top"><a id="a55695b88f5b6ed57c637b5821786d3ce"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a55695b88f5b6ed57c637b5821786d3ce">pointer_to_offset</a> (void *ptr) const noexcept</td></tr>
<tr class="memdesc:a55695b88f5b6ed57c637b5821786d3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion pointer to offset. <br /></td></tr>
<tr class="separator:a55695b88f5b6ed57c637b5821786d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8e6c9bbf699cad2e688c22598126bcb7"><td class="memItemLeft" align="right" valign="top"><a id="a8e6c9bbf699cad2e688c22598126bcb7"></a>
offset_type&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b></td></tr>
<tr class="separator:a8e6c9bbf699cad2e688c22598126bcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac336bb4341b7ba7869cca594a1993f32"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac336bb4341b7ba7869cca594a1993f32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac336bb4341b7ba7869cca594a1993f32">swap</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;a, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ac336bb4341b7ba7869cca594a1993f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> objects of the same type.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac336bb4341b7ba7869cca594a1993f32">More...</a><br /></td></tr>
<tr class="separator:ac336bb4341b7ba7869cca594a1993f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011974aa0c9c8bbdecfddae47757e1d9"><td class="memTemplParams" colspan="2"><a id="a011974aa0c9c8bbdecfddae47757e1d9"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a011974aa0c9c8bbdecfddae47757e1d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a011974aa0c9c8bbdecfddae47757e1d9">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a011974aa0c9c8bbdecfddae47757e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a011974aa0c9c8bbdecfddae47757e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520a16e7407e05001da08de616dd1dcf"><td class="memTemplParams" colspan="2"><a id="a520a16e7407e05001da08de616dd1dcf"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a520a16e7407e05001da08de616dd1dcf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a520a16e7407e05001da08de616dd1dcf">operator!=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a520a16e7407e05001da08de616dd1dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a520a16e7407e05001da08de616dd1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94572e79dfe0b16c54ca9af030430530"><td class="memTemplParams" colspan="2"><a id="a94572e79dfe0b16c54ca9af030430530"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94572e79dfe0b16c54ca9af030430530"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a94572e79dfe0b16c54ca9af030430530">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a94572e79dfe0b16c54ca9af030430530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator with nullptr. <br /></td></tr>
<tr class="separator:a94572e79dfe0b16c54ca9af030430530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08081052f4859949c20d811801b4b08"><td class="memTemplParams" colspan="2"><a id="ad08081052f4859949c20d811801b4b08"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad08081052f4859949c20d811801b4b08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad08081052f4859949c20d811801b4b08">operator==</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs) noexcept</td></tr>
<tr class="memdesc:ad08081052f4859949c20d811801b4b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator with nullptr. <br /></td></tr>
<tr class="separator:ad08081052f4859949c20d811801b4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08ba3d98f561f44e3890b42388069fa"><td class="memTemplParams" colspan="2"><a id="ab08ba3d98f561f44e3890b42388069fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab08ba3d98f561f44e3890b42388069fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ab08ba3d98f561f44e3890b42388069fa">operator!=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:ab08ba3d98f561f44e3890b42388069fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator with nullptr. <br /></td></tr>
<tr class="separator:ab08ba3d98f561f44e3890b42388069fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd93ab458a4d06c750bfcc9ec4dbaee"><td class="memTemplParams" colspan="2"><a id="a9dd93ab458a4d06c750bfcc9ec4dbaee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9dd93ab458a4d06c750bfcc9ec4dbaee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a9dd93ab458a4d06c750bfcc9ec4dbaee">operator!=</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs) noexcept</td></tr>
<tr class="memdesc:a9dd93ab458a4d06c750bfcc9ec4dbaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator with nullptr. <br /></td></tr>
<tr class="separator:a9dd93ab458a4d06c750bfcc9ec4dbaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5126c70dff9c127d58856f0891f448a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:aa5126c70dff9c127d58856f0891f448a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#aa5126c70dff9c127d58856f0891f448a">operator&lt;</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa5126c70dff9c127d58856f0891f448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#aa5126c70dff9c127d58856f0891f448a">More...</a><br /></td></tr>
<tr class="separator:aa5126c70dff9c127d58856f0891f448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa8e49f2fa6df860ca564083603965b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:abfa8e49f2fa6df860ca564083603965b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abfa8e49f2fa6df860ca564083603965b">operator&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abfa8e49f2fa6df860ca564083603965b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less or equal than operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abfa8e49f2fa6df860ca564083603965b">More...</a><br /></td></tr>
<tr class="separator:abfa8e49f2fa6df860ca564083603965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e319201e70b2aadef2f2cfaba7c57b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a28e319201e70b2aadef2f2cfaba7c57b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a28e319201e70b2aadef2f2cfaba7c57b">operator&gt;</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a28e319201e70b2aadef2f2cfaba7c57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a28e319201e70b2aadef2f2cfaba7c57b">More...</a><br /></td></tr>
<tr class="separator:a28e319201e70b2aadef2f2cfaba7c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8261c5ee8dd8ce92318d67bc44efc74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:ab8261c5ee8dd8ce92318d67bc44efc74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ab8261c5ee8dd8ce92318d67bc44efc74">operator&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab8261c5ee8dd8ce92318d67bc44efc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater or equal than operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ab8261c5ee8dd8ce92318d67bc44efc74">More...</a><br /></td></tr>
<tr class="separator:ab8261c5ee8dd8ce92318d67bc44efc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff16a85427d6abcc851e885be6e7436"><td class="memTemplParams" colspan="2"><a id="a1ff16a85427d6abcc851e885be6e7436"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ff16a85427d6abcc851e885be6e7436"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a1ff16a85427d6abcc851e885be6e7436">operator&lt;</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a1ff16a85427d6abcc851e885be6e7436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a1ff16a85427d6abcc851e885be6e7436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b296df0fd9480e93b23ee312b76e7c"><td class="memTemplParams" colspan="2"><a id="a46b296df0fd9480e93b23ee312b76e7c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46b296df0fd9480e93b23ee312b76e7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a46b296df0fd9480e93b23ee312b76e7c">operator&lt;</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a46b296df0fd9480e93b23ee312b76e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a46b296df0fd9480e93b23ee312b76e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4766cf41fd5fdb27ebae7fa6e695f447"><td class="memTemplParams" colspan="2"><a id="a4766cf41fd5fdb27ebae7fa6e695f447"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4766cf41fd5fdb27ebae7fa6e695f447"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4766cf41fd5fdb27ebae7fa6e695f447">operator&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a4766cf41fd5fdb27ebae7fa6e695f447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a4766cf41fd5fdb27ebae7fa6e695f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6eb233f6ed282a639d789a6c718bd9"><td class="memTemplParams" colspan="2"><a id="a6e6eb233f6ed282a639d789a6c718bd9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e6eb233f6ed282a639d789a6c718bd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a6e6eb233f6ed282a639d789a6c718bd9">operator&lt;=</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a6e6eb233f6ed282a639d789a6c718bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a6e6eb233f6ed282a639d789a6c718bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0300080c8f3e97413a6fef1a7678cc87"><td class="memTemplParams" colspan="2"><a id="a0300080c8f3e97413a6fef1a7678cc87"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0300080c8f3e97413a6fef1a7678cc87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0300080c8f3e97413a6fef1a7678cc87">operator&gt;</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a0300080c8f3e97413a6fef1a7678cc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a0300080c8f3e97413a6fef1a7678cc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7635d345fa085b7e46e0374950a99b0c"><td class="memTemplParams" colspan="2"><a id="a7635d345fa085b7e46e0374950a99b0c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7635d345fa085b7e46e0374950a99b0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7635d345fa085b7e46e0374950a99b0c">operator&gt;</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7635d345fa085b7e46e0374950a99b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a7635d345fa085b7e46e0374950a99b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c27bd406af2f03458e9cf0bb5074d5"><td class="memTemplParams" colspan="2"><a id="aa6c27bd406af2f03458e9cf0bb5074d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6c27bd406af2f03458e9cf0bb5074d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#aa6c27bd406af2f03458e9cf0bb5074d5">operator&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:aa6c27bd406af2f03458e9cf0bb5074d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:aa6c27bd406af2f03458e9cf0bb5074d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3521e5330655ba83bf22855f6e391a34"><td class="memTemplParams" colspan="2"><a id="a3521e5330655ba83bf22855f6e391a34"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3521e5330655ba83bf22855f6e391a34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a3521e5330655ba83bf22855f6e391a34">operator&gt;=</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3521e5330655ba83bf22855f6e391a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a3521e5330655ba83bf22855f6e391a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde3d9be3625ca0b966549ff298f41ff"><td class="memTemplParams" colspan="2"><a id="acde3d9be3625ca0b966549ff298f41ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acde3d9be3625ca0b966549ff298f41ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acde3d9be3625ca0b966549ff298f41ff">operator+</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::ptrdiff_t s)</td></tr>
<tr class="memdesc:acde3d9be3625ca0b966549ff298f41ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for self-relative pointers. <br /></td></tr>
<tr class="separator:acde3d9be3625ca0b966549ff298f41ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03773ce7fdfb47fd6fa6484a6507d480"><td class="memTemplParams" colspan="2"><a id="a03773ce7fdfb47fd6fa6484a6507d480"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03773ce7fdfb47fd6fa6484a6507d480"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a03773ce7fdfb47fd6fa6484a6507d480">operator-</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a03773ce7fdfb47fd6fa6484a6507d480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for self-relative pointers. <br /></td></tr>
<tr class="separator:a03773ce7fdfb47fd6fa6484a6507d480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c2bc63d42d339a9ee0da28eb66ff14"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y , typename  = typename std::enable_if&lt;		  std::is_same&lt;typename std::remove_cv&lt;T&gt;::type,			       typename std::remove_cv&lt;Y&gt;::type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab4c2bc63d42d339a9ee0da28eb66ff14"><td class="memTemplItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ab4c2bc63d42d339a9ee0da28eb66ff14">operator-</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ab4c2bc63d42d339a9ee0da28eb66ff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for self-relative pointers of identical type.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ab4c2bc63d42d339a9ee0da28eb66ff14">More...</a><br /></td></tr>
<tr class="separator:ab4c2bc63d42d339a9ee0da28eb66ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc2e6b8506c4902cdd4b87e136fbd1"><td class="memTemplParams" colspan="2"><a id="af5dc2e6b8506c4902cdd4b87e136fbd1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5dc2e6b8506c4902cdd4b87e136fbd1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#af5dc2e6b8506c4902cdd4b87e136fbd1">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:af5dc2e6b8506c4902cdd4b87e136fbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ostream operator. <br /></td></tr>
<tr class="separator:af5dc2e6b8506c4902cdd4b87e136fbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::self_relative_ptr&lt; T &gt;</h3>

<p>Persistent self-relative pointer class. </p>
<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> implements a smart ptr. It encapsulates the self offsetted pointer and provides member access, dereference and array access operators.</p>
<p>Template parameter type has following requirements:</p><ul>
<li>Is not polymorphic</li>
<li>Has no non-static data members of reference type</li>
<li>Satisfies Destructible requirement: <a href="https://en.cppreference.com/w/cpp/named_req/Destructible">https://en.cppreference.com/w/cpp/named_req/Destructible</a></li>
<li>All non-static data members and base classes follow the same requirements</li>
</ul>
Even if all of the above requirements are met, type representation may vary depending on ABI and compiler optimizations (as stated in [class.mem]: "the order of allocation of non-static data members with different access control is unspecified"). To enforce the same layout for all ABIs and optimization levels type should satisfy StandardLayoutType requirement.If pointer is used with array type, additional requirement is:</p><ul>
<li>Element type must be default constructible</li>
</ul>
The pointer is not designed to work with polymorphic types, as they have runtime RTTI info embedded, which is implementation specific and thus not consistently rebuildable. Such constructs as polymorphic members or members of a union defined within a class held in a pointer will also yield undefined behavior.C++ standard states that lifetime of an object is a runtime property [basic.lifetime]. Conditions which must be fulfilled for object's lifetime to begin, imply that using any non-trivially constructible object with pointer is undefined behaviour. This is being partially addressed by the following proposal: <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo</a>Another caveat is that snapshotting elements in a transaction and performing rollback uses memcpy internally. Using memcpy on an object in C++ is allowed by the standard only if the type satisfies TriviallyCopyable requirement. </p>
<p>Casting to self_relative_ptr_base can be easily done from any self_relative_ptr&lt;T&gt; objects, but when casting between convertible objects be advised to use constructors or operator= specified for such conversion, see:</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586" title="Copy constructor from a different self_relative_ptr&lt;&gt;.">self_relative_ptr::self_relative_ptr(self_relative_ptr&lt;U&gt; const &amp;r)</a> ,</li>
<li>self_relative_ptr&lt;T&gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26" title="Converting assignment operator from a different self_relative_ptr&lt;&gt;.">operator=(self_relative_ptr&lt;Y&gt; const &amp;r)</a> . When casting indirectly with (void *) or using static_cast, and then casting to the second (convertible) type, the offset will be re-calculated.</li>
</ul>
<p>The current version uses an approach where we store offset=real_offset-1 and zero offset (or real_offset equal one) is a null pointer. This is needed to support zero initialization.</p><ul>
<li>real_offset = pointer - this;</li>
<li>pointer = real_offset + this;</li>
<li>or pointer = offset + this + 1; </li>
</ul>
 </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad59315a07c5d3bfd6a761ac17007b23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59315a07c5d3bfd6a761ac17007b23a">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">iterator_category</a> =  std::random_access_iterator_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random access iterator requirements (members) </p>
<p>The <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> iterator category. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0b186cde38f990d3b7c1a9fd7f68c793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b186cde38f990d3b7c1a9fd7f68c793">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">element_type *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volatile pointer constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>volatile pointer, pointing to persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ad6b76812c31a4b81859d25846add4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad6b76812c31a4b81859d25846add4b">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">PMEMoid&#160;</td>
          <td class="paramname"><em>oid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PMEMoid constructor. </p>
<p>Provided for easy interoperability between C++ and C API's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>C-style persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5be3c4ecb9a967cb30425fb3ed54586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5be3c4ecb9a967cb30425fb3ed54586">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a different self_relative_ptr&lt;&gt;. </p>
<p>Available only for convertible, non-void types. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c550851f90b7139e588445913fdfb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c550851f90b7139e588445913fdfb48">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_type* <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the direct pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>the direct pointer to the object. </dd></dl>

</div>
</div>
<a id="a2283fb5e5ba26aa3a7443a353d062f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2283fb5e5ba26aa3a7443a353d062f49">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>self-relative pointer assignment within a transaction automatically registers this operation so that a rollback is possible.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70042cf9bf7619af8f9f48409e34cf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70042cf9bf7619af8f9f48409e34cf26">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt;T&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting assignment operator from a different self_relative_ptr&lt;&gt;. </p>
<p>Available only for convertible types. Just like regular assignment, also automatically registers itself in a transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd01402f0ef7b1c9197aede9a9fa1a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01402f0ef7b1c9197aede9a9fa1a1c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullptr move assignment operator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95fb880992038e280590f619cbe8b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fb880992038e280590f619cbe8b041">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::detail::sp_array_access&lt;T&gt;::type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array access operator. </p>
<p>Contains run-time bounds checking for static arrays. </p>

</div>
</div>
<a id="abbc1dd29d634c370a0fa8ed352d7b734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc1dd29d634c370a0fa8ed352d7b734">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OffsetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">pmem::detail::self_relative_ptr_base_impl</a>&lt; OffsetType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a>&lt; OffsetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two self_relative_ptr_base objects of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>the other <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab4c2bc63d42d339a9ee0da28eb66ff14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c2bc63d42d339a9ee0da28eb66ff14">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y , typename  = typename std::enable_if&lt;		  std::is_same&lt;typename std::remove_cv&lt;T&gt;::type,			       typename std::remove_cv&lt;Y&gt;::type&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for self-relative pointers of identical type. </p>
<p>Calculates the offset difference. Calculating the difference of pointers from objects of different pools is not allowed. </p>

</div>
</div>
<a id="aa5126c70dff9c127d58856f0891f448a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5126c70dff9c127d58856f0891f448a">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the sum(this, offset) of lhs is less than the sum(this, offset) of rhs. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="abfa8e49f2fa6df860ca564083603965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa8e49f2fa6df860ca564083603965b">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less or equal than operator. </p>
<p>See less than operator for comparison rules. </p>

</div>
</div>
<a id="a28e319201e70b2aadef2f2cfaba7c57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e319201e70b2aadef2f2cfaba7c57b">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than operator. </p>
<p>See less than operator for comparison rules. </p>

</div>
</div>
<a id="ab8261c5ee8dd8ce92318d67bc44efc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8261c5ee8dd8ce92318d67bc44efc74">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater or equal than operator. </p>
<p>See less than operator for comparison rules. </p>

</div>
</div>
<a id="ac336bb4341b7ba7869cca594a1993f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac336bb4341b7ba7869cca594a1993f32">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> objects of the same type. </p>
<p>Non-member swap function as required by Swappable concept. en.cppreference.com/w/cpp/concept/Swappable </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="self__relative__ptr_8hpp_source.html">self_relative_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
