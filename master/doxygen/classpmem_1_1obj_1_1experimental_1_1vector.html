<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface.  
 <a href="classpmem_1_1obj_1_1experimental_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">libpmemobj++/experimental/vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a636c3f33b0647feb03e1caf9aece8ab2">vector</a> ()</td></tr>
<tr class="memdesc:a636c3f33b0647feb03e1caf9aece8ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a636c3f33b0647feb03e1caf9aece8ab2">More...</a><br /></td></tr>
<tr class="separator:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77628ae4d95b0e93037541f104ec86b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a77628ae4d95b0e93037541f104ec86b3">vector</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a77628ae4d95b0e93037541f104ec86b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="#a77628ae4d95b0e93037541f104ec86b3">More...</a><br /></td></tr>
<tr class="separator:a77628ae4d95b0e93037541f104ec86b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b0a598e44399198a1f05ee732e576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a486b0a598e44399198a1f05ee732e576">vector</a> (size_type count)</td></tr>
<tr class="memdesc:a486b0a598e44399198a1f05ee732e576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of T default constructed values.  <a href="#a486b0a598e44399198a1f05ee732e576">More...</a><br /></td></tr>
<tr class="separator:a486b0a598e44399198a1f05ee732e576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; value_type, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f6b898490147e4c6e620785d5194aa">vector</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ae1f6b898490147e4c6e620785d5194aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="#ae1f6b898490147e4c6e620785d5194aa">More...</a><br /></td></tr>
<tr class="separator:ae1f6b898490147e4c6e620785d5194aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1167a0629de37532aa57f39da47fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9b1167a0629de37532aa57f39da47fa9">vector</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a9b1167a0629de37532aa57f39da47fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9b1167a0629de37532aa57f39da47fa9">More...</a><br /></td></tr>
<tr class="separator:a9b1167a0629de37532aa57f39da47fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa503ab924495ac60140b9852ce7d52b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa503ab924495ac60140b9852ce7d52b0">vector</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa503ab924495ac60140b9852ce7d52b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aa503ab924495ac60140b9852ce7d52b0">More...</a><br /></td></tr>
<tr class="separator:aa503ab924495ac60140b9852ce7d52b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88f2db2da445af0fab25559262c636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7a88f2db2da445af0fab25559262c636">vector</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a7a88f2db2da445af0fab25559262c636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="#a7a88f2db2da445af0fab25559262c636">More...</a><br /></td></tr>
<tr class="separator:a7a88f2db2da445af0fab25559262c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a395a49f38bcde6c2164405fc9bb2c35a">~vector</a> ()</td></tr>
<tr class="memdesc:a395a49f38bcde6c2164405fc9bb2c35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a395a49f38bcde6c2164405fc9bb2c35a">More...</a><br /></td></tr>
<tr class="separator:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7b1f1a08b1d34f9874c1d56dce9c8ec8">at</a> (size_type n)</td></tr>
<tr class="memdesc:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking and add it to a transaction.  <a href="#a7b1f1a08b1d34f9874c1d56dce9c8ec8">More...</a><br /></td></tr>
<tr class="separator:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db43b38bad316d12f51319fcdb2054"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a83db43b38bad316d12f51319fcdb2054">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a83db43b38bad316d12f51319fcdb2054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a83db43b38bad316d12f51319fcdb2054">More...</a><br /></td></tr>
<tr class="separator:a83db43b38bad316d12f51319fcdb2054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fc08c07d12cdacc4426285962f0c21"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:a38fc08c07d12cdacc4426285962f0c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a38fc08c07d12cdacc4426285962f0c21">More...</a><br /></td></tr>
<tr class="separator:a38fc08c07d12cdacc4426285962f0c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a57b4e5d1c66f006ad7f87f9573f3c6bc">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">More...</a><br /></td></tr>
<tr class="separator:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0ffcc2e74974015ed9741b1430227"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f0ffcc2e74974015ed9741b1430227">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ae1f0ffcc2e74974015ed9741b1430227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#ae1f0ffcc2e74974015ed9741b1430227">More...</a><br /></td></tr>
<tr class="separator:ae1f0ffcc2e74974015ed9741b1430227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ea56dd1be6b3e5d0427a62327b81e5">front</a> ()</td></tr>
<tr class="memdesc:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element and add this element to a transaction.  <a href="#ae5ea56dd1be6b3e5d0427a62327b81e5">More...</a><br /></td></tr>
<tr class="separator:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674fdb0401fd0f7396675035d1d8e72a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a674fdb0401fd0f7396675035d1d8e72a">front</a> () const</td></tr>
<tr class="memdesc:a674fdb0401fd0f7396675035d1d8e72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#a674fdb0401fd0f7396675035d1d8e72a">More...</a><br /></td></tr>
<tr class="separator:a674fdb0401fd0f7396675035d1d8e72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb83c8e3bda44858a6923319e880e6"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6">cfront</a> () const</td></tr>
<tr class="memdesc:abbfb83c8e3bda44858a6923319e880e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#abbfb83c8e3bda44858a6923319e880e6">More...</a><br /></td></tr>
<tr class="separator:abbfb83c8e3bda44858a6923319e880e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0014916c3340dfafdcba429a3afd4a"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a">back</a> ()</td></tr>
<tr class="memdesc:a4c0014916c3340dfafdcba429a3afd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element and add this element to a transaction.  <a href="#a4c0014916c3340dfafdcba429a3afd4a">More...</a><br /></td></tr>
<tr class="separator:a4c0014916c3340dfafdcba429a3afd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dc2516566c13ec6713c624cdfd2c21"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a01dc2516566c13ec6713c624cdfd2c21">back</a> () const</td></tr>
<tr class="memdesc:a01dc2516566c13ec6713c624cdfd2c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#a01dc2516566c13ec6713c624cdfd2c21">More...</a><br /></td></tr>
<tr class="separator:a01dc2516566c13ec6713c624cdfd2c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19e208064355c8176eeffa1c832cdd5"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5">cback</a> () const</td></tr>
<tr class="memdesc:af19e208064355c8176eeffa1c832cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#af19e208064355c8176eeffa1c832cdd5">More...</a><br /></td></tr>
<tr class="separator:af19e208064355c8176eeffa1c832cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10579fdbcf3a682355025954d4ba665f"><td class="memItemLeft" align="right" valign="top">value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f">data</a> ()</td></tr>
<tr class="memdesc:a10579fdbcf3a682355025954d4ba665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw pointer to the underlying data and adds entire array to a transaction.  <a href="#a10579fdbcf3a682355025954d4ba665f">More...</a><br /></td></tr>
<tr class="separator:a10579fdbcf3a682355025954d4ba665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9561c662b97f84da5e47e0f767f9bde"><td class="memItemLeft" align="right" valign="top">const value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad9561c662b97f84da5e47e0f767f9bde">data</a> () const noexcept</td></tr>
<tr class="memdesc:ad9561c662b97f84da5e47e0f767f9bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data.  <a href="#ad9561c662b97f84da5e47e0f767f9bde">More...</a><br /></td></tr>
<tr class="separator:ad9561c662b97f84da5e47e0f767f9bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3543940ea0b583b71e96ec3a89c68a"><td class="memItemLeft" align="right" valign="top">const value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a">cdata</a> () const noexcept</td></tr>
<tr class="memdesc:a8a3543940ea0b583b71e96ec3a89c68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data.  <a href="#a8a3543940ea0b583b71e96ec3a89c68a">More...</a><br /></td></tr>
<tr class="separator:a8a3543940ea0b583b71e96ec3a89c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab88d348f9aec780a683e0572b60be83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83">begin</a> ()</td></tr>
<tr class="memdesc:aab88d348f9aec780a683e0572b60be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#aab88d348f9aec780a683e0572b60be83">More...</a><br /></td></tr>
<tr class="separator:aab88d348f9aec780a683e0572b60be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb307d36ab9098655ba1a1166d37444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a3cb307d36ab9098655ba1a1166d37444">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a3cb307d36ab9098655ba1a1166d37444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#a3cb307d36ab9098655ba1a1166d37444">More...</a><br /></td></tr>
<tr class="separator:a3cb307d36ab9098655ba1a1166d37444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae52abd4d3c066bf755b78f4b781c1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aae52abd4d3c066bf755b78f4b781c1d8">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aae52abd4d3c066bf755b78f4b781c1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#aae52abd4d3c066bf755b78f4b781c1d8">More...</a><br /></td></tr>
<tr class="separator:aae52abd4d3c066bf755b78f4b781c1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d32b0060badd059f0ac41eb73bf54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54">end</a> ()</td></tr>
<tr class="memdesc:aac5d32b0060badd059f0ac41eb73bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to past the end.  <a href="#aac5d32b0060badd059f0ac41eb73bf54">More...</a><br /></td></tr>
<tr class="separator:aac5d32b0060badd059f0ac41eb73bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289592fadece20471f1588c0a1bddb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa289592fadece20471f1588c0a1bddb3">end</a> () const noexcept</td></tr>
<tr class="memdesc:aa289592fadece20471f1588c0a1bddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to past the end.  <a href="#aa289592fadece20471f1588c0a1bddb3">More...</a><br /></td></tr>
<tr class="separator:aa289592fadece20471f1588c0a1bddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac1f050f7fabb39ec5918fbc1fb3604ba">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end.  <a href="#ac1f050f7fabb39ec5918fbc1fb3604ba">More...</a><br /></td></tr>
<tr class="separator:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec3d65c0203596140b72b21581c795"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abdec3d65c0203596140b72b21581c795">rbegin</a> ()</td></tr>
<tr class="memdesc:abdec3d65c0203596140b72b21581c795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#abdec3d65c0203596140b72b21581c795">More...</a><br /></td></tr>
<tr class="separator:abdec3d65c0203596140b72b21581c795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2904e853e49b5abf858e08199fe3a361"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2904e853e49b5abf858e08199fe3a361">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a2904e853e49b5abf858e08199fe3a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a2904e853e49b5abf858e08199fe3a361">More...</a><br /></td></tr>
<tr class="separator:a2904e853e49b5abf858e08199fe3a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767248672d1dde6231a2edf45e4edad"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a0767248672d1dde6231a2edf45e4edad">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0767248672d1dde6231a2edf45e4edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a0767248672d1dde6231a2edf45e4edad">More...</a><br /></td></tr>
<tr class="separator:a0767248672d1dde6231a2edf45e4edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b79d6c2a9f83b2b786a7a38951431"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a301b79d6c2a9f83b2b786a7a38951431">rend</a> ()</td></tr>
<tr class="memdesc:a301b79d6c2a9f83b2b786a7a38951431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#a301b79d6c2a9f83b2b786a7a38951431">More...</a><br /></td></tr>
<tr class="separator:a301b79d6c2a9f83b2b786a7a38951431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad8102a1af5ef750fc2da054a6cfb3f1b">rend</a> () const noexcept</td></tr>
<tr class="memdesc:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end.  <a href="#ad8102a1af5ef750fc2da054a6cfb3f1b">More...</a><br /></td></tr>
<tr class="separator:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669cf45a5270311bbd00c3da4cd0c41"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9669cf45a5270311bbd00c3da4cd0c41">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a9669cf45a5270311bbd00c3da4cd0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a9669cf45a5270311bbd00c3da4cd0c41">More...</a><br /></td></tr>
<tr class="separator:a9669cf45a5270311bbd00c3da4cd0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68621a1b88210bc2cac19f5218f7be5d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a68621a1b88210bc2cac19f5218f7be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a68621a1b88210bc2cac19f5218f7be5d">More...</a><br /></td></tr>
<tr class="separator:a68621a1b88210bc2cac19f5218f7be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ae5f550e26055428de5c6bfbe103a8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a> () const noexcept</td></tr>
<tr class="separator:a47ae5f550e26055428de5c6bfbe103a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size</a> () const noexcept</td></tr>
<tr class="separator:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6f34cabfe6535991feacf04745536"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity</a> () const noexcept</td></tr>
<tr class="separator:a48c6f34cabfe6535991feacf04745536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008f5170008840628525c7e8327a2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a6008f5170008840628525c7e8327a2e2">free_data</a> ()</td></tr>
<tr class="memdesc:a6008f5170008840628525c7e8327a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a vector and frees all allocated persitent memory for data in transaction.  <a href="#a6008f5170008840628525c7e8327a2e2">More...</a><br /></td></tr>
<tr class="separator:a6008f5170008840628525c7e8327a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ab667822e6db1a4ed0ea917ab75b5e02e">_alloc</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a>)</td></tr>
<tr class="memdesc:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ab667822e6db1a4ed0ea917ab75b5e02e">More...</a><br /></td></tr>
<tr class="separator:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55506a53b2f29e68def838b8c32bc25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae55506a53b2f29e68def838b8c32bc25">_dealloc</a> ()</td></tr>
<tr class="memdesc:ae55506a53b2f29e68def838b8c32bc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ae55506a53b2f29e68def838b8c32bc25">More...</a><br /></td></tr>
<tr class="separator:ae55506a53b2f29e68def838b8c32bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e900597e407247e7c0e3d9dc1b0734e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9e900597e407247e7c0e3d9dc1b0734e">_grow</a> (size_type count, const_reference value)</td></tr>
<tr class="memdesc:a9e900597e407247e7c0e3d9dc1b0734e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a9e900597e407247e7c0e3d9dc1b0734e">More...</a><br /></td></tr>
<tr class="separator:a9e900597e407247e7c0e3d9dc1b0734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; value_type, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2e8c0c53838d13b751004eab5b60c4e7">_grow</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a2e8c0c53838d13b751004eab5b60c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a2e8c0c53838d13b751004eab5b60c4e7">More...</a><br /></td></tr>
<tr class="separator:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1a8a0b0f53e4d3d03fce745586669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2ab1a8a0b0f53e4d3d03fce745586669">_shrink</a> (size_type size_new) noexcept</td></tr>
<tr class="memdesc:a2ab1a8a0b0f53e4d3d03fce745586669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a2ab1a8a0b0f53e4d3d03fce745586669">More...</a><br /></td></tr>
<tr class="separator:a2ab1a8a0b0f53e4d3d03fce745586669"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::vector&lt; T &gt;</h3>

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a636c3f33b0647feb03e1caf9aece8ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636c3f33b0647feb03e1caf9aece8ab2">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77628ae4d95b0e93037541f104ec86b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77628ae4d95b0e93037541f104ec86b3">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486b0a598e44399198a1f05ee732e576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486b0a598e44399198a1f05ee732e576">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of T default constructed values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f6b898490147e4c6e620785d5194aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f6b898490147e4c6e620785d5194aa">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; T, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>The first and last arguments must satisfy InputIterator requirements. This overload only participates in overload resolution if InputIt satisfies InputIterator, to avoid ambiguity with the overload of count-value constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1167a0629de37532aa57f39da47fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1167a0629de37532aa57f39da47fa9">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa503ab924495ac60140b9852ce7d52b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa503ab924495ac60140b9852ce7d52b0">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d" title="Checks whether the container is empty. ">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the vector to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == other.data() </dd>
<dd>
other.data() == nullptr </dd>
<dd>
other.capacity() == 0 </dd>
<dd>
other.size() == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a88f2db2da445af0fab25559262c636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a88f2db2da445af0fab25559262c636">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == init.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a395a49f38bcde6c2164405fc9bb2c35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395a49f38bcde6c2164405fc9bb2c35a">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::~<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that free_data may throw an <a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">transaction_free_error</a> when freeing underlying array failed. It is recommended to call free_data manually before object destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab667822e6db1a4ed0ea917ab75b5e02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667822e6db1a4ed0ea917ab75b5e02e">&#9670;&nbsp;</a></span>_alloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_alloc </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Allocates memory for given number of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>capacity of new underlying array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == capacity_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size exceeds biggest possible pmem allocation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae55506a53b2f29e68def838b8c32bc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55506a53b2f29e68def838b8c32bc25">&#9670;&nbsp;</a></span>_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_dealloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Deallocates underlying array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e900597e407247e7c0e3d9dc1b0734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e900597e407247e7c0e3d9dc1b0734e">&#9670;&nbsp;</a></span>_grow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements. Copy constructs elements at the end of underlying array based on given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + count) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= count + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
value is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8c0c53838d13b751004eab5b60c4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8c0c53838d13b751004eab5b60c4e7">&#9670;&nbsp;</a></span>_grow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; T, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements and input arguments satisfy InputIterator requirements. Constructs elements in underlying array with the contents of the range [first, last). The first and last arguments must satisfy InputIterator requirements. This overload participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= std::distance(first, last) + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
InputIt::reference is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab1a8a0b0f53e4d3d03fce745586669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab1a8a0b0f53e4d3d03fce745586669">&#9670;&nbsp;</a></span>_shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_shrink </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Destroys elements in underlying array beginning from position size_new.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_new</td><td>new size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>) must be snapshotted in current transaction. </dd>
<dd>
size_new &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == size_new </dd></dl>

</div>
</div>
<a id="a7b1f1a08b1d34f9874c1d56dce9c8ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1f1a08b1d34f9874c1d56dce9c8ec8">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking and add it to a transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83db43b38bad316d12f51319fcdb2054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db43b38bad316d12f51319fcdb2054">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0014916c3340dfafdcba429a3afd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0014916c3340dfafdcba429a3afd4a">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01dc2516566c13ec6713c624cdfd2c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dc2516566c13ec6713c624cdfd2c21">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying array. </dd></dl>

</div>
</div>
<a id="aab88d348f9aec780a683e0572b60be83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab88d348f9aec780a683e0572b60be83">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="a3cb307d36ab9098655ba1a1166d37444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb307d36ab9098655ba1a1166d37444">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a48c6f34cabfe6535991feacf04745536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c6f34cabfe6535991feacf04745536">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements that can be held in currently allocated storage </dd></dl>

</div>
</div>
<a id="af19e208064355c8176eeffa1c832cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19e208064355c8176eeffa1c832cdd5">&#9670;&nbsp;</a></span>cback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a" title="Access the last element and add this element to a transaction. ">back()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5" title="Access the last element. ">cback()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5" title="Access the last element. ">cback()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying array. </dd></dl>

</div>
</div>
<a id="aae52abd4d3c066bf755b78f4b781c1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae52abd4d3c066bf755b78f4b781c1d8">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aae52abd4d3c066bf755b78f4b781c1d8" title="Returns const iterator to the beginning. ">cbegin()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a8a3543940ea0b583b71e96ec3a89c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3543940ea0b583b71e96ec3a89c68a">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const raw pointer to the underlying data. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a" title="Returns const raw pointer to the underlying data. ">cdata()</a> will return const_pointer not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a" title="Returns const raw pointer to the underlying data. ">cdata()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const_pointer to the underlying data. </dd></dl>

</div>
</div>
<a id="ac1f050f7fabb39ec5918fbc1fb3604ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f050f7fabb39ec5918fbc1fb3604ba">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac1f050f7fabb39ec5918fbc1fb3604ba" title="Returns a const iterator to the end. ">cend()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="abbfb83c8e3bda44858a6923319e880e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfb83c8e3bda44858a6923319e880e6">&#9670;&nbsp;</a></span>cfront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cfront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ea56dd1be6b3e5d0427a62327b81e5" title="Access the first element and add this element to a transaction. ">front()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6" title="Access the first element. ">cfront()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6" title="Access the first element. ">cfront()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying array. </dd></dl>

</div>
</div>
<a id="a38fc08c07d12cdacc4426285962f0c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fc08c07d12cdacc4426285962f0c21">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7b1f1a08b1d34f9874c1d56dce9c8ec8" title="Access element at specific index with bounds checking and add it to a transaction. ">at()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21" title="Access element at specific index with bounds checking. ">const_at()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21" title="Access element at specific index with bounds checking. ">const_at()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0767248672d1dde6231a2edf45e4edad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0767248672d1dde6231a2edf45e4edad">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abdec3d65c0203596140b72b21581c795" title="Returns a reverse iterator to the beginning. ">rbegin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a0767248672d1dde6231a2edf45e4edad" title="Returns a const reverse iterator to the beginning. ">crbegin()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a9669cf45a5270311bbd00c3da4cd0c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669cf45a5270311bbd00c3da4cd0c41">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a301b79d6c2a9f83b2b786a7a38951431" title="Returns a reverse iterator to the end. ">rend()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9669cf45a5270311bbd00c3da4cd0c41" title="Returns a const reverse iterator to the beginning. ">crend()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a10579fdbcf3a682355025954d4ba665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10579fdbcf3a682355025954d4ba665f">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns raw pointer to the underlying data and adds entire array to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the underlying data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9561c662b97f84da5e47e0f767f9bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9561c662b97f84da5e47e0f767f9bde">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const raw pointer to the underlying data. </p>
<dl class="section return"><dt>Returns</dt><dd>const_pointer to the underlying data. </dd></dl>

</div>
</div>
<a id="a68621a1b88210bc2cac19f5218f7be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68621a1b88210bc2cac19f5218f7be5d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="aac5d32b0060badd059f0ac41eb73bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d32b0060badd059f0ac41eb73bf54">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="aa289592fadece20471f1588c0a1bddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289592fadece20471f1588c0a1bddb3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="a6008f5170008840628525c7e8327a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008f5170008840628525c7e8327a2e2">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a vector and frees all allocated persitent memory for data in transaction. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ea56dd1be6b3e5d0427a62327b81e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ea56dd1be6b3e5d0427a62327b81e5">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674fdb0401fd0f7396675035d1d8e72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674fdb0401fd0f7396675035d1d8e72a">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to first element in underlying array. </dd></dl>

</div>
</div>
<a id="a8e55449de7f6a9c04eaf19f3131681a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e55449de7f6a9c04eaf19f3131681a7">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold due to PMDK limitations. </dd></dl>

</div>
</div>
<a id="a57b4e5d1c66f006ad7f87f9573f3c6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f0ffcc2e74974015ed9741b1430227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0ffcc2e74974015ed9741b1430227">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array. </dd></dl>

</div>
</div>
<a id="abdec3d65c0203596140b72b21581c795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec3d65c0203596140b72b21581c795">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the last element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="a2904e853e49b5abf858e08199fe3a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2904e853e49b5abf858e08199fe3a361">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a301b79d6c2a9f83b2b786a7a38951431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301b79d6c2a9f83b2b786a7a38951431">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the theoretical element preceding the first element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="ad8102a1af5ef750fc2da054a6cfb3f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8102a1af5ef750fc2da054a6cfb3f1b">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a47ae5f550e26055428de5c6bfbe103a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae5f550e26055428de5c6bfbe103a8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
