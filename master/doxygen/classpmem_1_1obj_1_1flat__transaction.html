<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::flat_transaction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git107.g7e59f08f</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpmem_1_1obj_1_1flat__transaction.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1flat__transaction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::flat_transaction Class Reference<div class="ingroups"><a class="el" href="group__transactions.html">Transactions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ flat transaction handler class.  
 <a href="classpmem_1_1obj_1_1flat__transaction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transaction_8hpp_source.html">libpmemobj++/transaction.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pmem::obj::flat_transaction:</div>
<div class="dyncontent">
<div class="center"><img src="classpmem_1_1obj_1_1flat__transaction__inherit__graph.png" border="0" usemap="#apmem_1_1obj_1_1flat__transaction_inherit__map" alt="Inheritance graph"/></div>
<map name="apmem_1_1obj_1_1flat__transaction_inherit__map" id="apmem_1_1obj_1_1flat__transaction_inherit__map">
<area shape="rect" title="C++ flat transaction handler class." alt="" coords="5,95,185,121"/>
<area shape="rect" href="classpmem_1_1detail_1_1transaction__base.html" title=" " alt="" coords="11,5,180,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4b5dd1361e26221d949a0c1c051c9824"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">manual</a> = typename <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">detail::transaction_base</a>&lt; true &gt;::<a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">manual</a></td></tr>
<tr class="memdesc:a4b5dd1361e26221d949a0c1c051c9824"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ manual scope transaction class.  <a href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">More...</a><br /></td></tr>
<tr class="separator:a4b5dd1361e26221d949a0c1c051c9824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754b2fad0aac24717598b7e586c7a7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">automatic</a> = typename <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">detail::transaction_base</a>&lt; true &gt;::<a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">automatic</a></td></tr>
<tr class="memdesc:a9754b2fad0aac24717598b7e586c7a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ automatic scope transaction class.  <a href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">More...</a><br /></td></tr>
<tr class="separator:a9754b2fad0aac24717598b7e586c7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4345317108f070b1917aeb58d4c51d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">stage</a> </td></tr>
<tr class="memdesc:a1e4345317108f070b1917aeb58d4c51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible stages of a transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">More...</a><br /></td></tr>
<tr class="separator:a1e4345317108f070b1917aeb58d4c51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17987ad34cbb579b884300516555178c"><td class="memItemLeft" align="right" valign="top"><a id="a17987ad34cbb579b884300516555178c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a17987ad34cbb579b884300516555178c">~flat_transaction</a> () noexcept=delete</td></tr>
<tr class="memdesc:a17987ad34cbb579b884300516555178c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a17987ad34cbb579b884300516555178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6162d1d30b3c679814498da961147c54"><td class="memTemplParams" colspan="2">template&lt;typename... Locks&gt; </td></tr>
<tr class="memitem:a6162d1d30b3c679814498da961147c54"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">run</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, std::function&lt; void()&gt; tx, Locks &amp;... locks)</td></tr>
<tr class="memdesc:a6162d1d30b3c679814498da961147c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a closure-like transaction and lock <code>locks</code>.  <a href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">More...</a><br /></td></tr>
<tr class="separator:a6162d1d30b3c679814498da961147c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3bcf42e4b82b444a2e3a5a21d4ef8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#afc3bcf42e4b82b444a2e3a5a21d4ef8c">abort</a> (int err)</td></tr>
<tr class="memdesc:afc3bcf42e4b82b444a2e3a5a21d4ef8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually abort the current transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#afc3bcf42e4b82b444a2e3a5a21d4ef8c">More...</a><br /></td></tr>
<tr class="separator:afc3bcf42e4b82b444a2e3a5a21d4ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c0d86f943d6727e1caa7573cc83edb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">commit</a> ()</td></tr>
<tr class="memdesc:a16c0d86f943d6727e1caa7573cc83edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually commit a transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">More...</a><br /></td></tr>
<tr class="separator:a16c0d86f943d6727e1caa7573cc83edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e12537667e9cffaf2462eda7a1f60a"><td class="memItemLeft" align="right" valign="top"><a id="a88e12537667e9cffaf2462eda7a1f60a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>error</b> () noexcept</td></tr>
<tr class="separator:a88e12537667e9cffaf2462eda7a1f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9da87f86cf25e84bd83d2292f7adc48"><td class="memItemLeft" align="right" valign="top"><a id="ad9da87f86cf25e84bd83d2292f7adc48"></a>
static POBJ_CPP_DEPRECATED int&#160;</td><td class="memItemRight" valign="bottom"><b>get_last_tx_error</b> () noexcept</td></tr>
<tr class="separator:ad9da87f86cf25e84bd83d2292f7adc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fedce219cd56f06353a30823e5b41e0"><td class="memItemLeft" align="right" valign="top"><a id="a4fedce219cd56f06353a30823e5b41e0"></a>
static POBJ_CPP_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>exec_tx</b> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, std::function&lt; void()&gt; tx, Locks &amp;... locks)</td></tr>
<tr class="separator:a4fedce219cd56f06353a30823e5b41e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dffc5d7316f67f900e4cf8de8b6422"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a63dffc5d7316f67f900e4cf8de8b6422">snapshot</a> (const T *addr, size_t num=1)</td></tr>
<tr class="memdesc:a63dffc5d7316f67f900e4cf8de8b6422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a “snapshot” of given elements of type T number (1 by default), located at the given address ptr in the virtual memory space and saves it to the undo log.  <a href="classpmem_1_1detail_1_1transaction__base.html#a63dffc5d7316f67f900e4cf8de8b6422">More...</a><br /></td></tr>
<tr class="separator:a63dffc5d7316f67f900e4cf8de8b6422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd22aa1c4862fc4e1974e39fca7f3dfa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa">register_callback</a> (<a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">stage</a> stg, std::function&lt; void()&gt; cb)</td></tr>
<tr class="memdesc:abd22aa1c4862fc4e1974e39fca7f3dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers callback to be called on specified stage for the transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa">More...</a><br /></td></tr>
<tr class="separator:abd22aa1c4862fc4e1974e39fca7f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ flat transaction handler class. </p>
<p>This class is recommended over <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html" title="C++ transaction handler class.">basic_transaction</a>.</p>
<p>This class is the pmemobj transaction handler. Scoped transactions are handled through two internal classes: <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">manual</a> and <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">automatic</a>.</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">manual</a> transactions need to be committed manually, otherwise they will be aborted on object destruction.<br  />
</li>
<li><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">automatic</a> transactions are only available in C++17. They handle transaction commit/abort automatically.</li>
</ul>
<p>This class also exposes a closure-like transaction API, which is the preferred way of handling transactions.</p>
<p>This API should NOT be mixed with C transactions API. One issue is that C++ callbacks registered using <a class="el" href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa" title="Registers callback to be called on specified stage for the transaction.">transaction::register_callback()</a> would not be called if C++ transaction is created inside C transaction. The same is true if user calls pmemobj_tx_set_user_data() inside a C++ transaction.</p>
<p><b>Unlike <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html" title="C++ transaction handler class.">basic_transaction</a>, <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html" title="C++ flat transaction handler class.">flat_transaction</a> does not abort automatically in case of transactional functions (like make_persistent) failures. Instead, abort will happen only if an exception is not caught before the outermost transaction ends.</b></p>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_flat_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        p&lt;int&gt; count;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, [&amp;] {</div>
<div class="line">            proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                    proot-&gt;count++;</div>
<div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;some error&quot;</span>);</div>
<div class="line">                });</div>
<div class="line">            } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">                <span class="comment">/* Transaction is not aborted yet (unlike for</span></div>
<div class="line"><span class="comment">                 * basic_transaction). */</span></div>
<div class="line">                assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line">                assert(proot-&gt;count == 2);</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* An internal transaction error occurred, outer tx aborted just</span></div>
<div class="line"><span class="comment">         * now. Reacquire locks if necessary. */</span></div>
<div class="line">        assert(proot-&gt;count == 0);</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* Some other exception thrown, outer tx aborted just now.</span></div>
<div class="line"><span class="comment">         * Reacquire locks if necessary. */</span></div>
<div class="line">        assert(proot-&gt;count == 0);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1flat__transaction_html_a6162d1d30b3c679814498da961147c54"><div class="ttname"><a href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">pmem::obj::flat_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:810</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:694</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__error_html"><div class="ttname"><a href="classpmem_1_1transaction__error.html">pmem::transaction_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:109</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="apext_8hpp_html"><div class="ttname"><a href="pext_8hpp.html">pext.hpp</a></div><div class="ttdoc">Convenience extensions for the resides on pmem property template.</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>simple_ptr {</div>
<div class="line">    simple_ptr()</div>
<div class="line">    {</div>
<div class="line">        assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line">        ptr = make_persistent&lt;T&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~simple_ptr()</div>
<div class="line">    {</div>
<div class="line">        assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            delete_persistent&lt;T&gt;(ptr);</div>
<div class="line">        } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            std::terminate();</div>
<div class="line">        } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__scope__error.html">pmem::transaction_scope_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            std::terminate();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    persistent_ptr&lt;T&gt; ptr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>A {</div>
<div class="line">    A() : ptr1(), ptr2()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    simple_ptr&lt;int&gt; ptr1;</div>
<div class="line">    simple_ptr&lt;<span class="keywordtype">char</span>[(1ULL &lt;&lt; 30)]&gt; ptr2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>B {</div>
<div class="line">    B() : ptr1(), ptr2()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> pop = pool_base(pmemobj_pool_by_ptr(<span class="keyword">this</span>));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// It would result in a crash!</span></div>
<div class="line">        <span class="comment">// basic_transaction::run(pop, [&amp;]{ throw</span></div>
<div class="line">        <span class="comment">// std::runtime_error(&quot;Error&quot;); });</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(</div>
<div class="line">            pop, [&amp;] { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Error&quot;</span>); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    simple_ptr&lt;int&gt; ptr1;</div>
<div class="line">    simple_ptr&lt;int&gt; ptr2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_nested_struct_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        persistent_ptr&lt;A&gt; ptrA;</div>
<div class="line">        persistent_ptr&lt;B&gt; ptrB;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> create_a = [&amp;] { proot-&gt;ptrA = make_persistent&lt;A&gt;(); };</div>
<div class="line">    <span class="keyword">auto</span> create_b = [&amp;] { proot-&gt;ptrB = make_persistent&lt;B&gt;(); };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// It would result in a crash!</span></div>
<div class="line">        <span class="comment">// basic_transaction::run(pop, create_a);</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, create_a);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* To see why flat_transaction is necessary let&#39;s</span></div>
<div class="line"><span class="comment">         * consider what happens when calling A ctor. The call stack</span></div>
<div class="line"><span class="comment">         * will look like this:</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         *  | ptr2 ctor |</span></div>
<div class="line"><span class="comment">         *  |-----------|</span></div>
<div class="line"><span class="comment">         *  | ptr1 ctor |</span></div>
<div class="line"><span class="comment">         *  |-----------|</span></div>
<div class="line"><span class="comment">         *  |  A ctor   |</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Since ptr2 is a pointer to some huge array of elements,</span></div>
<div class="line"><span class="comment">         * calling ptr2 ctor will most likely result in make_persistent</span></div>
<div class="line"><span class="comment">         * throwing an exception (due to out of memory). This exception</span></div>
<div class="line"><span class="comment">         * will, in turn, cause stack unwinding - already constructed</span></div>
<div class="line"><span class="comment">         * elements must be destroyed (in this example ptr1 destructor</span></div>
<div class="line"><span class="comment">         * will be called).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * If we&#39;d use basic_transaction the allocation failure, apart</span></div>
<div class="line"><span class="comment">         * from throwing an exception, would also cause the transaction</span></div>
<div class="line"><span class="comment">         * to abort (by default, in basic_transaction, all transactional</span></div>
<div class="line"><span class="comment">         * functions failures cause tx abort). This is problematic since</span></div>
<div class="line"><span class="comment">         * the ptr1 destructor, which is called during stack unwinding,</span></div>
<div class="line"><span class="comment">         * expects the transaction to be in WORK stage (and the actual</span></div>
<div class="line"><span class="comment">         * stage is ABORTED). As a result the application will fail on</span></div>
<div class="line"><span class="comment">         * assert (and probably crash in NDEBUG mode).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Now, consider what will happen if we&#39;d use flat_transaction</span></div>
<div class="line"><span class="comment">         * instead. In this case, make_persistent failure will not abort</span></div>
<div class="line"><span class="comment">         * the transaction, it will only result in an exception. This</span></div>
<div class="line"><span class="comment">         * means that the transaction is still in WORK stage during</span></div>
<div class="line"><span class="comment">         * stack unwinding. Only after it completes, the transaction is</span></div>
<div class="line"><span class="comment">         * aborted (it&#39;s happening at the outermost level, when exiting</span></div>
<div class="line"><span class="comment">         * create_a lambda).</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">basic_transaction::run</a>(pop, create_b);</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, create_b);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Running create_b can be done both within basic and flat</span></div>
<div class="line"><span class="comment">         * transaction. However, note that the transaction used in the B</span></div>
<div class="line"><span class="comment">         * constructor MUST be a flat_transaction. This is because</span></div>
<div class="line"><span class="comment">         * flat_transaction does not abort immediately when catching an</span></div>
<div class="line"><span class="comment">         * exception. Instead it passes it to the outermost transaction</span></div>
<div class="line"><span class="comment">         * - the abort is performed at that outermost level. In case of</span></div>
<div class="line"><span class="comment">         * a basic_transaction the abort would be done within the B ctor</span></div>
<div class="line"><span class="comment">         * and it would result in the same problems as with the previous</span></div>
<div class="line"><span class="comment">         * example.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_a9564707de1779ca1bce7041fb7c9855c"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::basic_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:676</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__free__error_html"><div class="ttname"><a href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:156</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__scope__error_html"><div class="ttname"><a href="classpmem_1_1transaction__scope__error.html">pmem::transaction_scope_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:167</div></div>
</div><!-- fragment --></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9754b2fad0aac24717598b7e586c7a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754b2fad0aac24717598b7e586c7a7d">&#9670;&nbsp;</a></span>automatic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">pmem::obj::flat_transaction::automatic</a> =  typename <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">detail::transaction_base</a>&lt;true&gt;::<a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a9754b2fad0aac24717598b7e586c7a7d">automatic</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ automatic scope transaction class. </p>
<p>This class is one of pmemobj transaction handlers. All operations between creating and destroying the transaction object are treated as performed in a transaction block and can be rolled back. If you have a C++17 compliant compiler, the automatic transaction will commit and abort automatically depending on the context of object destruction.</p>
<p>The locks are held for the entire duration of the transaction. They are released at the end of the scope, so within the <code>catch</code> block, they are already unlocked. If the cleanup action requires access to data within a critical section, the locks have to be manually acquired once again.</p>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__mutex_8hpp.html">libpmemobj++/shared_mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">automatic_tx_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        mutex pmutex;</div>
<div class="line">        shared_mutex shared_pmutex;</div>
<div class="line">        p&lt;int&gt; count;</div>
<div class="line">        persistent_ptr&lt;root&gt; another_root;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a8ffae81b74ffe313eb2deb16573d70e1">transaction::automatic</a> tx(pop, proot-&gt;pmutex,</div>
<div class="line">                      proot-&gt;shared_pmutex);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically allocate objects */</span></div>
<div class="line">        proot-&gt;another_root = make_persistent&lt;root&gt;();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically modify objects */</span></div>
<div class="line">        proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* manual transaction commit is no longer necessary */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* an internal transaction error occurred, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* some other exception thrown, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* In complex cases with library calls, remember to check the status of</span></div>
<div class="line"><span class="comment">     * the previous transaction. */</span></div>
<div class="line">    <span class="keywordflow">return</span> transaction::error();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_a8ffae81b74ffe313eb2deb16573d70e1"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#a8ffae81b74ffe313eb2deb16573d70e1">pmem::obj::basic_transaction::automatic</a></div><div class="ttdeci">typename detail::transaction_base&lt; false &gt;::automatic automatic</div><div class="ttdoc">C++ automatic scope transaction class.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:669</div></div>
<div class="ttc" id="amutex_8hpp_html"><div class="ttname"><a href="mutex_8hpp.html">mutex.hpp</a></div><div class="ttdoc">Pmem-resident mutex.</div></div>
<div class="ttc" id="ashared__mutex_8hpp_html"><div class="ttname"><a href="shared__mutex_8hpp.html">shared_mutex.hpp</a></div><div class="ttdoc">Pmem-resident shared mutex.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b5dd1361e26221d949a0c1c051c9824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5dd1361e26221d949a0c1c051c9824">&#9670;&nbsp;</a></span>manual</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">pmem::obj::flat_transaction::manual</a> =  typename <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">detail::transaction_base</a>&lt;true&gt;::<a class="el" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">manual</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ manual scope transaction class. </p>
<p>This class is one of pmemobj transaction handlers. All operations between creating and destroying the transaction object are treated as performed in a transaction block and can be rolled back. The manual transaction has to be committed explicitly in the outer most transaction - otherwise it will abort. Calling <a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb" title="Manually commit a transaction.">commit()</a> in inner transactions is optional.</p>
<p>The locks are held for the entire duration of the transaction. They are released at the end of the scope, so within the <code>catch</code> block, they are already unlocked. If the cleanup action requires access to data within a critical section, the locks have to be manually acquired once again.</p>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__mutex_8hpp.html">libpmemobj++/shared_mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">manual_flat_tx_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        mutex pmutex;</div>
<div class="line">        shared_mutex shared_pmutex;</div>
<div class="line">        p&lt;int&gt; count;</div>
<div class="line">        persistent_ptr&lt;root&gt; another_root;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">flat_transaction::manual</a> tx(pop, proot-&gt;pmutex);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically allocate objects */</span></div>
<div class="line">        proot-&gt;another_root = make_persistent&lt;root&gt;();</div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">flat_transaction::manual</a> inner_tx(pop,</div>
<div class="line">                              proot-&gt;shared_pmutex);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* atomically modify objects */</span></div>
<div class="line">            proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* OPTIONAL */</span></div>
<div class="line">            <span class="comment">// transaction::commit();</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Even if there is no explicit commit inner_tx will</span></div>
<div class="line"><span class="comment">             * not abort. This is true even if</span></div>
<div class="line"><span class="comment">             * flat_transaction::manual is destroyed because of an</span></div>
<div class="line"><span class="comment">             * active exception. For basic_transaction::manual you</span></div>
<div class="line"><span class="comment">             * have to call commit() at each level (as many times as</span></div>
<div class="line"><span class="comment">             * there are manual transaction objects). In case of</span></div>
<div class="line"><span class="comment">             * a flat_transaction, the commit has to be called only</span></div>
<div class="line"><span class="comment">             * once, at the outermost level.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* It&#39;s necessary to commit the transaction manually and</span></div>
<div class="line"><span class="comment">         * it has to be the last operation in the transaction. */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">transaction::commit</a>();</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* An internal transaction error occurred, outer tx aborted just</span></div>
<div class="line"><span class="comment">         * now. Reacquire locks if necessary, */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* Some other exception thrown, outer tx aborted just now.</span></div>
<div class="line"><span class="comment">         * Reacquire locks if necessary. */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* In complex cases with library calls, remember to check the status of</span></div>
<div class="line"><span class="comment">     * the last transaction. */</span></div>
<div class="line">    <span class="keywordflow">return</span> transaction::error();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1detail_1_1transaction__base_html_a16c0d86f943d6727e1caa7573cc83edb"><div class="ttname"><a href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">pmem::detail::transaction_base&lt; false &gt;::commit</a></div><div class="ttdeci">static void commit()</div><div class="ttdoc">Manually commit a transaction.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:330</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1flat__transaction_html_a4b5dd1361e26221d949a0c1c051c9824"><div class="ttname"><a href="classpmem_1_1obj_1_1flat__transaction.html#a4b5dd1361e26221d949a0c1c051c9824">pmem::obj::flat_transaction::manual</a></div><div class="ttdeci">typename detail::transaction_base&lt; true &gt;::manual manual</div><div class="ttdoc">C++ manual scope transaction class.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:745</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1e4345317108f070b1917aeb58d4c51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4345317108f070b1917aeb58d4c51d">&#9670;&nbsp;</a></span>stage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">pmem::detail::transaction_base::stage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible stages of a transaction. </p>
<p>For every stage one or more callbacks can be registered (see <a class="el" href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa" title="Registers callback to be called on specified stage for the transaction.">transaction::register_callback()</a>).</p>
<p>To read more about PMDK's transactions and their stages, see manpage pmemobj_tx_begin(3): <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_tx_begin.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_tx_begin.3</a> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc3bcf42e4b82b444a2e3a5a21d4ef8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3bcf42e4b82b444a2e3a5a21d4ef8c">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually abort the current transaction. </p>
<p>If called within an inner transaction, the outer transactions will also be aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>the error to be reported as the reason of the abort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>if the transaction is in an invalid state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class.">manual_tx_abort</a></td><td>this exception is thrown to signify a transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16c0d86f943d6727e1caa7573cc83edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c0d86f943d6727e1caa7573cc83edb">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually commit a transaction. </p>
<p>It is the sole responsibility of the caller, that after the call to <a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb" title="Manually commit a transaction.">transaction::commit()</a> no other operations are done within the transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>on any errors with ending the transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd22aa1c4862fc4e1974e39fca7f3dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd22aa1c4862fc4e1974e39fca7f3dfa">&#9670;&nbsp;</a></span>register_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">stage</a>&#160;</td>
          <td class="paramname"><em>stg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers callback to be called on specified stage for the transaction. </p>
<p>In case of nested transactions those callbacks are called when the outer most transaction enters a specified stage.</p>
<dl class="section pre"><dt>Precondition</dt><dd>this function must be called during a transaction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>when called outside of a transaction scope</td></tr>
  </table>
  </dd>
</dl>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_callback_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        p&lt;int&gt; count;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> cb_called = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">auto</span> internal_tx_function = [&amp;] {</div>
<div class="line">        <span class="comment">/* callbacks can be registered even in inner transaction but</span></div>
<div class="line"><span class="comment">         * will be called when outer transaction ends */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">transaction::run</a>(pop, [&amp;] {</div>
<div class="line">            <a class="code" href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa">transaction::register_callback</a>(</div>
<div class="line">                transaction::stage::oncommit,</div>
<div class="line">                [&amp;] { cb_called = <span class="keyword">true</span>; });</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* cb_called is false here if internal_tx_function is called</span></div>
<div class="line"><span class="comment">         * inside another transaction */</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">transaction::run</a>(pop, [&amp;] { internal_tx_function(); });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* cb_called == true if transaction ended successfully */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* an internal transaction error occurred, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* some other exception thrown, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1detail_1_1transaction__base_html_abd22aa1c4862fc4e1974e39fca7f3dfa"><div class="ttname"><a href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa">pmem::detail::transaction_base&lt; false &gt;::register_callback</a></div><div class="ttdeci">static void register_callback(stage stg, std::function&lt; void()&gt; cb)</div><div class="ttdoc">Registers callback to be called on specified stage for the transaction.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:487</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6162d1d30b3c679814498da961147c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6162d1d30b3c679814498da961147c54">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::flat_transaction::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a closure-like transaction and lock <code>locks</code>. </p>
<p>Starts new transaction and executes passed <code>tx</code> function transactionally. Transaction can only start when stage is WORK or NONE.</p>
<p>The locks have to be persistent memory resident locks. An attempt to lock the locks will be made. If any of the specified locks is already locked, the method will block. The locks are held until the end of the transaction. The transaction does not have to be committed manually. Manual aborts will end the transaction with an active exception.</p>
<p>If an exception is thrown within the transaction, it gets propagated to the outer most transaction. If the exception is not caught, it will result in a transaction abort.</p>
<p>The locks are held for the entire duration of the transaction. They are released at the end of the scope, so within the <code>catch</code> block, they are already unlocked. If the cleanup action requires access to data within a critical section, the locks have to be manually acquired once again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool in which the transaction will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx</td><td>an std::function&lt;void ()&gt; which will perform operations within this transaction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>locks to be taken for the duration of the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>on any error pertaining the execution of the transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class.">manual_tx_abort</a></td><td>on manual transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63dffc5d7316f67f900e4cf8de8b6422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dffc5d7316f67f900e4cf8de8b6422">&#9670;&nbsp;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::snapshot </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a “snapshot” of given elements of type T number (1 by default), located at the given address ptr in the virtual memory space and saves it to the undo log. </p>
<p>The application is then free to directly modify the object in that memory range. In case of a failure or abort, all the changes within this range will be rolled back. The supplied block of memory has to be within the pool registered in the transaction. This function must be called during transaction. This overload only participates in overload resolution of function template if T is either a trivially copyable type or some PMDK provided type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>pointer to the first object to be snapshotted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of elements to be snapshotted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must be called during transaction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when snapshotting failed or if function wasn't called during transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/<a class="el" href="transaction_8hpp_source.html">transaction.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html">flat_transaction</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
