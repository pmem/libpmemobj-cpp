<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::persistent_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.11</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1persistent__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::persistent_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent pointer class.  
 <a href="classpmem_1_1obj_1_1persistent__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="persistent__ptr_8hpp_source.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa0da8c77b8229979234b565b6e99b3e3"><td class="memItemLeft" align="right" valign="top"><a id="aa0da8c77b8229979234b565b6e99b3e3"></a>
typedef pmem::detail::sp_element&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a></td></tr>
<tr class="memdesc:aa0da8c77b8229979234b565b6e99b3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the actual object with all qualifiers removed, used for easy underlying type access. <br /></td></tr>
<tr class="separator:aa0da8c77b8229979234b565b6e99b3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5f287d06995fe517000650ee35a2a8"><td class="memTemplParams" colspan="2"><a id="a5a5f287d06995fe517000650ee35a2a8"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a5a5f287d06995fe517000650ee35a2a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a5a5f287d06995fe517000650ee35a2a8">rebind</a> = <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; U &gt;</td></tr>
<tr class="memdesc:a5a5f287d06995fe517000650ee35a2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind to a different type of pointer. <br /></td></tr>
<tr class="separator:a5a5f287d06995fe517000650ee35a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b743ee332a992f938b2e086e9f182d"><td class="memItemLeft" align="right" valign="top"><a id="a49b743ee332a992f938b2e086e9f182d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a49b743ee332a992f938b2e086e9f182d">persistency_type</a> = <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a49b743ee332a992f938b2e086e9f182d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The persistency type to be used with this pointer. <br /></td></tr>
<tr class="separator:a49b743ee332a992f938b2e086e9f182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e85a0b982f88b0eeb217cf3c0ad3e35"><td class="memItemLeft" align="right" valign="top"><a id="a3e85a0b982f88b0eeb217cf3c0ad3e35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a3e85a0b982f88b0eeb217cf3c0ad3e35">bool_type</a> = bool</td></tr>
<tr class="memdesc:a3e85a0b982f88b0eeb217cf3c0ad3e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The used bool_type. <br /></td></tr>
<tr class="separator:a3e85a0b982f88b0eeb217cf3c0ad3e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978fa74b702f6d40c235a68103d3e0ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a978fa74b702f6d40c235a68103d3e0ff">iterator_category</a> = std::random_access_iterator_tag</td></tr>
<tr class="memdesc:a978fa74b702f6d40c235a68103d3e0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator requirements (members)  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a978fa74b702f6d40c235a68103d3e0ff">More...</a><br /></td></tr>
<tr class="separator:a978fa74b702f6d40c235a68103d3e0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725a74e0fa382ae9cafbe90dbc0c3b7"><td class="memItemLeft" align="right" valign="top"><a id="ad725a74e0fa382ae9cafbe90dbc0c3b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ad725a74e0fa382ae9cafbe90dbc0c3b7">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ad725a74e0fa382ae9cafbe90dbc0c3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> difference type. <br /></td></tr>
<tr class="separator:ad725a74e0fa382ae9cafbe90dbc0c3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ba9ff5c043395ac9cebcb33dae7f21"><td class="memItemLeft" align="right" valign="top"><a id="aa9ba9ff5c043395ac9cebcb33dae7f21"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa9ba9ff5c043395ac9cebcb33dae7f21">value_type</a> = T</td></tr>
<tr class="memdesc:aa9ba9ff5c043395ac9cebcb33dae7f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:aa9ba9ff5c043395ac9cebcb33dae7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7015e71f65550faab67a820744f6bfa1"><td class="memItemLeft" align="right" valign="top"><a id="a7015e71f65550faab67a820744f6bfa1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a7015e71f65550faab67a820744f6bfa1">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a7015e71f65550faab67a820744f6bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:a7015e71f65550faab67a820744f6bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8000c13e9a76ddaae15a8df5344a5ba"><td class="memItemLeft" align="right" valign="top"><a id="ad8000c13e9a76ddaae15a8df5344a5ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ad8000c13e9a76ddaae15a8df5344a5ba">pointer</a> = <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ad8000c13e9a76ddaae15a8df5344a5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer type. <br /></td></tr>
<tr class="separator:ad8000c13e9a76ddaae15a8df5344a5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22b7f8fa1c18dd36c4a726e3cb25e584"><td class="memItemLeft" align="right" valign="top"><a id="a22b7f8fa1c18dd36c4a726e3cb25e584"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a22b7f8fa1c18dd36c4a726e3cb25e584">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; void &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a22b7f8fa1c18dd36c4a726e3cb25e584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit void specialization of the converting constructor. <br /></td></tr>
<tr class="separator:a22b7f8fa1c18dd36c4a726e3cb25e584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602b7a7c3030bbb04b200e4390676337"><td class="memItemLeft" align="right" valign="top"><a id="a602b7a7c3030bbb04b200e4390676337"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a602b7a7c3030bbb04b200e4390676337">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; const void &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a602b7a7c3030bbb04b200e4390676337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit const void specialization of the converting constructor. <br /></td></tr>
<tr class="separator:a602b7a7c3030bbb04b200e4390676337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ba8801160ec958ce7bba25179f646"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a9f2ba8801160ec958ce7bba25179f646">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a> *ptr)</td></tr>
<tr class="memdesc:a9f2ba8801160ec958ce7bba25179f646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile pointer constructor.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a9f2ba8801160ec958ce7bba25179f646">More...</a><br /></td></tr>
<tr class="separator:a9f2ba8801160ec958ce7bba25179f646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767d19090d50575fe12d0e73d29ce26"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;			  !std::is_same&lt;T, U&gt;::value &amp;&amp;			  std::is_same&lt;typename std::remove_cv&lt;T&gt;::type,				       U&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac767d19090d50575fe12d0e73d29ce26"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ac767d19090d50575fe12d0e73d29ce26">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; U &gt; const &amp;r) noexcept</td></tr>
<tr class="memdesc:ac767d19090d50575fe12d0e73d29ce26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a different persistent_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#ac767d19090d50575fe12d0e73d29ce26">More...</a><br /></td></tr>
<tr class="separator:ac767d19090d50575fe12d0e73d29ce26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1bd3321cb14059719ed1c8c89bfa05"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Dummy  = void, typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </td></tr>
<tr class="memitem:aca1bd3321cb14059719ed1c8c89bfa05"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aca1bd3321cb14059719ed1c8c89bfa05">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; U &gt; const &amp;r) noexcept</td></tr>
<tr class="memdesc:aca1bd3321cb14059719ed1c8c89bfa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a different persistent_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#aca1bd3321cb14059719ed1c8c89bfa05">More...</a><br /></td></tr>
<tr class="separator:aca1bd3321cb14059719ed1c8c89bfa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eceeb630b864b49d68bb184c0253331"><td class="memItemLeft" align="right" valign="top"><a id="a6eceeb630b864b49d68bb184c0253331"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a6eceeb630b864b49d68bb184c0253331">operator persistent_ptr&lt; void &gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a6eceeb630b864b49d68bb184c0253331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent pointer to void conversion operator. <br /></td></tr>
<tr class="separator:a6eceeb630b864b49d68bb184c0253331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bb784984c1e92e028d0d568e7db3ae"><td class="memItemLeft" align="right" valign="top"><a id="a55bb784984c1e92e028d0d568e7db3ae"></a>
pmem::detail::sp_dereference&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a55bb784984c1e92e028d0d568e7db3ae">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a55bb784984c1e92e028d0d568e7db3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator. <br /></td></tr>
<tr class="separator:a55bb784984c1e92e028d0d568e7db3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60126ca2fe1952c22d85ba73ea05575a"><td class="memItemLeft" align="right" valign="top"><a id="a60126ca2fe1952c22d85ba73ea05575a"></a>
pmem::detail::sp_member_access&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a60126ca2fe1952c22d85ba73ea05575a">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a60126ca2fe1952c22d85ba73ea05575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator. <br /></td></tr>
<tr class="separator:a60126ca2fe1952c22d85ba73ea05575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ab81005cbc26bbb5fd796cacb5f809"><td class="memTemplParams" colspan="2">template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a90ab81005cbc26bbb5fd796cacb5f809"><td class="memTemplItemLeft" align="right" valign="top">pmem::detail::sp_array_access&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a90ab81005cbc26bbb5fd796cacb5f809">operator[]</a> (std::ptrdiff_t i) const noexcept</td></tr>
<tr class="memdesc:a90ab81005cbc26bbb5fd796cacb5f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array access operator.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a90ab81005cbc26bbb5fd796cacb5f809">More...</a><br /></td></tr>
<tr class="separator:a90ab81005cbc26bbb5fd796cacb5f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc70b76fe385715c59d72e12420b6070"><td class="memItemLeft" align="right" valign="top"><a id="abc70b76fe385715c59d72e12420b6070"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#abc70b76fe385715c59d72e12420b6070">operator++</a> ()</td></tr>
<tr class="memdesc:abc70b76fe385715c59d72e12420b6070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator. <br /></td></tr>
<tr class="separator:abc70b76fe385715c59d72e12420b6070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca3c65cd59cda6dbf98a510c5fe242"><td class="memItemLeft" align="right" valign="top"><a id="a52ca3c65cd59cda6dbf98a510c5fe242"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a52ca3c65cd59cda6dbf98a510c5fe242">operator++</a> (int)</td></tr>
<tr class="memdesc:a52ca3c65cd59cda6dbf98a510c5fe242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator. <br /></td></tr>
<tr class="separator:a52ca3c65cd59cda6dbf98a510c5fe242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0a128d4b126684827fa624a4f4d602"><td class="memItemLeft" align="right" valign="top"><a id="a4d0a128d4b126684827fa624a4f4d602"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a4d0a128d4b126684827fa624a4f4d602">operator--</a> ()</td></tr>
<tr class="memdesc:a4d0a128d4b126684827fa624a4f4d602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator. <br /></td></tr>
<tr class="separator:a4d0a128d4b126684827fa624a4f4d602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69b7d64fdfc5d48e6e3110a1cb7f46"><td class="memItemLeft" align="right" valign="top"><a id="a7f69b7d64fdfc5d48e6e3110a1cb7f46"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a7f69b7d64fdfc5d48e6e3110a1cb7f46">operator--</a> (int)</td></tr>
<tr class="memdesc:a7f69b7d64fdfc5d48e6e3110a1cb7f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator. <br /></td></tr>
<tr class="separator:a7f69b7d64fdfc5d48e6e3110a1cb7f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e03767491d6a3d3d7ce5fae7a8bb6c"><td class="memItemLeft" align="right" valign="top"><a id="a57e03767491d6a3d3d7ce5fae7a8bb6c"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a57e03767491d6a3d3d7ce5fae7a8bb6c">operator+=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a57e03767491d6a3d3d7ce5fae7a8bb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. <br /></td></tr>
<tr class="separator:a57e03767491d6a3d3d7ce5fae7a8bb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc718501518e2bbb567dcc12d501c44"><td class="memItemLeft" align="right" valign="top"><a id="a7cc718501518e2bbb567dcc12d501c44"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a7cc718501518e2bbb567dcc12d501c44">operator-=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a7cc718501518e2bbb567dcc12d501c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator. <br /></td></tr>
<tr class="separator:a7cc718501518e2bbb567dcc12d501c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4241eff22b48089de2df630af6b0c493"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4241eff22b48089de2df630af6b0c493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a4241eff22b48089de2df630af6b0c493">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;r)</td></tr>
<tr class="memdesc:a4241eff22b48089de2df630af6b0c493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting assignment operator from a different persistent_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a4241eff22b48089de2df630af6b0c493">More...</a><br /></td></tr>
<tr class="separator:a4241eff22b48089de2df630af6b0c493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a44b42d2e9466cff96b62d1439b559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a25a44b42d2e9466cff96b62d1439b559">persist</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;pop)</td></tr>
<tr class="memdesc:a25a44b42d2e9466cff96b62d1439b559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persists the content of the underlying object.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a25a44b42d2e9466cff96b62d1439b559">More...</a><br /></td></tr>
<tr class="separator:a25a44b42d2e9466cff96b62d1439b559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199f8eb81d381af36016d5c784780df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a3199f8eb81d381af36016d5c784780df">persist</a> (void)</td></tr>
<tr class="memdesc:a3199f8eb81d381af36016d5c784780df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persists what the persistent pointer points to.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a3199f8eb81d381af36016d5c784780df">More...</a><br /></td></tr>
<tr class="separator:a3199f8eb81d381af36016d5c784780df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3576b7c9381e281518a077ee76e9188e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a3576b7c9381e281518a077ee76e9188e">flush</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;pop)</td></tr>
<tr class="memdesc:a3576b7c9381e281518a077ee76e9188e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes what the persistent pointer points to.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a3576b7c9381e281518a077ee76e9188e">More...</a><br /></td></tr>
<tr class="separator:a3576b7c9381e281518a077ee76e9188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fe3d39a95e1281ba102a3fc51fa1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a52fe3d39a95e1281ba102a3fc51fa1a3">flush</a> (void)</td></tr>
<tr class="memdesc:a52fe3d39a95e1281ba102a3fc51fa1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes what the persistent pointer points to.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a52fe3d39a95e1281ba102a3fc51fa1a3">More...</a><br /></td></tr>
<tr class="separator:a52fe3d39a95e1281ba102a3fc51fa1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45c60e7966d086029c42d151ce969e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ad45c60e7966d086029c42d151ce969e0">get</a> () const noexcept</td></tr>
<tr class="memdesc:ad45c60e7966d086029c42d151ce969e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direct pointer.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#ad45c60e7966d086029c42d151ce969e0">More...</a><br /></td></tr>
<tr class="separator:ad45c60e7966d086029c42d151ce969e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51602c5383f310740e4e0c70c98b07b5"><td class="memItemLeft" align="right" valign="top"><a id="a51602c5383f310740e4e0c70c98b07b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a51602c5383f310740e4e0c70c98b07b5">persistent_ptr_base</a> () noexcept</td></tr>
<tr class="memdesc:a51602c5383f310740e4e0c70c98b07b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, zeroes the PMEMoid. <br /></td></tr>
<tr class="separator:a51602c5383f310740e4e0c70c98b07b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6526afba61462160150673fcf7489971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a6526afba61462160150673fcf7489971">persistent_ptr_base</a> (PMEMoid oid) noexcept</td></tr>
<tr class="memdesc:a6526afba61462160150673fcf7489971"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMEMoid constructor.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a6526afba61462160150673fcf7489971">More...</a><br /></td></tr>
<tr class="separator:a6526afba61462160150673fcf7489971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab189ea8e11b71db7fb9e371b9635b56b"><td class="memItemLeft" align="right" valign="top"><a id="ab189ea8e11b71db7fb9e371b9635b56b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ab189ea8e11b71db7fb9e371b9635b56b">persistent_ptr_base</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a> &amp;&amp;r) noexcept</td></tr>
<tr class="memdesc:ab189ea8e11b71db7fb9e371b9635b56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:ab189ea8e11b71db7fb9e371b9635b56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aff9a32d18e6ccaf34b1c08ca3ddeb473"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aff9a32d18e6ccaf34b1c08ca3ddeb473">pointer_to</a> (T &amp;ref)</td></tr>
<tr class="memdesc:aff9a32d18e6ccaf34b1c08ca3ddeb473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a persistent pointer from a given reference.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#aff9a32d18e6ccaf34b1c08ca3ddeb473">More...</a><br /></td></tr>
<tr class="separator:aff9a32d18e6ccaf34b1c08ca3ddeb473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae5e4e6f4f66affcd0b29ffb8ea27038d"><td class="memItemLeft" align="right" valign="top"><a id="ae5e4e6f4f66affcd0b29ffb8ea27038d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ae5e4e6f4f66affcd0b29ffb8ea27038d">verify_type</a> ()</td></tr>
<tr class="memdesc:ae5e4e6f4f66affcd0b29ffb8ea27038d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if element_type is not polymorphic. <br /></td></tr>
<tr class="separator:ae5e4e6f4f66affcd0b29ffb8ea27038d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5d64a209866470043a33409cbd1764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#adf5d64a209866470043a33409cbd1764">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a> *vptr, int)</td></tr>
<tr class="memdesc:adf5d64a209866470043a33409cbd1764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private constructor enabling persistent_ptrs to volatile objects.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#adf5d64a209866470043a33409cbd1764">More...</a><br /></td></tr>
<tr class="separator:adf5d64a209866470043a33409cbd1764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0cdb42d48a60e158e75638896b8687"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acd0cdb42d48a60e158e75638896b8687"><td class="memTemplItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#acd0cdb42d48a60e158e75638896b8687">calculate_offset</a> () const</td></tr>
<tr class="memdesc:acd0cdb42d48a60e158e75638896b8687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate in-object offset for structures with inheritance.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#acd0cdb42d48a60e158e75638896b8687">More...</a><br /></td></tr>
<tr class="separator:acd0cdb42d48a60e158e75638896b8687"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::persistent_ptr&lt; T &gt;</h3>

<p>Persistent pointer class. </p>
<p><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> implements a smart ptr. It encapsulates the PMEMoid fat pointer and provides member access, dereference and array access operators.</p>
<p>Template parameter type has following requirements:</p><ul>
<li>Is not polymorphic</li>
<li>Has no non-static data members of reference type</li>
<li>Satisfies Destructible requirement: <a href="https://en.cppreference.com/w/cpp/named_req/Destructible">https://en.cppreference.com/w/cpp/named_req/Destructible</a></li>
<li>All non-static data members and base classes follow the same requirements</li>
</ul>
Even if all of the above requirements are met, type representation may vary depending on ABI and compiler optimizations (as stated in [class.mem]: "the order of allocation of non-static data members with different access control is unspecified"). To enforce the same layout for all ABIs and optimization levels type should satisfy StandardLayoutType requirement.If pointer is used with array type, additional requirement is:</p><ul>
<li>Element type must be default constructible</li>
</ul>
The pointer is not designed to work with polymorphic types, as they have runtime RTTI info embedded, which is implementation specific and thus not consistently rebuildable. Such constructs as polymorphic members or members of a union defined within a class held in a pointer will also yield undefined behavior.C++ standard states that lifetime of an object is a runtime property [basic.lifetime]. Conditions which must be fulfilled for object's lifetime to begin, imply that using any non-trivially constructible object with pointer is undefined behaviour. This is being partially addressed by the following proposal: <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo</a>Another caveat is that snapshotting elements in a transaction and performing rollback uses memcpy internally. Using memcpy on an object in C++ is allowed by the standard only if the type satisfies TriviallyCopyable requirement. </p>
<p>This type does NOT manage the life-cycle of the object. The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">persistent_ptr_example()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>compound_type {</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span></div>
<div class="line">        set_some_variable(<span class="keywordtype">int</span> val)</div>
<div class="line">        {</div>
<div class="line">            some_variable = val;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> some_variable;</div>
<div class="line">        <span class="keywordtype">double</span> some_other_variable;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;compound_type&gt;</a> comp;</div>
<div class="line">    } proot;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* typical usage schemes */</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">transaction::run</a>(pop, [&amp;] {</div>
<div class="line">        proot.comp = make_persistent&lt;compound_type&gt;(); <span class="comment">/* allocation */</span></div>
<div class="line">        proot.comp-&gt;set_some_variable(12);     <span class="comment">/* call function */</span></div>
<div class="line">        proot.comp-&gt;some_other_variable = 2.3; <span class="comment">/* set variable */</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* reading from the persistent_ptr */</span></div>
<div class="line">    compound_type tmp = *proot.comp;</div>
<div class="line">    (void)tmp;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Changing a persistent_ptr&lt;&gt; variable outside of a transaction is a</span></div>
<div class="line"><span class="comment">     * volatile modification. No way to ensure persistence in case of power</span></div>
<div class="line"><span class="comment">     * failure. */</span></div>
<div class="line">    proot.comp-&gt;some_variable = 12;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Casting to <a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html" title="Persistent_ptr base (non-template) class.">persistent_ptr_base</a> can be easily done from any persistent_ptr&lt;T&gt; objects, but when casting between convertible objects be advised to use constructors or operator= specified for such conversion, see:</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ac767d19090d50575fe12d0e73d29ce26" title="Copy constructor from a different persistent_ptr&lt;&gt;.">persistent_ptr::persistent_ptr(persistent_ptr&lt;U&gt; const &amp;r)</a> ,</li>
<li>persistent_ptr&lt;T&gt; &amp; <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a4241eff22b48089de2df630af6b0c493" title="Converting assignment operator from a different persistent_ptr&lt;&gt;.">operator=(persistent_ptr&lt;Y&gt; const &amp;r)</a> . When casting indirectly with (void *) or using static_cast, and then casting to the second (convertible) type, the offset will not be re-calculated.</li>
</ul>
<p>Below you can find an example how to and how NOT to cast <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>'s: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr__base_8hpp.html">libpmemobj++/persistent_ptr_base.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">persistent_ptr_conversion_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;int&gt;</a> pfoo;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Casting persistent_ptr to persistent_ptr_base */</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">transaction::run</a>(pop, [&amp;] {</div>
<div class="line">        <span class="comment">/* Good: any persistent_ptr&lt;T&gt; can be stored in a base ptr */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a> i_ptr_base = make_persistent&lt;int&gt;(10);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Wrong: even though raw pointer can be used to create new</span></div>
<div class="line"><span class="comment">         * persistent_ptr it&#39;s not advised to use it this way, since</span></div>
<div class="line"><span class="comment">         * there&#39;s no information about underlying/template type</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;double&gt;</a> dptr = i_ptr_base.<a class="code" href="classpmem_1_1obj_1_1persistent__ptr__base.html#aa75eca8b91580df65760e63270e3dae8">raw</a>();</div>
<div class="line">        std::cout &lt;&lt; *dptr; <span class="comment">// contains trash data</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Acceptable: it&#39;s not advised, but it will work properly.</span></div>
<div class="line"><span class="comment">         * Although, you have to be sure the underlying type is correct</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;int&gt;</a> iptr_nonbase = i_ptr_base.<a class="code" href="classpmem_1_1obj_1_1persistent__ptr__base.html#aa75eca8b91580df65760e63270e3dae8">raw</a>();</div>
<div class="line">        std::cout &lt;&lt; *iptr_nonbase; <span class="comment">// contains proper data</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Wrong: illegal call for derived constructor.</span></div>
<div class="line"><span class="comment">         * no viable conversion from &#39;persistent_ptr_base&#39; to</span></div>
<div class="line"><span class="comment">         * &#39;persistent_ptr&lt;int&gt;&#39;</span></div>
<div class="line"><span class="comment">         * iptr_nonbase = i_ptr_base;</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Wrong: conversion from base class to persistent_ptr&lt;T&gt; is not</span></div>
<div class="line"><span class="comment">         * possible: no matching conversion from &#39;persistent_ptr_base&#39;</span></div>
<div class="line"><span class="comment">         * to &#39;persistent_ptr&lt;int&gt;&#39;</span></div>
<div class="line"><span class="comment">         * iptr_nonbase = static_cast&lt;persistent_ptr&lt;int&gt;&gt;(i_ptr_base);</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Good: you can use base and ptr classes with volatile pointer</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;int&gt;</a> i_ptr = make_persistent&lt;int&gt;(10);</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a> *i_ptr_ref = &amp;i_ptr;</div>
<div class="line">        std::cout &lt;&lt; i_ptr_ref-&gt;<a class="code" href="classpmem_1_1obj_1_1persistent__ptr__base.html#aa75eca8b91580df65760e63270e3dae8">raw</a>().off; <span class="comment">/* contains PMEMoid&#39;s data */</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>A {</div>
<div class="line">        uint64_t a;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">struct </span>B {</div>
<div class="line">        uint64_t b;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">struct </span>C : <span class="keyword">public</span> A, <span class="keyword">public</span> B {</div>
<div class="line">        uint64_t c;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Convertible types, using struct A, B and C */</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">transaction::run</a>(pop, [] {</div>
<div class="line">        <span class="comment">/* Good: conversion from type C to B, using copy constructor */</span></div>
<div class="line">        <span class="keyword">auto</span> cptr = make_persistent&lt;C&gt;();</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;B&gt;</a> bptr = cptr;</div>
<div class="line">        std::cout &lt;&lt; (bptr-&gt;b ==</div>
<div class="line">                  cptr-&gt;b); <span class="comment">/* thanks to conversion and */</span></div>
<div class="line">                    <span class="comment">/* recalculating offsets it&#39;s correct */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Good: conversion from type C to B, using converting</span></div>
<div class="line"><span class="comment">         * assignment operator</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;B&gt;</a> bptr2;</div>
<div class="line">        bptr2 = cptr;</div>
<div class="line">        std::cout &lt;&lt; (bptr2-&gt;b == cptr-&gt;b); <span class="comment">/* true */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Good: direct conversion using static_cast */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;B&gt;</a> bptr3 = <span class="keyword">static_cast&lt;</span><a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;B&gt;</a><span class="keyword">&gt;</span>(cptr);</div>
<div class="line">        std::cout &lt;&lt; (bptr3-&gt;b == cptr-&gt;b); <span class="comment">/* true */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Wrong: conversion to base class and then to different ptr.</span></div>
<div class="line"><span class="comment">         * class no matching conversion from &#39;persistent_ptr_base&#39; to</span></div>
<div class="line"><span class="comment">         * &#39;persistent_ptr&lt;B&gt;&#39;</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * auto cptr2 = (persistent_ptr_base)cptr;</span></div>
<div class="line"><span class="comment">         * persistent_ptr&lt;B&gt; bptr4 =</span></div>
<div class="line"><span class="comment">         *      static_cast&lt;persistent_ptr&lt;B&gt;&gt;(cptr2);</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Wrong: conversion to &#39;void *&#39; and then to different ptr</span></div>
<div class="line"><span class="comment">         * class. ambiguous conversion from &#39;void *&#39; to</span></div>
<div class="line"><span class="comment">         * &#39;persistent_ptr&lt;B&gt;&#39;</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * auto cptr3 = (void *)&amp;cptr;</span></div>
<div class="line"><span class="comment">         * persistent_ptr&lt;B&gt; bptr5 =</span></div>
<div class="line"><span class="comment">         *      static_cast&lt;persistent_ptr&lt;B&gt;&gt;(cptr3);</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a978fa74b702f6d40c235a68103d3e0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978fa74b702f6d40c235a68103d3e0ff">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a978fa74b702f6d40c235a68103d3e0ff">iterator_category</a> =  std::random_access_iterator_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random access iterator requirements (members) </p>
<p>The <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> iterator category. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f2ba8801160ec958ce7bba25179f646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2ba8801160ec958ce7bba25179f646">&#9670;&nbsp;</a></span>persistent_ptr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volatile pointer constructor. </p>
<p>If ptr does not point to an address from a valid pool, the persistent pointer will evaluate to nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>volatile pointer, pointing to persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac767d19090d50575fe12d0e73d29ce26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac767d19090d50575fe12d0e73d29ce26">&#9670;&nbsp;</a></span>persistent_ptr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;			  !std::is_same&lt;T, U&gt;::value &amp;&amp;			  std::is_same&lt;typename std::remove_cv&lt;T&gt;::type,				       U&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a different persistent_ptr&lt;&gt;. </p>
<p>Available only for convertible types. </p>

</div>
</div>
<a id="aca1bd3321cb14059719ed1c8c89bfa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1bd3321cb14059719ed1c8c89bfa05">&#9670;&nbsp;</a></span>persistent_ptr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename Dummy  = void, typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a different persistent_ptr&lt;&gt;. </p>
<p>Available only for convertible, non-void types. </p>

</div>
</div>
<a id="adf5d64a209866470043a33409cbd1764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5d64a209866470043a33409cbd1764">&#9670;&nbsp;</a></span>persistent_ptr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a> *&#160;</td>
          <td class="paramname"><em>vptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private constructor enabling persistent_ptrs to volatile objects. </p>
<p>This is internal implementation needed only for the pointer_traits&lt;persistent_ptr&gt;::pointer_to to be able to create valid pointers. This is used in libstdc++'s std::vector::insert(). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd0cdb42d48a60e158e75638896b8687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0cdb42d48a60e158e75638896b8687">&#9670;&nbsp;</a></span>calculate_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::calculate_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate in-object offset for structures with inheritance. </p>
<p>In case of the given inheritance:</p>
<p>A B \ / C</p>
<p>A pointer to B *ptr = &amp;C should be offset by sizeof(A). This function calculates that offset.</p>
<dl class="section return"><dt>Returns</dt><dd>offset between two compatible pointer types to the same object </dd></dl>

</div>
</div>
<a id="a3576b7c9381e281518a077ee76e9188e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3576b7c9381e281518a077ee76e9188e">&#9670;&nbsp;</a></span>flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes what the persistent pointer points to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pop</td><td>Pmemobj pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52fe3d39a95e1281ba102a3fc51fa1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fe3d39a95e1281ba102a3fc51fa1a3">&#9670;&nbsp;</a></span>flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes what the persistent pointer points to. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>when cannot get pool from persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad45c60e7966d086029c42d151ce969e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45c60e7966d086029c42d151ce969e0">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa0da8c77b8229979234b565b6e99b3e3">element_type</a>* <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the direct pointer. </p>
<p>Performs a calculations on the underlying C-style pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>the direct pointer to the object. </dd></dl>

</div>
</div>
<a id="a4241eff22b48089de2df630af6b0c493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4241eff22b48089de2df630af6b0c493">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt;T&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting assignment operator from a different persistent_ptr&lt;&gt;. </p>
<p>Available only for convertible types. Just like regular assignment, also automatically registers itself in a transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ab81005cbc26bbb5fd796cacb5f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ab81005cbc26bbb5fd796cacb5f809">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::detail::sp_array_access&lt;T&gt;::type <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array access operator. </p>
<p>Contains run-time bounds checking for static arrays. </p>

</div>
</div>
<a id="a25a44b42d2e9466cff96b62d1439b559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a44b42d2e9466cff96b62d1439b559">&#9670;&nbsp;</a></span>persist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::persist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Persists the content of the underlying object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pop</td><td>Pmemobj pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3199f8eb81d381af36016d5c784780df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3199f8eb81d381af36016d5c784780df">&#9670;&nbsp;</a></span>persist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::persist </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Persists what the persistent pointer points to. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>when cannot get pool from persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6526afba61462160150673fcf7489971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6526afba61462160150673fcf7489971">&#9670;&nbsp;</a></span>persistent_ptr_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::obj::persistent_ptr_base::persistent_ptr_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PMEMoid constructor. </p>
<p>Provided for easy interoperability between C++ and C API's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>C-style persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff9a32d18e6ccaf34b1c08ca3ddeb473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9a32d18e6ccaf34b1c08ca3ddeb473">&#9670;&nbsp;</a></span>pointer_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::pointer_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a persistent pointer from a given reference. </p>
<p>This can create a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> to a volatile object, use with extreme caution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>reference to an object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libpmemobj++/detail/<a class="el" href="common_8hpp_source.html">common.hpp</a></li>
<li>libpmemobj++/<a class="el" href="persistent__ptr_8hpp_source.html">persistent_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:674</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr__base_html_aa75eca8b91580df65760e63270e3dae8"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr__base.html#aa75eca8b91580df65760e63270e3dae8">pmem::obj::persistent_ptr_base::raw</a></div><div class="ttdeci">const PMEMoid &amp; raw() const noexcept</div><div class="ttdoc">Get PMEMoid encapsulated by this object.</div><div class="ttdef"><b>Definition:</b> persistent_ptr_base.hpp:151</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">Persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1transaction_html_aae32a7ede01bfcf20672433263267387"><div class="ttname"><a href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">pmem::obj::transaction::run</a></div><div class="ttdeci">static void run(pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:406</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr_html"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a></div><div class="ttdoc">Persistent pointer class.</div><div class="ttdef"><b>Definition:</b> persistent_ptr.hpp:152</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr__base_html"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr__base.html">pmem::obj::persistent_ptr_base</a></div><div class="ttdoc">Persistent_ptr base (non-template) class.</div><div class="ttdef"><b>Definition:</b> persistent_ptr_base.hpp:42</div></div>
<div class="ttc" id="apersistent__ptr__base_8hpp_html"><div class="ttname"><a href="persistent__ptr__base_8hpp.html">persistent_ptr_base.hpp</a></div><div class="ttdoc">Base class for persistent_ptr.</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
