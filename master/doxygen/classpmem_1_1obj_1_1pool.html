<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::pool&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git107.g7e59f08f</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpmem_1_1obj_1_1pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classpmem_1_1obj_1_1pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::pool&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__primitives.html">Primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>PMEMobj pool class.  
 <a href="classpmem_1_1obj_1_1pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pool_8hpp_source.html">libpmemobj++/pool.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pmem::obj::pool&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpmem_1_1obj_1_1pool__inherit__graph.png" border="0" usemap="#apmem_1_1obj_1_1pool_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="apmem_1_1obj_1_1pool_3_01T_01_4_inherit__map" id="apmem_1_1obj_1_1pool_3_01T_01_4_inherit__map">
<area shape="rect" title="PMEMobj pool class." alt="" coords="7,80,154,107"/>
<area shape="rect" href="classpmem_1_1obj_1_1pool__base.html" title="The non&#45;template pool base class." alt="" coords="5,5,156,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae26e5edd74a7fecaa683353fc22fe8b5"><td class="memItemLeft" align="right" valign="top"><a id="ae26e5edd74a7fecaa683353fc22fe8b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#ae26e5edd74a7fecaa683353fc22fe8b5">pool</a> () noexcept=default</td></tr>
<tr class="memdesc:ae26e5edd74a7fecaa683353fc22fe8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted constructor. <br /></td></tr>
<tr class="separator:ae26e5edd74a7fecaa683353fc22fe8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5473cb18d6e9cd0ab88fc875c611e2b"><td class="memItemLeft" align="right" valign="top"><a id="aa5473cb18d6e9cd0ab88fc875c611e2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#aa5473cb18d6e9cd0ab88fc875c611e2b">pool</a> (const <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;) noexcept=default</td></tr>
<tr class="memdesc:aa5473cb18d6e9cd0ab88fc875c611e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:aa5473cb18d6e9cd0ab88fc875c611e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b44411aeb6b321e38d7378d5b62ece"><td class="memItemLeft" align="right" valign="top"><a id="a41b44411aeb6b321e38d7378d5b62ece"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a41b44411aeb6b321e38d7378d5b62ece">pool</a> (<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a41b44411aeb6b321e38d7378d5b62ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a41b44411aeb6b321e38d7378d5b62ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5143f7a1d95c97781de03e9062fc85cc"><td class="memItemLeft" align="right" valign="top"><a id="a5143f7a1d95c97781de03e9062fc85cc"></a>
<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a5143f7a1d95c97781de03e9062fc85cc">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;) noexcept=default</td></tr>
<tr class="memdesc:a5143f7a1d95c97781de03e9062fc85cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy assignment operator. <br /></td></tr>
<tr class="separator:a5143f7a1d95c97781de03e9062fc85cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0621e8ce454f924858b65e27866c69a"><td class="memItemLeft" align="right" valign="top"><a id="ad0621e8ce454f924858b65e27866c69a"></a>
<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#ad0621e8ce454f924858b65e27866c69a">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ad0621e8ce454f924858b65e27866c69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move assignment operator. <br /></td></tr>
<tr class="separator:ad0621e8ce454f924858b65e27866c69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6240769ecb4fd657c9c0eae53b7a78"><td class="memItemLeft" align="right" valign="top"><a id="a1f6240769ecb4fd657c9c0eae53b7a78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a1f6240769ecb4fd657c9c0eae53b7a78">~pool</a> () noexcept=default</td></tr>
<tr class="memdesc:a1f6240769ecb4fd657c9c0eae53b7a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a1f6240769ecb4fd657c9c0eae53b7a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b373fb46d72a5c395194ff71af8ff17"><td class="memItemLeft" align="right" valign="top"><a id="a7b373fb46d72a5c395194ff71af8ff17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a7b373fb46d72a5c395194ff71af8ff17">pool</a> (const <a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;pb) noexcept</td></tr>
<tr class="memdesc:a7b373fb46d72a5c395194ff71af8ff17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a7b373fb46d72a5c395194ff71af8ff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e3d24e46a574a4cc092bdb1af57a3c"><td class="memItemLeft" align="right" valign="top"><a id="a71e3d24e46a574a4cc092bdb1af57a3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a71e3d24e46a574a4cc092bdb1af57a3c">pool</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&amp;pb) noexcept</td></tr>
<tr class="memdesc:a71e3d24e46a574a4cc092bdb1af57a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a71e3d24e46a574a4cc092bdb1af57a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8253223d35089f9736fe37cc1f38ed53"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a8253223d35089f9736fe37cc1f38ed53"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a8253223d35089f9736fe37cc1f38ed53">ctl_get</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8253223d35089f9736fe37cc1f38ed53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a8253223d35089f9736fe37cc1f38ed53">More...</a><br /></td></tr>
<tr class="separator:a8253223d35089f9736fe37cc1f38ed53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f19b41b5e921b5edd0cf46cab20369e"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a3f19b41b5e921b5edd0cf46cab20369e"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a3f19b41b5e921b5edd0cf46cab20369e">ctl_set</a> (const std::string &amp;name, M arg)</td></tr>
<tr class="memdesc:a3f19b41b5e921b5edd0cf46cab20369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a3f19b41b5e921b5edd0cf46cab20369e">More...</a><br /></td></tr>
<tr class="separator:a3f19b41b5e921b5edd0cf46cab20369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c170c19673a29ace63092d083781330"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a7c170c19673a29ace63092d083781330"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a7c170c19673a29ace63092d083781330">ctl_exec</a> (const std::string &amp;name, M arg)</td></tr>
<tr class="memdesc:a7c170c19673a29ace63092d083781330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a7c170c19673a29ace63092d083781330">More...</a><br /></td></tr>
<tr class="separator:a7c170c19673a29ace63092d083781330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9909db1249389347b4d81b00a5e3df6"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ad9909db1249389347b4d81b00a5e3df6"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#ad9909db1249389347b4d81b00a5e3df6">ctl_get</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:ad9909db1249389347b4d81b00a5e3df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#ad9909db1249389347b4d81b00a5e3df6">More...</a><br /></td></tr>
<tr class="separator:ad9909db1249389347b4d81b00a5e3df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef9f3fd95a13e5a7361e756471e022b"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a3ef9f3fd95a13e5a7361e756471e022b"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a3ef9f3fd95a13e5a7361e756471e022b">ctl_set</a> (const std::wstring &amp;name, M arg)</td></tr>
<tr class="memdesc:a3ef9f3fd95a13e5a7361e756471e022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a3ef9f3fd95a13e5a7361e756471e022b">More...</a><br /></td></tr>
<tr class="separator:a3ef9f3fd95a13e5a7361e756471e022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af453acceffd968ca68108e3475a7cfdc"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:af453acceffd968ca68108e3475a7cfdc"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#af453acceffd968ca68108e3475a7cfdc">ctl_exec</a> (const std::wstring &amp;name, M arg)</td></tr>
<tr class="memdesc:af453acceffd968ca68108e3475a7cfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#af453acceffd968ca68108e3475a7cfdc">More...</a><br /></td></tr>
<tr class="separator:af453acceffd968ca68108e3475a7cfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b71b78e8229b009639835a5ad159d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">root</a> ()</td></tr>
<tr class="memdesc:a85b71b78e8229b009639835a5ad159d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves pool's root object.  <a href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">More...</a><br /></td></tr>
<tr class="separator:a85b71b78e8229b009639835a5ad159d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba2534f64b5a04367a60aa3a989f495"><td class="memItemLeft" align="right" valign="top"><a id="a2ba2534f64b5a04367a60aa3a989f495"></a>
POBJ_CPP_DEPRECATED <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_root</b> ()</td></tr>
<tr class="separator:a2ba2534f64b5a04367a60aa3a989f495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54af0122ce7be0754305b7b27f4e2fc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a54af0122ce7be0754305b7b27f4e2fc6">close</a> ()</td></tr>
<tr class="memdesc:a54af0122ce7be0754305b7b27f4e2fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the pool.  <a href="classpmem_1_1obj_1_1pool__base.html#a54af0122ce7be0754305b7b27f4e2fc6">More...</a><br /></td></tr>
<tr class="separator:a54af0122ce7be0754305b7b27f4e2fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689c84a97250a514c1fee892c38dfefe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a689c84a97250a514c1fee892c38dfefe">persist</a> (const void *addr, size_t len) noexcept</td></tr>
<tr class="memdesc:a689c84a97250a514c1fee892c38dfefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs persist operation on a given chunk of memory.  <a href="classpmem_1_1obj_1_1pool__base.html#a689c84a97250a514c1fee892c38dfefe">More...</a><br /></td></tr>
<tr class="separator:a689c84a97250a514c1fee892c38dfefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62614e17c84a28ec0fce3e1a65c90dea"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a62614e17c84a28ec0fce3e1a65c90dea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a62614e17c84a28ec0fce3e1a65c90dea">persist</a> (const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;prop) noexcept</td></tr>
<tr class="memdesc:a62614e17c84a28ec0fce3e1a65c90dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs persist operation on a given pmem property.  <a href="classpmem_1_1obj_1_1pool__base.html#a62614e17c84a28ec0fce3e1a65c90dea">More...</a><br /></td></tr>
<tr class="separator:a62614e17c84a28ec0fce3e1a65c90dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439567476fb60bdd5b0687f3587f9415"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a439567476fb60bdd5b0687f3587f9415"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a439567476fb60bdd5b0687f3587f9415">persist</a> (const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; &amp;ptr) noexcept</td></tr>
<tr class="memdesc:a439567476fb60bdd5b0687f3587f9415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs persist operation on a given persistent pointer.  <a href="classpmem_1_1obj_1_1pool__base.html#a439567476fb60bdd5b0687f3587f9415">More...</a><br /></td></tr>
<tr class="separator:a439567476fb60bdd5b0687f3587f9415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e93abc89e36875a923cbeef1c29575c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a1e93abc89e36875a923cbeef1c29575c">flush</a> (const void *addr, size_t len) noexcept</td></tr>
<tr class="memdesc:a1e93abc89e36875a923cbeef1c29575c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs flush operation on a given chunk of memory.  <a href="classpmem_1_1obj_1_1pool__base.html#a1e93abc89e36875a923cbeef1c29575c">More...</a><br /></td></tr>
<tr class="separator:a1e93abc89e36875a923cbeef1c29575c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3488d41902121546ce2b3b824e54edf5"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a3488d41902121546ce2b3b824e54edf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a3488d41902121546ce2b3b824e54edf5">flush</a> (const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;prop) noexcept</td></tr>
<tr class="memdesc:a3488d41902121546ce2b3b824e54edf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs flush operation on a given pmem property.  <a href="classpmem_1_1obj_1_1pool__base.html#a3488d41902121546ce2b3b824e54edf5">More...</a><br /></td></tr>
<tr class="separator:a3488d41902121546ce2b3b824e54edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a036b1032c163ee1403e477cdd1527b"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a6a036b1032c163ee1403e477cdd1527b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a6a036b1032c163ee1403e477cdd1527b">flush</a> (const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; &amp;ptr) noexcept</td></tr>
<tr class="memdesc:a6a036b1032c163ee1403e477cdd1527b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs flush operation on a given persistent object.  <a href="classpmem_1_1obj_1_1pool__base.html#a6a036b1032c163ee1403e477cdd1527b">More...</a><br /></td></tr>
<tr class="separator:a6a036b1032c163ee1403e477cdd1527b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c005d60a0dddba8d09d351e07c0ddf"><td class="memItemLeft" align="right" valign="top"><a id="ad0c005d60a0dddba8d09d351e07c0ddf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#ad0c005d60a0dddba8d09d351e07c0ddf">drain</a> (void) noexcept</td></tr>
<tr class="memdesc:ad0c005d60a0dddba8d09d351e07c0ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs drain operation. <br /></td></tr>
<tr class="separator:ad0c005d60a0dddba8d09d351e07c0ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3c26d4d537fdc6c963382460e0e9a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#ae0c3c26d4d537fdc6c963382460e0e9a">memcpy_persist</a> (void *dest, const void *src, size_t len) noexcept</td></tr>
<tr class="memdesc:ae0c3c26d4d537fdc6c963382460e0e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs memcpy and persist operation on a given chunk of memory.  <a href="classpmem_1_1obj_1_1pool__base.html#ae0c3c26d4d537fdc6c963382460e0e9a">More...</a><br /></td></tr>
<tr class="separator:ae0c3c26d4d537fdc6c963382460e0e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27e91b9ee180bc52004aabf6c9a6e3e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#ab27e91b9ee180bc52004aabf6c9a6e3e">memset_persist</a> (void *dest, int c, size_t len) noexcept</td></tr>
<tr class="memdesc:ab27e91b9ee180bc52004aabf6c9a6e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs memset and persist operation on a given chunk of memory.  <a href="classpmem_1_1obj_1_1pool__base.html#ab27e91b9ee180bc52004aabf6c9a6e3e">More...</a><br /></td></tr>
<tr class="separator:ab27e91b9ee180bc52004aabf6c9a6e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f6a903bdedaba77186510ae1efbee"><td class="memItemLeft" align="right" valign="top">PMEMobjpool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a1b5f6a903bdedaba77186510ae1efbee">handle</a> () noexcept</td></tr>
<tr class="memdesc:a1b5f6a903bdedaba77186510ae1efbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the C style handle to the pool.  <a href="classpmem_1_1obj_1_1pool__base.html#a1b5f6a903bdedaba77186510ae1efbee">More...</a><br /></td></tr>
<tr class="separator:a1b5f6a903bdedaba77186510ae1efbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d42c6495ae28299938aa78955daf3c"><td class="memItemLeft" align="right" valign="top"><a id="a12d42c6495ae28299938aa78955daf3c"></a>
POBJ_CPP_DEPRECATED PMEMobjpool *&#160;</td><td class="memItemRight" valign="bottom"><b>get_handle</b> () noexcept</td></tr>
<tr class="separator:a12d42c6495ae28299938aa78955daf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f80e80e1f19247d8353a61a514e4a0"><td class="memItemLeft" align="right" valign="top">pobj_defrag_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a33f80e80e1f19247d8353a61a514e4a0">defrag</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a> **ptrv, size_t oidcnt)</td></tr>
<tr class="memdesc:a33f80e80e1f19247d8353a61a514e4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts defragmentation using selected pointers within this pool.  <a href="classpmem_1_1obj_1_1pool__base.html#a33f80e80e1f19247d8353a61a514e4a0">More...</a><br /></td></tr>
<tr class="separator:a33f80e80e1f19247d8353a61a514e4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1dcc1ec8833d4a9215ce3b6d24f51a79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">open</a> (const std::string &amp;path, const std::string &amp;layout)</td></tr>
<tr class="memdesc:a1dcc1ec8833d4a9215ce3b6d24f51a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing object store memory pool.  <a href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">More...</a><br /></td></tr>
<tr class="separator:a1dcc1ec8833d4a9215ce3b6d24f51a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a780cfb3bc6c708856783938a9e8c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">create</a> (const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=<a class="el" href="classpmem_1_1obj_1_1pool__base.html#a78d046f5b91b553db94c01d9e3a09a4e">DEFAULT_MODE</a>)</td></tr>
<tr class="memdesc:a8c7a780cfb3bc6c708856783938a9e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new transactional object store pool.  <a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">More...</a><br /></td></tr>
<tr class="separator:a8c7a780cfb3bc6c708856783938a9e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff95b310c46cf87e957dfc8fafedabc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">check</a> (const std::string &amp;path, const std::string &amp;layout)</td></tr>
<tr class="memdesc:a2ff95b310c46cf87e957dfc8fafedabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given pool is consistent.  <a href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">More...</a><br /></td></tr>
<tr class="separator:a2ff95b310c46cf87e957dfc8fafedabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cc3ae8b8de69613706b26418c2b8ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a11cc3ae8b8de69613706b26418c2b8ee">open</a> (const std::wstring &amp;path, const std::wstring &amp;layout)</td></tr>
<tr class="memdesc:a11cc3ae8b8de69613706b26418c2b8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing object store memory pool.  <a href="classpmem_1_1obj_1_1pool.html#a11cc3ae8b8de69613706b26418c2b8ee">More...</a><br /></td></tr>
<tr class="separator:a11cc3ae8b8de69613706b26418c2b8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc51b425f8e25cc03fdc307187566f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a32bc51b425f8e25cc03fdc307187566f">create</a> (const std::wstring &amp;path, const std::wstring &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=<a class="el" href="classpmem_1_1obj_1_1pool__base.html#a78d046f5b91b553db94c01d9e3a09a4e">DEFAULT_MODE</a>)</td></tr>
<tr class="memdesc:a32bc51b425f8e25cc03fdc307187566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new transactional object store pool.  <a href="classpmem_1_1obj_1_1pool.html#a32bc51b425f8e25cc03fdc307187566f">More...</a><br /></td></tr>
<tr class="separator:a32bc51b425f8e25cc03fdc307187566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb6b9957bcb43a7d55b81a8054da9e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a8ddb6b9957bcb43a7d55b81a8054da9e">check</a> (const std::wstring &amp;path, const std::wstring &amp;layout)</td></tr>
<tr class="memdesc:a8ddb6b9957bcb43a7d55b81a8054da9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given pool is consistent.  <a href="classpmem_1_1obj_1_1pool.html#a8ddb6b9957bcb43a7d55b81a8054da9e">More...</a><br /></td></tr>
<tr class="separator:a8ddb6b9957bcb43a7d55b81a8054da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:acc45ff6df8396f8e336ff42ef7280292"><td class="memItemLeft" align="right" valign="top"><a id="acc45ff6df8396f8e336ff42ef7280292"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>check_pool</b> (pmemobjpool *pop, std::string mode)</td></tr>
<tr class="separator:acc45ff6df8396f8e336ff42ef7280292"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab004e6a97c080fc284d70c8dc334f6ff"><td class="memItemLeft" align="right" valign="top"><a id="ab004e6a97c080fc284d70c8dc334f6ff"></a>
PMEMobjpool *&#160;</td><td class="memItemRight" valign="bottom"><b>pop</b></td></tr>
<tr class="separator:ab004e6a97c080fc284d70c8dc334f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a78d046f5b91b553db94c01d9e3a09a4e"><td class="memItemLeft" align="right" valign="top"><a id="a78d046f5b91b553db94c01d9e3a09a4e"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a78d046f5b91b553db94c01d9e3a09a4e">DEFAULT_MODE</a> = S_IWRITE | S_IREAD</td></tr>
<tr class="memdesc:a78d046f5b91b553db94c01d9e3a09a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default create mode. <br /></td></tr>
<tr class="separator:a78d046f5b91b553db94c01d9e3a09a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::pool&lt; T &gt;</h3>

<p>PMEMobj pool class. </p>
<p>This class is the pmemobj pool handler. It provides basic primitives for operations on pmemobj pools. The template parameter defines the type of the root object within the pool. This pool class inherits also some methods from the base class: <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pmem::obj::pool_base</a>.</p>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="p_8hpp.html">libpmemobj++/p.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">pool_example()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">root</a> {</div>
<div class="line">        p&lt;int&gt; some_array[42];</div>
<div class="line">        p&lt;int&gt; some_other_array[42];</div>
<div class="line">        p&lt;double&gt; some_variable;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* close a pmemobj pool */</span></div>
<div class="line">    pop.close();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* or open a pmemobj pool */</span></div>
<div class="line">    pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pool&lt;root&gt;::open</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* typical usage schemes */</span></div>
<div class="line">    <span class="keyword">auto</span> root_obj = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* low-level memory manipulation */</span></div>
<div class="line">    root_obj-&gt;some_variable = 3.2;</div>
<div class="line">    pop.persist(root_obj-&gt;some_variable);</div>
<div class="line"> </div>
<div class="line">    pop.memset_persist(root_obj-&gt;some_array, 2,</div>
<div class="line">               <span class="keyword">sizeof</span>(root_obj-&gt;some_array));</div>
<div class="line"> </div>
<div class="line">    pop.memcpy_persist(root_obj-&gt;some_other_array, root_obj-&gt;some_array,</div>
<div class="line">               <span class="keyword">sizeof</span>(root_obj-&gt;some_array));</div>
<div class="line"> </div>
<div class="line">    pop.close();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* check pool consistency */</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">pool&lt;root&gt;::check</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a1dcc1ec8833d4a9215ce3b6d24f51a79"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pmem::obj::pool::open</a></div><div class="ttdeci">static pool&lt; T &gt; open(const std::string &amp;path, const std::string &amp;layout)</div><div class="ttdoc">Opens an existing object store memory pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:672</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a2ff95b310c46cf87e957dfc8fafedabc"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">pmem::obj::pool::check</a></div><div class="ttdeci">static int check(const std::string &amp;path, const std::string &amp;layout)</div><div class="ttdoc">Checks if a given pool is consistent.</div><div class="ttdef"><b>Definition:</b> pool.hpp:711</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a85b71b78e8229b009639835a5ad159d2"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">pmem::obj::pool::root</a></div><div class="ttdeci">persistent_ptr&lt; T &gt; root()</div><div class="ttdoc">Retrieves pool's root object.</div><div class="ttdef"><b>Definition:</b> pool.hpp:644</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:694</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="ap_8hpp_html"><div class="ttname"><a href="p_8hpp.html">p.hpp</a></div><div class="ttdoc">Resides on pmem property template.</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
</div><!-- fragment --><p> This API should not be mixed with C API. For example explicitly calling pmemobj_set_user_data(pop) on pool which is handled by C++ pool object is undefined behaviour. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ff95b310c46cf87e957dfc8fafedabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff95b310c46cf87e957dfc8fafedabc">&#9670;&nbsp;</a></span>check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::check </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given pool is consistent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, 1 if file is consistent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a8ddb6b9957bcb43a7d55b81a8054da9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddb6b9957bcb43a7d55b81a8054da9e">&#9670;&nbsp;</a></span>check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::check </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given pool is consistent. </p>
<p>Wide string variant. Available only on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, 1 if file is consistent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a54af0122ce7be0754305b7b27f4e2fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af0122ce7be0754305b7b27f4e2fc6">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the pool. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the pool has already been closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c7a780cfb3bc6c708856783938a9e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a780cfb3bc6c708856783938a9e8c">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>PMEMOBJ_MIN_POOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a78d046f5b91b553db94c01d9e3a09a4e">DEFAULT_MODE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new transactional object store pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file to be created. If exists the pool can be created in-place depending on the size parameter. Existing file must be zeroed. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool, can be a null-terminated string. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the pool in bytes. If zero and the file exists the pool is created in-place. </td></tr>
    <tr><td class="paramname">mode</td><td>File mode for the new file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the created pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during creation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32bc51b425f8e25cc03fdc307187566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bc51b425f8e25cc03fdc307187566f">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>PMEMOBJ_MIN_POOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="classpmem_1_1obj_1_1pool__base.html#a78d046f5b91b553db94c01d9e3a09a4e">DEFAULT_MODE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new transactional object store pool. </p>
<p>Wide string variant. Available only on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file to be created. If exists the pool can be created in-place depending on the size parameter. Existing file must be zeroed. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool, can be a null-terminated string. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the pool in bytes. If zero and the file exists the pool is created in-place. </td></tr>
    <tr><td class="paramname">mode</td><td>File mode for the new file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the created pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during creation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c170c19673a29ace63092d083781330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c170c19673a29ace63092d083781330">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute function at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="af453acceffd968ca68108e3475a7cfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af453acceffd968ca68108e3475a7cfdc">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute function at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a8253223d35089f9736fe37cc1f38ed53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8253223d35089f9736fe37cc1f38ed53">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="ad9909db1249389347b4d81b00a5e3df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9909db1249389347b4d81b00a5e3df6">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a3f19b41b5e921b5edd0cf46cab20369e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f19b41b5e921b5edd0cf46cab20369e">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a3ef9f3fd95a13e5a7361e756471e022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef9f3fd95a13e5a7361e756471e022b">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a33f80e80e1f19247d8353a61a514e4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f80e80e1f19247d8353a61a514e4a0">&#9670;&nbsp;</a></span>defrag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pobj_defrag_result pmem::obj::pool_base::defrag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a> **&#160;</td>
          <td class="paramname"><em>ptrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>oidcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts defragmentation using selected pointers within this pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptrv</td><td>pointer to contiguous space containing <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>'s for defrag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oidcnt</td><td>number of <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>'s passed (in ptrv). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result struct containing a number of relocated and total processed objects.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1defrag__error.html" title="Custom defrag error class.">pmem::defrag_error</a></td><td>when a failure during defragmentation occurs. Even if this error is thrown, some of the objects could have been relocated, see <a class="el" href="classpmem_1_1defrag__error.html#a1a50dcf9b7eec99e293bd3cdc3f876b7" title="Results of the defragmentation run.">defrag_error.result</a> for summary stats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3488d41902121546ce2b3b824e54edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3488d41902121546ce2b3b824e54edf5">&#9670;&nbsp;</a></span>flush() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::flush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs flush operation on a given pmem property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prop</td><td>Resides on pmem property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a036b1032c163ee1403e477cdd1527b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a036b1032c163ee1403e477cdd1527b">&#9670;&nbsp;</a></span>flush() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::flush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs flush operation on a given persistent object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Persistent pointer to object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e93abc89e36875a923cbeef1c29575c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e93abc89e36875a923cbeef1c29575c">&#9670;&nbsp;</a></span>flush() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::flush </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs flush operation on a given chunk of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address of memory chunk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>size of memory chunk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b5f6a903bdedaba77186510ae1efbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5f6a903bdedaba77186510ae1efbee">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PMEMobjpool* pmem::obj::pool_base::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the C style handle to the pool. </p>
<p>Necessary to be able to use the pool with the C API.</p>
<dl class="section return"><dt>Returns</dt><dd>pool opaque handle. </dd></dl>

</div>
</div>
<a id="ae0c3c26d4d537fdc6c963382460e0e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c3c26d4d537fdc6c963382460e0e9a">&#9670;&nbsp;</a></span>memcpy_persist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* pmem::obj::pool_base::memcpy_persist </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs memcpy and persist operation on a given chunk of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>destination memory address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source memory address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>size of memory chunk</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to dest </dd></dl>

</div>
</div>
<a id="ab27e91b9ee180bc52004aabf6c9a6e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27e91b9ee180bc52004aabf6c9a6e3e">&#9670;&nbsp;</a></span>memset_persist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* pmem::obj::pool_base::memset_persist </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs memset and persist operation on a given chunk of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>destination memory address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>constant value to fill the memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>size of memory chunk</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to dest </dd></dl>

</div>
</div>
<a id="a1dcc1ec8833d4a9215ce3b6d24f51a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcc1ec8833d4a9215ce3b6d24f51a79">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing object store memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the opened pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during opening occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11cc3ae8b8de69613706b26418c2b8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cc3ae8b8de69613706b26418c2b8ee">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing object store memory pool. </p>
<p>Wide string variant. Available only on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the opened pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during opening occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62614e17c84a28ec0fce3e1a65c90dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62614e17c84a28ec0fce3e1a65c90dea">&#9670;&nbsp;</a></span>persist() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::persist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs persist operation on a given pmem property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prop</td><td>Resides on pmem property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a439567476fb60bdd5b0687f3587f9415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439567476fb60bdd5b0687f3587f9415">&#9670;&nbsp;</a></span>persist() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::persist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs persist operation on a given persistent pointer. </p>
<p>Persist is not performed on the object referenced by this pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Persistent pointer to object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a689c84a97250a514c1fee892c38dfefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689c84a97250a514c1fee892c38dfefe">&#9670;&nbsp;</a></span>persist() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::pool_base::persist </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs persist operation on a given chunk of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address of memory chunk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>size of memory chunk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85b71b78e8229b009639835a5ad159d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b71b78e8229b009639835a5ad159d2">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves pool's root object. </p>
<dl class="section return"><dt>Returns</dt><dd>persistent pointer to the root object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when pool handle is incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libpmemobj++/<a class="el" href="persistent__ptr_8hpp_source.html">persistent_ptr.hpp</a></li>
<li>libpmemobj++/<a class="el" href="pool_8hpp_source.html">pool.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
