<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::segment_vector&lt; T, Policy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.8</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><b>obj</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1segment__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::segment_vector&lt; T, Policy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Segment table is a data type with a vector-like interface The difference is that it does not do reallocations and iterators are not invalidated when adding new elements.  
 <a href="classpmem_1_1obj_1_1segment__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="segment__vector_8hpp_source.html">libpmemobj++/container/segment_vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aabbf4997c70410b3586d005449887b16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aabbf4997c70410b3586d005449887b16">segment_vector</a> ()</td></tr>
<tr class="memdesc:aabbf4997c70410b3586d005449887b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aabbf4997c70410b3586d005449887b16">More...</a><br /></td></tr>
<tr class="separator:aabbf4997c70410b3586d005449887b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c80efe7a6eea647f60b0255c212b18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a70c80efe7a6eea647f60b0255c212b18">segment_vector</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a70c80efe7a6eea647f60b0255c212b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="#a70c80efe7a6eea647f60b0255c212b18">More...</a><br /></td></tr>
<tr class="separator:a70c80efe7a6eea647f60b0255c212b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217f0fd6e98c4b004d7514b1cae68e34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a217f0fd6e98c4b004d7514b1cae68e34">segment_vector</a> (size_type count)</td></tr>
<tr class="memdesc:a217f0fd6e98c4b004d7514b1cae68e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of T default constructed values.  <a href="#a217f0fd6e98c4b004d7514b1cae68e34">More...</a><br /></td></tr>
<tr class="separator:a217f0fd6e98c4b004d7514b1cae68e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11484a1642a8b1f0becdf8a733f7c581"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a11484a1642a8b1f0becdf8a733f7c581"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a11484a1642a8b1f0becdf8a733f7c581">segment_vector</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a11484a1642a8b1f0becdf8a733f7c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="#a11484a1642a8b1f0becdf8a733f7c581">More...</a><br /></td></tr>
<tr class="separator:a11484a1642a8b1f0becdf8a733f7c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583fdfc8a146bd9f3e013884f3dd41c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aa583fdfc8a146bd9f3e013884f3dd41c">segment_vector</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;other)</td></tr>
<tr class="memdesc:aa583fdfc8a146bd9f3e013884f3dd41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aa583fdfc8a146bd9f3e013884f3dd41c">More...</a><br /></td></tr>
<tr class="separator:aa583fdfc8a146bd9f3e013884f3dd41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e54740654d57285e97f0b9c87ee744"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#af2e54740654d57285e97f0b9c87ee744">segment_vector</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:af2e54740654d57285e97f0b9c87ee744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#af2e54740654d57285e97f0b9c87ee744">More...</a><br /></td></tr>
<tr class="separator:af2e54740654d57285e97f0b9c87ee744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19ac6c9b74d37f757e6dad3a531cfb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#af19ac6c9b74d37f757e6dad3a531cfb1">segment_vector</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:af19ac6c9b74d37f757e6dad3a531cfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="#af19ac6c9b74d37f757e6dad3a531cfb1">More...</a><br /></td></tr>
<tr class="separator:af19ac6c9b74d37f757e6dad3a531cfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2b4c204e181fa09f41a67e8422ab8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a2c2b4c204e181fa09f41a67e8422ab8e">segment_vector</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a2c2b4c204e181fa09f41a67e8422ab8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a2c2b4c204e181fa09f41a67e8422ab8e">More...</a><br /></td></tr>
<tr class="separator:a2c2b4c204e181fa09f41a67e8422ab8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae779bee43ac7c8a43a678b02f42a2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aae779bee43ac7c8a43a678b02f42a2c6">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;other)</td></tr>
<tr class="memdesc:aae779bee43ac7c8a43a678b02f42a2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#aae779bee43ac7c8a43a678b02f42a2c6">More...</a><br /></td></tr>
<tr class="separator:aae779bee43ac7c8a43a678b02f42a2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990e7ddf68aadbc282c560ed7081ec4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a990e7ddf68aadbc282c560ed7081ec4a">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a990e7ddf68aadbc282c560ed7081ec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a990e7ddf68aadbc282c560ed7081ec4a">More...</a><br /></td></tr>
<tr class="separator:a990e7ddf68aadbc282c560ed7081ec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5cd43445320fe45a78871b32af1eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ada5cd43445320fe45a78871b32af1eb3">operator=</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:ada5cd43445320fe45a78871b32af1eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist transactionally.  <a href="#ada5cd43445320fe45a78871b32af1eb3">More...</a><br /></td></tr>
<tr class="separator:ada5cd43445320fe45a78871b32af1eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7facbe6e45962b1cc276eab069075e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ae7facbe6e45962b1cc276eab069075e1">operator=</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ae7facbe6e45962b1cc276eab069075e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ae7facbe6e45962b1cc276eab069075e1">More...</a><br /></td></tr>
<tr class="separator:ae7facbe6e45962b1cc276eab069075e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e227b9f711389978df043c0c58a54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#af0e227b9f711389978df043c0c58a54f">assign</a> (size_type count, const_reference value)</td></tr>
<tr class="memdesc:af0e227b9f711389978df043c0c58a54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value value transactionally.  <a href="#af0e227b9f711389978df043c0c58a54f">More...</a><br /></td></tr>
<tr class="separator:af0e227b9f711389978df043c0c58a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08440744ce64d6792270c34a17a7ebcb"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a08440744ce64d6792270c34a17a7ebcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a08440744ce64d6792270c34a17a7ebcb">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a08440744ce64d6792270c34a17a7ebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last) transactionally.  <a href="#a08440744ce64d6792270c34a17a7ebcb">More...</a><br /></td></tr>
<tr class="separator:a08440744ce64d6792270c34a17a7ebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144a4bfb1c0a114b5445def8f2288418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a144a4bfb1c0a114b5445def8f2288418">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a144a4bfb1c0a114b5445def8f2288418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist transactionally.  <a href="#a144a4bfb1c0a114b5445def8f2288418">More...</a><br /></td></tr>
<tr class="separator:a144a4bfb1c0a114b5445def8f2288418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a26bcdf3f0c961f41aa169441df6b69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8a26bcdf3f0c961f41aa169441df6b69">assign</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;other)</td></tr>
<tr class="memdesc:a8a26bcdf3f0c961f41aa169441df6b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment method.  <a href="#a8a26bcdf3f0c961f41aa169441df6b69">More...</a><br /></td></tr>
<tr class="separator:a8a26bcdf3f0c961f41aa169441df6b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d29c0bf01ab69bc6c0f3d2a28b737e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a1d29c0bf01ab69bc6c0f3d2a28b737e2">assign</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a1d29c0bf01ab69bc6c0f3d2a28b737e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment method.  <a href="#a1d29c0bf01ab69bc6c0f3d2a28b737e2">More...</a><br /></td></tr>
<tr class="separator:a1d29c0bf01ab69bc6c0f3d2a28b737e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a198871133f6e0644bc4fe8a6060aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a47a198871133f6e0644bc4fe8a6060aa">assign</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a47a198871133f6e0644bc4fe8a6060aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment method.  <a href="#a47a198871133f6e0644bc4fe8a6060aa">More...</a><br /></td></tr>
<tr class="separator:a47a198871133f6e0644bc4fe8a6060aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4051413b06ca21934f2ba122dc86516a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a4051413b06ca21934f2ba122dc86516a">~segment_vector</a> ()</td></tr>
<tr class="memdesc:a4051413b06ca21934f2ba122dc86516a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a4051413b06ca21934f2ba122dc86516a">More...</a><br /></td></tr>
<tr class="separator:a4051413b06ca21934f2ba122dc86516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a164d3a95f0d60e4efab8f8d69dd65"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a22a164d3a95f0d60e4efab8f8d69dd65">at</a> (size_type n)</td></tr>
<tr class="memdesc:a22a164d3a95f0d60e4efab8f8d69dd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking and add it to a transaction.  <a href="#a22a164d3a95f0d60e4efab8f8d69dd65">More...</a><br /></td></tr>
<tr class="separator:a22a164d3a95f0d60e4efab8f8d69dd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a14ac12af3fb113ed37a28cb5ba41a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a21a14ac12af3fb113ed37a28cb5ba41a">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a21a14ac12af3fb113ed37a28cb5ba41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a21a14ac12af3fb113ed37a28cb5ba41a">More...</a><br /></td></tr>
<tr class="separator:a21a14ac12af3fb113ed37a28cb5ba41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4092a037385e1a10f2b2fdf6d7dcdc11"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a4092a037385e1a10f2b2fdf6d7dcdc11">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:a4092a037385e1a10f2b2fdf6d7dcdc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a4092a037385e1a10f2b2fdf6d7dcdc11">More...</a><br /></td></tr>
<tr class="separator:a4092a037385e1a10f2b2fdf6d7dcdc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27698ce4f5d3c1b02dc063b57858d828"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a27698ce4f5d3c1b02dc063b57858d828">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a27698ce4f5d3c1b02dc063b57858d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#a27698ce4f5d3c1b02dc063b57858d828">More...</a><br /></td></tr>
<tr class="separator:a27698ce4f5d3c1b02dc063b57858d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7dfbc45745684ccd0ce1915414e420"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a3e7dfbc45745684ccd0ce1915414e420">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:a3e7dfbc45745684ccd0ce1915414e420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#a3e7dfbc45745684ccd0ce1915414e420">More...</a><br /></td></tr>
<tr class="separator:a3e7dfbc45745684ccd0ce1915414e420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a0cd4aaee184668bc6a7a8d0d1297"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a043a0cd4aaee184668bc6a7a8d0d1297">front</a> ()</td></tr>
<tr class="memdesc:a043a0cd4aaee184668bc6a7a8d0d1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element and add this element to a transaction.  <a href="#a043a0cd4aaee184668bc6a7a8d0d1297">More...</a><br /></td></tr>
<tr class="separator:a043a0cd4aaee184668bc6a7a8d0d1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832fec54d78a85bb9e37f5856139a84a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a832fec54d78a85bb9e37f5856139a84a">front</a> () const</td></tr>
<tr class="memdesc:a832fec54d78a85bb9e37f5856139a84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#a832fec54d78a85bb9e37f5856139a84a">More...</a><br /></td></tr>
<tr class="separator:a832fec54d78a85bb9e37f5856139a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a53a30e76899eec783f759048234385"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a2a53a30e76899eec783f759048234385">cfront</a> () const</td></tr>
<tr class="memdesc:a2a53a30e76899eec783f759048234385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#a2a53a30e76899eec783f759048234385">More...</a><br /></td></tr>
<tr class="separator:a2a53a30e76899eec783f759048234385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fde028f85c7f299b9517b710e15df4"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a67fde028f85c7f299b9517b710e15df4">back</a> ()</td></tr>
<tr class="memdesc:a67fde028f85c7f299b9517b710e15df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element and add this element to a transaction.  <a href="#a67fde028f85c7f299b9517b710e15df4">More...</a><br /></td></tr>
<tr class="separator:a67fde028f85c7f299b9517b710e15df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7345a794c689a4d044492c50015edfe5"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a7345a794c689a4d044492c50015edfe5">back</a> () const</td></tr>
<tr class="memdesc:a7345a794c689a4d044492c50015edfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#a7345a794c689a4d044492c50015edfe5">More...</a><br /></td></tr>
<tr class="separator:a7345a794c689a4d044492c50015edfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441e4f590b7c80351f5ec6ce4a7b6e2e"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a441e4f590b7c80351f5ec6ce4a7b6e2e">cback</a> () const</td></tr>
<tr class="memdesc:a441e4f590b7c80351f5ec6ce4a7b6e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#a441e4f590b7c80351f5ec6ce4a7b6e2e">More...</a><br /></td></tr>
<tr class="separator:a441e4f590b7c80351f5ec6ce4a7b6e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc964fecbe98f99e9cb949d5e59053a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a5cc964fecbe98f99e9cb949d5e59053a">begin</a> ()</td></tr>
<tr class="memdesc:a5cc964fecbe98f99e9cb949d5e59053a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#a5cc964fecbe98f99e9cb949d5e59053a">More...</a><br /></td></tr>
<tr class="separator:a5cc964fecbe98f99e9cb949d5e59053a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f479d02fe75af3a55701366f2cccba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a65f479d02fe75af3a55701366f2cccba">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a65f479d02fe75af3a55701366f2cccba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#a65f479d02fe75af3a55701366f2cccba">More...</a><br /></td></tr>
<tr class="separator:a65f479d02fe75af3a55701366f2cccba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb09b8e2f0be380778a99173d859ab5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#afb09b8e2f0be380778a99173d859ab5b">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:afb09b8e2f0be380778a99173d859ab5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#afb09b8e2f0be380778a99173d859ab5b">More...</a><br /></td></tr>
<tr class="separator:afb09b8e2f0be380778a99173d859ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab792d2e3506aeaf34a86326514f097a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9">end</a> ()</td></tr>
<tr class="memdesc:ab792d2e3506aeaf34a86326514f097a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to past the end.  <a href="#ab792d2e3506aeaf34a86326514f097a9">More...</a><br /></td></tr>
<tr class="separator:ab792d2e3506aeaf34a86326514f097a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ad3488c97850fcc84a4f7e07c19033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ae1ad3488c97850fcc84a4f7e07c19033">end</a> () const noexcept</td></tr>
<tr class="memdesc:ae1ad3488c97850fcc84a4f7e07c19033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to past the end.  <a href="#ae1ad3488c97850fcc84a4f7e07c19033">More...</a><br /></td></tr>
<tr class="separator:ae1ad3488c97850fcc84a4f7e07c19033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59833e40dfcf4b317b2d59773206d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ad59833e40dfcf4b317b2d59773206d0e">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ad59833e40dfcf4b317b2d59773206d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end.  <a href="#ad59833e40dfcf4b317b2d59773206d0e">More...</a><br /></td></tr>
<tr class="separator:ad59833e40dfcf4b317b2d59773206d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2470337050593000c1c8bdfb807d98"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a1f2470337050593000c1c8bdfb807d98">rbegin</a> ()</td></tr>
<tr class="memdesc:a1f2470337050593000c1c8bdfb807d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#a1f2470337050593000c1c8bdfb807d98">More...</a><br /></td></tr>
<tr class="separator:a1f2470337050593000c1c8bdfb807d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac00bb1a1eb7356455a07e6e0716324"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#abac00bb1a1eb7356455a07e6e0716324">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:abac00bb1a1eb7356455a07e6e0716324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#abac00bb1a1eb7356455a07e6e0716324">More...</a><br /></td></tr>
<tr class="separator:abac00bb1a1eb7356455a07e6e0716324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e09ee9c8c2f1d3d334e8e9be13e6a7a"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a0e09ee9c8c2f1d3d334e8e9be13e6a7a">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0e09ee9c8c2f1d3d334e8e9be13e6a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a0e09ee9c8c2f1d3d334e8e9be13e6a7a">More...</a><br /></td></tr>
<tr class="separator:a0e09ee9c8c2f1d3d334e8e9be13e6a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0b4e0f74ef7c851b751dc77481dedc"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aab0b4e0f74ef7c851b751dc77481dedc">rend</a> ()</td></tr>
<tr class="memdesc:aab0b4e0f74ef7c851b751dc77481dedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#aab0b4e0f74ef7c851b751dc77481dedc">More...</a><br /></td></tr>
<tr class="separator:aab0b4e0f74ef7c851b751dc77481dedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f0daafb7699adafde4c14c03d25ed2"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#af0f0daafb7699adafde4c14c03d25ed2">rend</a> () const noexcept</td></tr>
<tr class="memdesc:af0f0daafb7699adafde4c14c03d25ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end.  <a href="#af0f0daafb7699adafde4c14c03d25ed2">More...</a><br /></td></tr>
<tr class="separator:af0f0daafb7699adafde4c14c03d25ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d737c6c08e62cde1c1f577f115acbe"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a70d737c6c08e62cde1c1f577f115acbe">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a70d737c6c08e62cde1c1f577f115acbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a70d737c6c08e62cde1c1f577f115acbe">More...</a><br /></td></tr>
<tr class="separator:a70d737c6c08e62cde1c1f577f115acbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83443513d6dc9d327aaddb1d3f2c579a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; <a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a83443513d6dc9d327aaddb1d3f2c579a">range</a> (size_type start, size_type n)</td></tr>
<tr class="memdesc:a83443513d6dc9d327aaddb1d3f2c579a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice and snapshots requested range.  <a href="#a83443513d6dc9d327aaddb1d3f2c579a">More...</a><br /></td></tr>
<tr class="separator:a83443513d6dc9d327aaddb1d3f2c579a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b61269c9cf20d911cb96cd9d2d4994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; <a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aa5b61269c9cf20d911cb96cd9d2d4994">range</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:aa5b61269c9cf20d911cb96cd9d2d4994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="#aa5b61269c9cf20d911cb96cd9d2d4994">More...</a><br /></td></tr>
<tr class="separator:aa5b61269c9cf20d911cb96cd9d2d4994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a54feecd73cbe81d9248ef69a5b83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; <a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ae0a54feecd73cbe81d9248ef69a5b83b">crange</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:ae0a54feecd73cbe81d9248ef69a5b83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="#ae0a54feecd73cbe81d9248ef69a5b83b">More...</a><br /></td></tr>
<tr class="separator:ae0a54feecd73cbe81d9248ef69a5b83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfb91c313b6c7f32e499d248b36228e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a0dfb91c313b6c7f32e499d248b36228e">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a0dfb91c313b6c7f32e499d248b36228e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a0dfb91c313b6c7f32e499d248b36228e">More...</a><br /></td></tr>
<tr class="separator:a0dfb91c313b6c7f32e499d248b36228e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8506fe2d9375b3158806066c99c58a63"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size</a> () const noexcept</td></tr>
<tr class="separator:a8506fe2d9375b3158806066c99c58a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210708c6c989ed613c8f9696b4c0e43c"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size</a> () const noexcept</td></tr>
<tr class="separator:a210708c6c989ed613c8f9696b4c0e43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05513b713163031d760155e6b8d4f642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a05513b713163031d760155e6b8d4f642">reserve</a> (size_type capacity_new)</td></tr>
<tr class="memdesc:a05513b713163031d760155e6b8d4f642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> to capacity_new transactionally.  <a href="#a05513b713163031d760155e6b8d4f642">More...</a><br /></td></tr>
<tr class="separator:a05513b713163031d760155e6b8d4f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136120e5690d247804ecabdaf36ffa8c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity</a> () const noexcept</td></tr>
<tr class="separator:a136120e5690d247804ecabdaf36ffa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad9be236869b89fdc734635e5eced88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#acad9be236869b89fdc734635e5eced88">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:acad9be236869b89fdc734635e5eced88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests transactional removal of unused capacity.  <a href="#acad9be236869b89fdc734635e5eced88">More...</a><br /></td></tr>
<tr class="separator:acad9be236869b89fdc734635e5eced88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fc50106c73f4c7def2de10a4d70b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a33fc50106c73f4c7def2de10a4d70b9e">clear</a> ()</td></tr>
<tr class="memdesc:a33fc50106c73f4c7def2de10a4d70b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> transactionally.  <a href="#a33fc50106c73f4c7def2de10a4d70b9e">More...</a><br /></td></tr>
<tr class="separator:a33fc50106c73f4c7def2de10a4d70b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98574d45630348a10be67222fc3487b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a98574d45630348a10be67222fc3487b2">free_data</a> ()</td></tr>
<tr class="memdesc:a98574d45630348a10be67222fc3487b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> and frees all allocated persistent memory for data transactionally.  <a href="#a98574d45630348a10be67222fc3487b2">More...</a><br /></td></tr>
<tr class="separator:a98574d45630348a10be67222fc3487b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd54d7f0382914d1ced6497811f441cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#acd54d7f0382914d1ced6497811f441cc">insert</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos, const T &amp;value)</td></tr>
<tr class="memdesc:acd54d7f0382914d1ced6497811f441cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before pos in the container transactionally.  <a href="#acd54d7f0382914d1ced6497811f441cc">More...</a><br /></td></tr>
<tr class="separator:acd54d7f0382914d1ced6497811f441cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0950b938bf07c33e637a2de39cece6ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a0950b938bf07c33e637a2de39cece6ad">insert</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a0950b938bf07c33e637a2de39cece6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves value before pos in the container transactionally.  <a href="#a0950b938bf07c33e637a2de39cece6ad">More...</a><br /></td></tr>
<tr class="separator:a0950b938bf07c33e637a2de39cece6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cada52443688d15e7f2b02b3015b7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a4cada52443688d15e7f2b02b3015b7e4">insert</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a4cada52443688d15e7f2b02b3015b7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos in the container transactionally.  <a href="#a4cada52443688d15e7f2b02b3015b7e4">More...</a><br /></td></tr>
<tr class="separator:a4cada52443688d15e7f2b02b3015b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493e0d8d521b7ff9ee954c8cce950aaa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a493e0d8d521b7ff9ee954c8cce950aaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a493e0d8d521b7ff9ee954c8cce950aaa">insert</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a493e0d8d521b7ff9ee954c8cce950aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos in the container transactionally.  <a href="#a493e0d8d521b7ff9ee954c8cce950aaa">More...</a><br /></td></tr>
<tr class="separator:a493e0d8d521b7ff9ee954c8cce950aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc2b1b14705153c13a6ea18b01c8886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a3cc2b1b14705153c13a6ea18b01c8886">insert</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a3cc2b1b14705153c13a6ea18b01c8886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos in the container transactionally.  <a href="#a3cc2b1b14705153c13a6ea18b01c8886">More...</a><br /></td></tr>
<tr class="separator:a3cc2b1b14705153c13a6ea18b01c8886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7784c71a121d5f4abb305043565f10d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa7784c71a121d5f4abb305043565f10d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aa7784c71a121d5f4abb305043565f10d">emplace</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa7784c71a121d5f4abb305043565f10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos.  <a href="#aa7784c71a121d5f4abb305043565f10d">More...</a><br /></td></tr>
<tr class="separator:aa7784c71a121d5f4abb305043565f10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21580dbce530f623ab9e83ebeb84c1f9"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a21580dbce530f623ab9e83ebeb84c1f9"><td class="memTemplItemLeft" align="right" valign="top">reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a21580dbce530f623ab9e83ebeb84c1f9">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a21580dbce530f623ab9e83ebeb84c1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container transactionally.  <a href="#a21580dbce530f623ab9e83ebeb84c1f9">More...</a><br /></td></tr>
<tr class="separator:a21580dbce530f623ab9e83ebeb84c1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e88c97d359484f505634a07bc1e07ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a9e88c97d359484f505634a07bc1e07ca">erase</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a9e88c97d359484f505634a07bc1e07ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <a href="#a9e88c97d359484f505634a07bc1e07ca">More...</a><br /></td></tr>
<tr class="separator:a9e88c97d359484f505634a07bc1e07ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bac8506779a2be6a3a248de1e6dcbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a6bac8506779a2be6a3a248de1e6dcbb1">erase</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> first, <a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a6bac8506779a2be6a3a248de1e6dcbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="#a6bac8506779a2be6a3a248de1e6dcbb1">More...</a><br /></td></tr>
<tr class="separator:a6bac8506779a2be6a3a248de1e6dcbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf5b3ee5ed1a67c33dcbf9b18563936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a7cf5b3ee5ed1a67c33dcbf9b18563936">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a7cf5b3ee5ed1a67c33dcbf9b18563936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container transactionally.  <a href="#a7cf5b3ee5ed1a67c33dcbf9b18563936">More...</a><br /></td></tr>
<tr class="separator:a7cf5b3ee5ed1a67c33dcbf9b18563936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039809c2b5d6f8511360264fe63feaad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a039809c2b5d6f8511360264fe63feaad">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a039809c2b5d6f8511360264fe63feaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container transactionally.  <a href="#a039809c2b5d6f8511360264fe63feaad">More...</a><br /></td></tr>
<tr class="separator:a039809c2b5d6f8511360264fe63feaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e672237c087e7ce916297cc38f11bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ac0e672237c087e7ce916297cc38f11bb">pop_back</a> ()</td></tr>
<tr class="memdesc:ac0e672237c087e7ce916297cc38f11bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container transactionally.  <a href="#ac0e672237c087e7ce916297cc38f11bb">More...</a><br /></td></tr>
<tr class="separator:ac0e672237c087e7ce916297cc38f11bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d813b415ab367b9c3a10cb9af20bb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a5d813b415ab367b9c3a10cb9af20bb76">resize</a> (size_type count)</td></tr>
<tr class="memdesc:a5d813b415ab367b9c3a10cb9af20bb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to count elements transactionally.  <a href="#a5d813b415ab367b9c3a10cb9af20bb76">More...</a><br /></td></tr>
<tr class="separator:a5d813b415ab367b9c3a10cb9af20bb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10be76a66671fee84756bd2902109b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a10be76a66671fee84756bd2902109b3b">resize</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a10be76a66671fee84756bd2902109b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements transactionally.  <a href="#a10be76a66671fee84756bd2902109b3b">More...</a><br /></td></tr>
<tr class="separator:a10be76a66671fee84756bd2902109b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9be5b870f39e608fc236144bedc0c7"><td class="memItemLeft" align="right" valign="top"><a id="a2c9be5b870f39e608fc236144bedc0c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a2c9be5b870f39e608fc236144bedc0c7">swap</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> &amp;other)</td></tr>
<tr class="memdesc:a2c9be5b870f39e608fc236144bedc0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with other transactionally. <br /></td></tr>
<tr class="separator:a2c9be5b870f39e608fc236144bedc0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab3ccc48d78848661aedb65bb816d933f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab3ccc48d78848661aedb65bb816d933f">internal_reserve</a> (size_type new_capacity)</td></tr>
<tr class="memdesc:ab3ccc48d78848661aedb65bb816d933f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper method.  <a href="#ab3ccc48d78848661aedb65bb816d933f">More...</a><br /></td></tr>
<tr class="separator:ab3ccc48d78848661aedb65bb816d933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4478b889ed006fb75c171e65b2d3ed"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acc4478b889ed006fb75c171e65b2d3ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#acc4478b889ed006fb75c171e65b2d3ed">construct</a> (size_type idx, size_type count, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acc4478b889ed006fb75c171e65b2d3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#acc4478b889ed006fb75c171e65b2d3ed">More...</a><br /></td></tr>
<tr class="separator:acc4478b889ed006fb75c171e65b2d3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed74041ed91b7204558df2f2c9ab5c61"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aed74041ed91b7204558df2f2c9ab5c61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aed74041ed91b7204558df2f2c9ab5c61">construct_range</a> (size_type idx, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:aed74041ed91b7204558df2f2c9ab5c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#aed74041ed91b7204558df2f2c9ab5c61">More...</a><br /></td></tr>
<tr class="separator:aed74041ed91b7204558df2f2c9ab5c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f17e687bf29c8d5bc3e80b4a9539b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ae1f17e687bf29c8d5bc3e80b4a9539b6">insert_gap</a> (size_type idx, size_type count)</td></tr>
<tr class="memdesc:ae1f17e687bf29c8d5bc3e80b4a9539b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ae1f17e687bf29c8d5bc3e80b4a9539b6">More...</a><br /></td></tr>
<tr class="separator:ae1f17e687bf29c8d5bc3e80b4a9539b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898b6204adf6183adb76fcea5a4a1975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a898b6204adf6183adb76fcea5a4a1975">shrink</a> (size_type size_new)</td></tr>
<tr class="memdesc:a898b6204adf6183adb76fcea5a4a1975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a898b6204adf6183adb76fcea5a4a1975">More...</a><br /></td></tr>
<tr class="separator:a898b6204adf6183adb76fcea5a4a1975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b432cd900dddc68c230e7bf5414d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ad7b432cd900dddc68c230e7bf5414d84">get_pool</a> () const noexcept</td></tr>
<tr class="memdesc:ad7b432cd900dddc68c230e7bf5414d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ad7b432cd900dddc68c230e7bf5414d84">More...</a><br /></td></tr>
<tr class="separator:ad7b432cd900dddc68c230e7bf5414d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4ab421d6d7cb9d82bcf40713a71a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a32c4ab421d6d7cb9d82bcf40713a71a6">snapshot_data</a> (size_type idx_first, size_type idx_last)</td></tr>
<tr class="memdesc:a32c4ab421d6d7cb9d82bcf40713a71a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a32c4ab421d6d7cb9d82bcf40713a71a6">More...</a><br /></td></tr>
<tr class="separator:a32c4ab421d6d7cb9d82bcf40713a71a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de7ddf21b249f3f4fe4500c52b19e23"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a1de7ddf21b249f3f4fe4500c52b19e23">get</a> (size_type n)</td></tr>
<tr class="memdesc:a1de7ddf21b249f3f4fe4500c52b19e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a1de7ddf21b249f3f4fe4500c52b19e23">More...</a><br /></td></tr>
<tr class="separator:a1de7ddf21b249f3f4fe4500c52b19e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e732fb6039ee7386aac4a29c7031bd"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a23e732fb6039ee7386aac4a29c7031bd">get</a> (size_type n) const</td></tr>
<tr class="memdesc:a23e732fb6039ee7386aac4a29c7031bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a23e732fb6039ee7386aac4a29c7031bd">More...</a><br /></td></tr>
<tr class="separator:a23e732fb6039ee7386aac4a29c7031bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15b3effc92e38a79e1aa2ed5e5f92ab"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aa15b3effc92e38a79e1aa2ed5e5f92ab">cget</a> (size_type n) const</td></tr>
<tr class="memdesc:aa15b3effc92e38a79e1aa2ed5e5f92ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#aa15b3effc92e38a79e1aa2ed5e5f92ab">More...</a><br /></td></tr>
<tr class="separator:aa15b3effc92e38a79e1aa2ed5e5f92ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a9e863fdb57705f274e8acbe04e33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aee3a9e863fdb57705f274e8acbe04e33">segment_capacity_validation</a> () const</td></tr>
<tr class="memdesc:aee3a9e863fdb57705f274e8acbe04e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#aee3a9e863fdb57705f274e8acbe04e33">More...</a><br /></td></tr>
<tr class="separator:aee3a9e863fdb57705f274e8acbe04e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Policy = exponential_size_vector_policy&lt;&gt;&gt;<br />
class pmem::obj::segment_vector&lt; T, Policy &gt;</h3>

<p>Segment table is a data type with a vector-like interface The difference is that it does not do reallocations and iterators are not invalidated when adding new elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>if SegmentType for policy is specified it must contain such functions as: default constructor, destructor, assign, operator[], free_data, emplace_back, clear, resize, reserve, erase, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a>. They must have signature the same as in vector. Also must support iterators.</dd></dl>
<p>Policy template represents Segments storing type and managing methods.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="segment__vector_8hpp.html">libpmemobj++/container/segment_vector.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="p_8hpp.html">libpmemobj++/p.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> N_ELEMENTS = 4096;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> SEGMENT_SIZE = 1024;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>pmem::obj;</div><div class="line"><span class="keyword">using</span> value_t = <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a>;</div><div class="line"><span class="keyword">using</span> segment_t = <a class="code" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector&lt;value_t&gt;</a>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * exponential_size_array_policy&lt;&gt; is equivalent to:</span></div><div class="line"><span class="comment"> * exponential_size_array_policy&lt;pmem::obj::vector&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">using</span> seg_vec_exp_arr =</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector&lt;value_t, exponential_size_array_policy&lt;&gt;</a>&gt;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * exponential_size_vector_policy&lt;&gt; is equivalent to:</span></div><div class="line"><span class="comment"> * exponential_size_vector_policy&lt;pmem::obj::vector&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">using</span> seg_vec_exp_vec =</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector&lt;value_t, exponential_size_vector_policy&lt;&gt;</a>&gt;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * fixed_size_vector_policy&lt;SEGMENT_SIZE&gt; is equivalent to:</span></div><div class="line"><span class="comment"> * fixed_size_vector_policy&lt;SEGMENT_SIZE, pmem::obj::vector&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">using</span> seg_vec_fix_vec =</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector&lt;value_t, fixed_size_vector_policy&lt;SEGMENT_SIZE&gt;</a>&gt;;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>root {</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;segment_t&gt;</a> pptr0;</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;seg_vec_exp_arr&gt;</a> pptr1;</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;seg_vec_exp_vec&gt;</a> pptr2;</div><div class="line">    <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;seg_vec_fix_vec&gt;</a> pptr3;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; file-name&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> path = argv[1];</div><div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pool&lt;root&gt;::open</a>(path, <span class="stringliteral">&quot;segment_vector example&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> r = pop.root();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (r-&gt;pptr0 == <span class="keyword">nullptr</span>) {</div><div class="line">        <a class="code" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">pmem::obj::transaction::run</a>(pop, [&amp;] {</div><div class="line">            r-&gt;pptr0 = make_persistent&lt;segment_t&gt;();</div><div class="line">            r-&gt;pptr1 = make_persistent&lt;seg_vec_exp_arr&gt;();</div><div class="line">            r-&gt;pptr2 = make_persistent&lt;seg_vec_exp_vec&gt;();</div><div class="line">            r-&gt;pptr3 = make_persistent&lt;seg_vec_fix_vec&gt;();</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> &amp;seg_vec_0 = *pop.root()-&gt;pptr0;</div><div class="line">    <span class="keyword">auto</span> &amp;seg_vec_1 = *pop.root()-&gt;pptr1;</div><div class="line">    <span class="keyword">auto</span> &amp;seg_vec_2 = *pop.root()-&gt;pptr2;</div><div class="line">    <span class="keyword">auto</span> &amp;seg_vec_3 = *pop.root()-&gt;pptr3;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N_ELEMENTS; ++i) {</div><div class="line">        seg_vec_0[i] = i;</div><div class="line">    }</div><div class="line"></div><div class="line">    seg_vec_1 = seg_vec_exp_arr(seg_vec_0.cbegin(), seg_vec_0.cend());</div><div class="line">    seg_vec_2 = seg_vec_exp_vec(seg_vec_1.cbegin(), seg_vec_1.cend());</div><div class="line">    seg_vec_3 = seg_vec_fix_vec(seg_vec_2.cbegin(), seg_vec_2.cend());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N_ELEMENTS; ++i) {</div><div class="line">        assert(seg_vec_1[i] = seg_vec_0[i]);</div><div class="line">        assert(seg_vec_2[i] = seg_vec_1[i]);</div><div class="line">        assert(seg_vec_3[i] = seg_vec_2[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    seg_vec_0.clear();</div><div class="line">    seg_vec_1.clear();</div><div class="line">    seg_vec_2.clear();</div><div class="line">    seg_vec_3.clear();</div><div class="line"></div><div class="line">    delete_persistent&lt;segment_t&gt;(r-&gt;pptr0);</div><div class="line">    delete_persistent&lt;seg_vec_exp_arr&gt;(r-&gt;pptr1);</div><div class="line">    delete_persistent&lt;seg_vec_exp_vec&gt;(r-&gt;pptr2);</div><div class="line">    delete_persistent&lt;seg_vec_fix_vec&gt;(r-&gt;pptr3);</div><div class="line"></div><div class="line">    pop.close();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aabbf4997c70410b3586d005449887b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbf4997c70410b3586d005449887b16">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70c80efe7a6eea647f60b0255c212b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c80efe7a6eea647f60b0255c212b18">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a217f0fd6e98c4b004d7514b1cae68e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217f0fd6e98c4b004d7514b1cae68e34">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of T default constructed values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11484a1642a8b1f0becdf8a733f7c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11484a1642a8b1f0becdf8a733f7c581">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>The first and last arguments must satisfy InputIterator requirements. This overload only participates in overload resolution if InputIt satisfies InputIterator, to avoid ambiguity with the overload of count-value constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greate than std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa583fdfc8a146bd9f3e013884f3dd41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa583fdfc8a146bd9f3e013884f3dd41c">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2e54740654d57285e97f0b9c87ee744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e54740654d57285e97f0b9c87ee744">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a0dfb91c313b6c7f32e499d248b36228e" title="Checks whether the container is empty.">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == other.capacity() </dd>
<dd>
other.capacity() == 0 </dd>
<dd>
other.size() == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19ac6c9b74d37f757e6dad3a531cfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19ac6c9b74d37f757e6dad3a531cfb1">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == init.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2b4c204e181fa09f41a67e8422ab8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2b4c204e181fa09f41a67e8422ab8e">&#9670;&nbsp;</a></span>segment_vector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of std::vector&lt;T&gt; other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if wasn't called in transaction. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4051413b06ca21934f2ba122dc86516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4051413b06ca21934f2ba122dc86516a">&#9670;&nbsp;</a></span>~segment_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::~<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that free_data may throw an <a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a> when freeing underlying segments failed. It is recommended to call free_data manually before object destruction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segments failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af0e227b9f711389978df043c0c58a54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e227b9f711389978df043c0c58a54f">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value value transactionally. </p>
<p>Only the iterators and references in [0, std::distance(first, last)) remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than max(<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>, count)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if count &gt; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>
<p>using vector policy user may call assign with zero count and in that case we can't call assign of uninitialized vector</p>

</div>
</div>
<a id="a08440744ce64d6792270c34a17a7ebcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08440744ce64d6792270c34a17a7ebcb">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last) transactionally. </p>
<p>This overload participates in overload resolution only if InputIt satisfies InputIterator. Only the iterators and references in [0, std::distance(first, last)) remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than max(<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>, std::distance(first, last))</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>
<p>using vector policy user may call assign with zero count and in that case we can't call assign of uninitialized vector</p>

</div>
</div>
<a id="a144a4bfb1c0a114b5445def8f2288418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144a4bfb1c0a114b5445def8f2288418">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list ilist transactionally. </p>
<p>Only the iterators and references in [0, std::distance(<a class="el" href="array_8hpp.html#af7b865184397a869c6c3961222774c35" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a8c9a19e08dff0b1cba582993afd16b83" title="Non-member end.">ilist.end()</a>)) remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == std::distance(<a class="el" href="array_8hpp.html#af7b865184397a869c6c3961222774c35" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a8c9a19e08dff0b1cba582993afd16b83" title="Non-member end.">ilist.end()</a>) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than max(<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>, std::distance(<a class="el" href="array_8hpp.html#af7b865184397a869c6c3961222774c35" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a8c9a19e08dff0b1cba582993afd16b83" title="Non-member end.">ilist.end()</a>))</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a26bcdf3f0c961f41aa169441df6b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a26bcdf3f0c961f41aa169441df6b69">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment method. </p>
<p>Replaces the contents with a copy of the contents of other transactionally.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == max(other.size(), <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d29c0bf01ab69bc6c0f3d2a28b737e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d29c0bf01ab69bc6c0f3d2a28b737e2">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment method. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container) transactionally. Other is in a valid but empty state afterwards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47a198871133f6e0644bc4fe8a6060aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a198871133f6e0644bc4fe8a6060aa">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment method. </p>
<p>Replaces the contents with a copy of the contents of std::vector&lt;T&gt; other transactionally.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == max(other.size(), <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22a164d3a95f0d60e4efab8f8d69dd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a164d3a95f0d60e4efab8f8d69dd65">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking and add it to a transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying segments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21a14ac12af3fb113ed37a28cb5ba41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a14ac12af3fb113ed37a28cb5ba41a">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying segments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67fde028f85c7f299b9517b710e15df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fde028f85c7f299b9517b710e15df4">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element in underlying segments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7345a794c689a4d044492c50015edfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7345a794c689a4d044492c50015edfe5">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying segments. </dd></dl>

</div>
</div>
<a id="a5cc964fecbe98f99e9cb949d5e59053a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc964fecbe98f99e9cb949d5e59053a">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a65f479d02fe75af3a55701366f2cccba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f479d02fe75af3a55701366f2cccba">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a136120e5690d247804ecabdaf36ffa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136120e5690d247804ecabdaf36ffa8c">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements that can be held in currently allocated storage. </dd></dl>

</div>
</div>
<a id="a441e4f590b7c80351f5ec6ce4a7b6e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441e4f590b7c80351f5ec6ce4a7b6e2e">&#9670;&nbsp;</a></span>cback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::cback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a67fde028f85c7f299b9517b710e15df4" title="Access the last element and add this element to a transaction.">back()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a441e4f590b7c80351f5ec6ce4a7b6e2e" title="Access the last element.">cback()</a> will return const_reference not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying segments. </dd></dl>

</div>
</div>
<a id="afb09b8e2f0be380778a99173d859ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb09b8e2f0be380778a99173d859ab5b">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a5cc964fecbe98f99e9cb949d5e59053a" title="Returns an iterator to the beginning.">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#afb09b8e2f0be380778a99173d859ab5b" title="Returns const iterator to the beginning.">cbegin()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="ad59833e40dfcf4b317b2d59773206d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59833e40dfcf4b317b2d59773206d0e">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ad59833e40dfcf4b317b2d59773206d0e" title="Returns a const iterator to the end.">cend()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a2a53a30e76899eec783f759048234385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a53a30e76899eec783f759048234385">&#9670;&nbsp;</a></span>cfront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::cfront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a043a0cd4aaee184668bc6a7a8d0d1297" title="Access the first element and add this element to a transaction.">front()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a2a53a30e76899eec783f759048234385" title="Access the first element.">cfront()</a> will return const_reference not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying segments. </dd></dl>

</div>
</div>
<a id="aa15b3effc92e38a79e1aa2ed5e5f92ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15b3effc92e38a79e1aa2ed5e5f92ab">&#9670;&nbsp;</a></span>cget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::cget </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Not considering if element exist or not.</p>
<dl class="section return"><dt>Returns</dt><dd>const reference to element with given index. </dd></dl>

</div>
</div>
<a id="a33fc50106c73f4c7def2de10a4d70b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fc50106c73f4c7def2de10a4d70b9e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4092a037385e1a10f2b2fdf6d7dcdc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4092a037385e1a10f2b2fdf6d7dcdc11">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a22a164d3a95f0d60e4efab8f8d69dd65" title="Access element at specific index with bounds checking and add it to a transaction.">at()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a4092a037385e1a10f2b2fdf6d7dcdc11" title="Access element at specific index with bounds checking.">const_at()</a> will return const_reference not depending on the const-qualification of the object it is called on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying segments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc4478b889ed006fb75c171e65b2d3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4478b889ed006fb75c171e65b2d3ed">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is free space for additional elements. Constructs elements at given index in underlying segments based on given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>underlying segments index where new elements will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>variadic template arguments for value_type constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> + count) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> &gt;= <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + count </dd>
<dd>
args is valid argument for value_type constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying segment in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed74041ed91b7204558df2f2c9ab5c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed74041ed91b7204558df2f2c9ab5c61">&#9670;&nbsp;</a></span>construct_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::construct_range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is free space for additional elements and input arguments satisfy InputIterator requirements. Copies elements at index idx in underlying segments with the contents of the range [first, last). This overload participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>underlying array index where new elements will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> &gt;= <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + std::distance(first, last) </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
InputIt::reference is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying segment in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0a54feecd73cbe81d9248ef69a5b83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a54feecd73cbe81d9248ef69a5b83b">&#9670;&nbsp;</a></span>crange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; typename <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> &gt; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::crange </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e09ee9c8c2f1d3d334e8e9be13e6a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e09ee9c8c2f1d3d334e8e9be13e6a7a">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a1f2470337050593000c1c8bdfb807d98" title="Returns a reverse iterator to the beginning.">rbegin()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a0e09ee9c8c2f1d3d334e8e9be13e6a7a" title="Returns a const reverse iterator to the beginning.">crbegin()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a70d737c6c08e62cde1c1f577f115acbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d737c6c08e62cde1c1f577f115acbe">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#aab0b4e0f74ef7c851b751dc77481dedc" title="Returns a reverse iterator to the end.">rend()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a70d737c6c08e62cde1c1f577f115acbe" title="Returns a const reverse iterator to the beginning.">crend()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="aa7784c71a121d5f4abb305043565f10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7784c71a121d5f4abb305043565f10d">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. </p>
<p>The element is constructed in-place. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... Note that standard allows args to be a self reference and internal emplace implementation handles this case by creating temporary element_type object. This object is being stored either on stack or on pmem, see <a class="el" href="structpmem_1_1detail_1_1temp__value.html" title="Template class for caching objects based on constructor&#39;s variadic template arguments and LIBPMEMOBJ_...">pmem::detail::temp_value</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the new element will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable, MoveInsertable and EmplaceConstructible.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21580dbce530f623ab9e83ebeb84c1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21580dbce530f623ab9e83ebeb84c1f9">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container transactionally. </p>
<p>The element is constructed in-place. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... Past-the-end iterator is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveInsertable and EmplaceConstructible. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> must be less than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dfb91c313b6c7f32e499d248b36228e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfb91c313b6c7f32e499d248b36228e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="ab792d2e3506aeaf34a86326514f097a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab792d2e3506aeaf34a86326514f097a9">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="ae1ad3488c97850fcc84a4f7e07c19033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ad3488c97850fcc84a4f7e07c19033">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a9e88c97d359484f505634a07bc1e07ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e88c97d359484f505634a07bc1e07ca">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the element to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator pos refers to the last element, the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> = <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> - 1.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bac8506779a2be6a3a248de1e6dcbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bac8506779a2be6a3a248de1e6dcbb1">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>beginning of the range of elements to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of range of elements to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator pos refers to the last element, the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator is returned. If first and last refer to the same element, iterator to this element is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> = <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> - std::distance(first, last).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98574d45630348a10be67222fc3487b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98574d45630348a10be67222fc3487b2">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> and frees all allocated persistent memory for data transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segments failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a043a0cd4aaee184668bc6a7a8d0d1297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043a0cd4aaee184668bc6a7a8d0d1297">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying segments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a832fec54d78a85bb9e37f5856139a84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832fec54d78a85bb9e37f5856139a84a">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to first element in underlying segments. </dd></dl>

</div>
</div>
<a id="a1de7ddf21b249f3f4fe4500c52b19e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de7ddf21b249f3f4fe4500c52b19e23">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Not considering if element exist or not.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to element with given index in <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a23e732fb6039ee7386aac4a29c7031bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e732fb6039ee7386aac4a29c7031bd">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Not considering if element exist or not.</p>
<dl class="section return"><dt>Returns</dt><dd>const reference to element with given index. </dd></dl>

</div>
</div>
<a id="ad7b432cd900dddc68c230e7bf5414d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b432cd900dddc68c230e7bf5414d84">&#9670;&nbsp;</a></span>get_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::get_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<dl class="section pre"><dt>Precondition</dt><dd>underlying segments must reside in persistent memory pool.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pool_base</a> object where <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> resides. </dd></dl>

</div>
</div>
<a id="acd54d7f0382914d1ced6497811f441cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd54d7f0382914d1ced6497811f441cc">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts value before pos in the container transactionally. </p>
<p>Causes allocation if the new <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>. Only the iterators and references before the insertion point remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of CopyAssignable and CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0950b938bf07c33e637a2de39cece6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0950b938bf07c33e637a2de39cece6ad">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves value before pos in the container transactionally. </p>
<p>Causes allocation if the new <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>. Only the iterators and references before the insertion pointremain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable and MoveInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cada52443688d15e7f2b02b3015b7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cada52443688d15e7f2b02b3015b7e4">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos in the container transactionally. </p>
<p>Causes allocation if the new <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>. Only the iterators and references before the insertion point remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of copies to be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if count == 0.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of CopyAssignable and CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + count, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a493e0d8d521b7ff9ee954c8cce950aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493e0d8d521b7ff9ee954c8cce950aaa">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos in the container transactionally. </p>
<p>Causes allocation if the new <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>. Only the iterators and references before the insertion point remain valid. This overload participates in overload resolution only if InputIt qualifies as InputIterator, to avoid ambiguity with the pos-count-value overload. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of elements to insert, can't be iterator into container for which insert is called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of elements to insert, can't be iterator into container for which insert is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted or pos if first == last.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of EmplaceConstructible, Swappable, CopyAssignable, CopyConstructible and CopyInsertable. </dd>
<dd>
InputIt must satisfies requirements of InputIterator.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + std::distance(first, last), or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cc2b1b14705153c13a6ea18b01c8886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc2b1b14705153c13a6ea18b01c8886">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos in the container transactionally. </p>
<p>Causes allocation if the new <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>. Only the iterators and references before the insertion point remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list to insert the values from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if ilist is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of EmplaceConstructible, Swappable, CopyAssignable, CopyConstructible and CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + std::distance(<a class="el" href="array_8hpp.html#af7b865184397a869c6c3961222774c35" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a8c9a19e08dff0b1cba582993afd16b83" title="Non-member end.">ilist.end()</a>), or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f17e687bf29c8d5bc3e80b4a9539b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f17e687bf29c8d5bc3e80b4a9539b6">&#9670;&nbsp;</a></span>insert_gap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::insert_gap </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Inserts a gap for count elements starting at index idx. If there is not enough space available, reallocation occurs.</p>
<p>param[in] idx index number where gap should be made. param[in] count length (expressed in number of elements) of the gap.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if there is not enough space for additional gap, new segment will be allocated and <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> will equal to nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a><ul>
<li>count.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3ccc48d78848661aedb65bb816d933f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ccc48d78848661aedb65bb816d933f">&#9670;&nbsp;</a></span>internal_reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::internal_reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper method. </p>
<p>Increases capacity. Allocs new segments if new_capacity is greater than current capacity.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_capacity</td><td>new desired capacity of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> = nearest power of 2 larger than new_capacity</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">pmem::length_error</td><td>when new_capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a210708c6c989ed613c8f9696b4c0e43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210708c6c989ed613c8f9696b4c0e43c">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold due to PMDK limitations. </dd></dl>

</div>
</div>
<a id="aae779bee43ac7c8a43a678b02f42a2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae779bee43ac7c8a43a678b02f42a2c6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of other transactionally.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than max(other.size(), <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a990e7ddf68aadbc282c560ed7081ec4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990e7ddf68aadbc282c560ed7081ec4a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container) transactionally. Other is in a valid but empty state afterwards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada5cd43445320fe45a78871b32af1eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5cd43445320fe45a78871b32af1eb3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == std::distance(<a class="el" href="array_8hpp.html#af7b865184397a869c6c3961222774c35" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a8c9a19e08dff0b1cba582993afd16b83" title="Non-member end.">ilist.end()</a>) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than max(<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>, std::distance(<a class="el" href="array_8hpp.html#af7b865184397a869c6c3961222774c35" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a8c9a19e08dff0b1cba582993afd16b83" title="Non-member end.">ilist.end()</a>))</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7facbe6e45962b1cc276eab069075e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7facbe6e45962b1cc276eab069075e1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of std::vector&lt;T&gt; other transactionally.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than max(other.size(), <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a>)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27698ce4f5d3c1b02dc063b57858d828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27698ce4f5d3c1b02dc063b57858d828">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying segments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e7dfbc45745684ccd0ce1915414e420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7dfbc45745684ccd0ce1915414e420">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying segments. </dd></dl>

</div>
</div>
<a id="ac0e672237c087e7ce916297cc38f11bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e672237c087e7ce916297cc38f11bb">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element of the container transactionally. </p>
<p>Calling pop_back on an empty container does nothing. No iterators or references except for <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a67fde028f85c7f299b9517b710e15df4" title="Access the last element and add this element to a transaction.">back()</a> and <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a> are invalidated.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == std::max(0, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> - 1)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cf5b3ee5ed1a67c33dcbf9b18563936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf5b3ee5ed1a67c33dcbf9b18563936">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container transactionally. </p>
<p>The new element is initialized as a copy of value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value of the element to be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a039809c2b5d6f8511360264fe63feaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039809c2b5d6f8511360264fe63feaad">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container transactionally. </p>
<p>value is moved into the new element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value of the element to be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> + 1, or remains the same if there is enough space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83443513d6dc9d327aaddb1d3f2c579a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83443513d6dc9d327aaddb1d3f2c579a">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; typename <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">iterator</a> &gt; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns slice and snapshots requested range. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5b61269c9cf20d911cb96cd9d2d4994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b61269c9cf20d911cb96cd9d2d4994">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; typename <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::<a class="el" href="classpmem_1_1obj_1_1segment__vector__internal_1_1segment__iterator.html">const_iterator</a> &gt; <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f2470337050593000c1c8bdfb807d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2470337050593000c1c8bdfb807d98">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the last element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="abac00bb1a1eb7356455a07e6e0716324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac00bb1a1eb7356455a07e6e0716324">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="aab0b4e0f74ef7c851b751dc77481dedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0b4e0f74ef7c851b751dc77481dedc">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the theoretical element preceding the first element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="af0f0daafb7699adafde4c14c03d25ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f0daafb7699adafde4c14c03d25ed2">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a>. </dd></dl>

</div>
</div>
<a id="a05513b713163031d760155e6b8d4f642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05513b713163031d760155e6b8d4f642">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the capacity of the <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="Segment table is a data type with a vector-like interface The difference is that it does not do reall...">segment_vector</a> to capacity_new transactionally. </p>
<p>If segment where should be capacity_new is greater than the current capacity's segment, new segments allocated, otherwise the method does nothing. Past-the-end iterator invalidated if allocation occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>new capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == max(capacity(), capacity_new)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">pmem::length_error</td><td>when capacity_new larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d813b415ab367b9c3a10cb9af20bb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d813b415ab367b9c3a10cb9af20bb76">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the container to count elements transactionally. </p>
<p>If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than std::max(capacity(), count) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10be76a66671fee84756bd2902109b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10be76a66671fee84756bd2902109b3b">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements transactionally. </p>
<p>If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to initialize the new elements with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 greater than std::max(capacity(), count) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
    <tr><td class="paramname">pmem::length_error</td><td>when new capacity larger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a210708c6c989ed613c8f9696b4c0e43c">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__out__of__memory.html" title="Custom out of memory error class.">pmem::transaction_out_of_memory</a></td><td>when not enough memory to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee3a9e863fdb57705f274e8acbe04e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3a9e863fdb57705f274e8acbe04e33">&#9670;&nbsp;</a></span>segment_capacity_validation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::segment_capacity_validation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if each allocated segment match its expected capacity according to static_segment_policy.</p>
<dl class="section return"><dt>Returns</dt><dd>true if capacity of all segments matches to expected capacity, false otherwise. </dd></dl>

</div>
</div>
<a id="a898b6204adf6183adb76fcea5a4a1975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898b6204adf6183adb76fcea5a4a1975">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::shrink </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Destroys elements in underlying array beginning from position size_new.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_new</td><td>new size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a5cc964fecbe98f99e9cb949d5e59053a" title="Returns an iterator to the beginning.">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#ab792d2e3506aeaf34a86326514f097a9" title="Returns an iterator to past the end.">end()</a>) must be snapshotted in current transaction. </dd>
<dd>
size_new &lt;= <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a> == size_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acad9be236869b89fdc734635e5eced88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad9be236869b89fdc734635e5eced88">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests transactional removal of unused capacity. </p>
<p>New capacity will be set to nearest power of 2 greater than current <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a>.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a136120e5690d247804ecabdaf36ffa8c">capacity()</a> == nearest power of 2 bigger than <a class="el" href="classpmem_1_1obj_1_1segment__vector.html#a8506fe2d9375b3158806066c99c58a63">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying segment failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8506fe2d9375b3158806066c99c58a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8506fe2d9375b3158806066c99c58a63">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<a id="a32c4ab421d6d7cb9d82bcf40713a71a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c4ab421d6d7cb9d82bcf40713a71a6">&#9670;&nbsp;</a></span>snapshot_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a>&lt; T, Policy &gt;::snapshot_data </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Takes a “snapshot” of data in range [this[first], this[last])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/container/<a class="el" href="segment__vector_8hpp_source.html">segment_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
