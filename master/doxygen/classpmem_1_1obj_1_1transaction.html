<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::transaction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1transaction.html">transaction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1transaction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::transaction Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ transaction handler class.  
 <a href="classpmem_1_1obj_1_1transaction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transaction_8hpp_source.html">libpmemobj++/transaction.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction_1_1automatic.html">automatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ automatic scope transaction class.  <a href="classpmem_1_1obj_1_1transaction_1_1automatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction_1_1manual.html">manual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ manual scope transaction class.  <a href="classpmem_1_1obj_1_1transaction_1_1manual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78ab1cc9876472a0f0fcf96d6a0d16d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a78ab1cc9876472a0f0fcf96d6a0d16d0">~transaction</a> () noexcept=delete</td></tr>
<tr class="memdesc:a78ab1cc9876472a0f0fcf96d6a0d16d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a78ab1cc9876472a0f0fcf96d6a0d16d0">More...</a><br /></td></tr>
<tr class="separator:a78ab1cc9876472a0f0fcf96d6a0d16d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4ff5a4362ea2a82830c7ca06a4358e05"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a4ff5a4362ea2a82830c7ca06a4358e05">abort</a> (int err)</td></tr>
<tr class="memdesc:a4ff5a4362ea2a82830c7ca06a4358e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually abort the current transaction.  <a href="#a4ff5a4362ea2a82830c7ca06a4358e05">More...</a><br /></td></tr>
<tr class="separator:a4ff5a4362ea2a82830c7ca06a4358e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378c803f81ae0f6756fe9e9ab21ec1c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a378c803f81ae0f6756fe9e9ab21ec1c9">commit</a> ()</td></tr>
<tr class="memdesc:a378c803f81ae0f6756fe9e9ab21ec1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually commit a transaction.  <a href="#a378c803f81ae0f6756fe9e9ab21ec1c9">More...</a><br /></td></tr>
<tr class="separator:a378c803f81ae0f6756fe9e9ab21ec1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee53ebfb68147106f2d69f437f59146c"><td class="memTemplParams" colspan="2">template&lt;typename... Locks&gt; </td></tr>
<tr class="memitem:aee53ebfb68147106f2d69f437f59146c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#aee53ebfb68147106f2d69f437f59146c">exec_tx</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, std::function&lt; void()&gt; tx, Locks &amp;... locks)</td></tr>
<tr class="memdesc:aee53ebfb68147106f2d69f437f59146c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a closure-like transaction and lock <code>locks</code>.  <a href="#aee53ebfb68147106f2d69f437f59146c">More...</a><br /></td></tr>
<tr class="separator:aee53ebfb68147106f2d69f437f59146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="memTemplParams" colspan="2">template&lt;typename L , typename... Locks&gt; </td></tr>
<tr class="memitem:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#aa5a605fedbe2a633f2921c2d0e9ccdde">add_lock</a> (L &amp;lock, Locks &amp;... locks) noexcept</td></tr>
<tr class="memdesc:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively add locks to the active transaction.  <a href="#aa5a605fedbe2a633f2921c2d0e9ccdde">More...</a><br /></td></tr>
<tr class="separator:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b9ef6f5a49231fd2d9ccadc66fa132"><td class="memItemLeft" align="right" valign="top"><a id="af1b9ef6f5a49231fd2d9ccadc66fa132"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#af1b9ef6f5a49231fd2d9ccadc66fa132">add_lock</a> () noexcept</td></tr>
<tr class="memdesc:af1b9ef6f5a49231fd2d9ccadc66fa132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method ending the recursive algorithm. <br /></td></tr>
<tr class="separator:af1b9ef6f5a49231fd2d9ccadc66fa132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ transaction handler class. </p>
<p>This class is the pmemobj transaction handler. Scoped transactions are handled through two internal classes: <a class="el" href="classpmem_1_1obj_1_1transaction_1_1manual.html">manual</a> and <a class="el" href="classpmem_1_1obj_1_1transaction_1_1automatic.html">automatic</a>.</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1transaction_1_1manual.html">manual</a> transactions need to be committed manually, otherwise they will be aborted on object destruction.<br />
</li>
<li><a class="el" href="classpmem_1_1obj_1_1transaction_1_1automatic.html">automatic</a> transactions are only available in C++17. They handle transaction commit/abort automatically.</li>
</ul>
<p>This class also exposes a closure-like transaction API, which is the preferred way of handling transactions.</p>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__mutex_8hpp.html">libpmemobj++/shared_mutex.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">general_tx_example()</div><div class="line">{</div><div class="line">    <span class="comment">// pool root structure</span></div><div class="line">    <span class="keyword">struct </span>root {</div><div class="line">        <a class="code" href="classpmem_1_1obj_1_1mutex.html">mutex</a> pmutex;</div><div class="line">        <a class="code" href="classpmem_1_1obj_1_1shared__mutex.html">shared_mutex</a> shared_pmutex;</div><div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> count;</div><div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;root&gt;</a> another_root;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a pmemobj pool</span></div><div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div><div class="line">    <span class="keyword">auto</span> proot = pop.get_root();</div><div class="line"></div><div class="line">    <span class="comment">// typical usage schemes</span></div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// take locks and start a transaction</span></div><div class="line">        <a class="code" href="classpmem_1_1obj_1_1transaction.html#aee53ebfb68147106f2d69f437f59146c">transaction::exec_tx</a>(pop,</div><div class="line">                     [&amp;]() {</div><div class="line">                         <span class="comment">// atomically allocate objects</span></div><div class="line">                         proot-&gt;another_root =</div><div class="line">                             make_persistent&lt;root&gt;();</div><div class="line"></div><div class="line">                         <span class="comment">// atomically modify objects</span></div><div class="line">                         proot-&gt;count++;</div><div class="line"></div><div class="line">                     },</div><div class="line">                     proot-&gt;pmutex, proot-&gt;shared_pmutex);</div><div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;te) {</div><div class="line">        <span class="comment">// a transaction error occurred, transaction got aborted</span></div><div class="line">        <span class="comment">// reacquire locks if necessary</span></div><div class="line">    } <span class="keywordflow">catch</span> (...) {</div><div class="line">        <span class="comment">// some other exception got propagated from within the tx</span></div><div class="line">        <span class="comment">// reacquire locks if necessary</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a78ab1cc9876472a0f0fcf96d6a0d16d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab1cc9876472a0f0fcf96d6a0d16d0">&#9670;&nbsp;</a></span>~transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::obj::transaction::~transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>End pmemobj transaction. If the transaction has not been committed before object destruction, an abort will be issued. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ff5a4362ea2a82830c7ca06a4358e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff5a4362ea2a82830c7ca06a4358e05">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually abort the current transaction. </p>
<p>If called within an inner transaction, the outer transactions will also be aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>the error to be reported as the reason of the abort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>if the transaction is in an invalid state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class. ">manual_tx_abort</a></td><td>this exception is thrown to signify a transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5a605fedbe2a633f2921c2d0e9ccdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a605fedbe2a633f2921c2d0e9ccdde">&#9670;&nbsp;</a></span>add_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pmem::obj::transaction::add_lock </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively add locks to the active transaction. </p>
<p>The locks are taken in the provided order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>the lock to add. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>the rest of the locks to be added to the active transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number if adding any of the locks failed, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a378c803f81ae0f6756fe9e9ab21ec1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378c803f81ae0f6756fe9e9ab21ec1c9">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually commit a transaction. </p>
<p>It is the sole responsibility of the caller, that after the call to <a class="el" href="classpmem_1_1obj_1_1transaction.html#a378c803f81ae0f6756fe9e9ab21ec1c9" title="Manually commit a transaction. ">transaction::commit()</a> no other operations are done within the transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>on any errors with ending the transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee53ebfb68147106f2d69f437f59146c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee53ebfb68147106f2d69f437f59146c">&#9670;&nbsp;</a></span>exec_tx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::exec_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a closure-like transaction and lock <code>locks</code>. </p>
<p>The locks have to be persistent memory resident locks. An attempt to lock the locks will be made. If any of the specified locks is already locked, the method will block. The locks are held until the end of the transaction. The transaction does not have to be committed manually. Manual aborts will end the transaction with an active exception.</p>
<p>If an exception is thrown within the transaction, it gets aborted and the exception is rethrown. Therefore extra care has to be taken with proper error handling.</p>
<p>The locks are held for the entire duration of the transaction. They are released at the end of the scope, so within the <code>catch</code> block, they are already unlocked. If the cleanup action requires access to data within a critical section, the locks have to be manually acquired once again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool in which the transaction will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx</td><td>an std::function&lt;void ()&gt; which will perform operations within this transaction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>locks to be taken for the duration of the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>on any error pertaining the execution of the transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class. ">manual_tx_abort</a></td><td>on manual transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/<a class="el" href="transaction_8hpp_source.html">transaction.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
