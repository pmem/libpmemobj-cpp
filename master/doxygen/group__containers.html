<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: Containers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git107.g7e59f08f</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__containers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Containers</div>  </div>
</div><!--header-->
<div class="contents">

<p>Custom (but STL-like) containers for persistent memory.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent container with std::array compatible interface.  <a href="structpmem_1_1obj_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__string.html">pmem::obj::basic_string&lt; CharT, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent string container with std::basic_string compatible interface.  <a href="classpmem_1_1obj_1_1basic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory aware implementation of Intel TBB <a href="https://spec.oneapi.io/versions/0.5.0/oneTBB/containers/concurrent_hash_map_cls.html">concurrent_hash_map</a>  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector&lt; T, Policy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent version of segment vector with std::vector compatible interface.  <a href="classpmem_1_1obj_1_1segment__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent container with std::vector compatible interface.  <a href="classpmem_1_1obj_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0d1bf59e796791b4e701e11d5e364cbc"><td class="memItemLeft" align="right" valign="top"><a id="ga0d1bf59e796791b4e701e11d5e364cbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__containers.html#ga0d1bf59e796791b4e701e11d5e364cbc">pmem::obj::string</a> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:ga0d1bf59e796791b4e701e11d5e364cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most typical string usage - the char specialization. <br /></td></tr>
<tr class="separator:ga0d1bf59e796791b4e701e11d5e364cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64a29a801a006e76d058bf9700af95b"><td class="memItemLeft" align="right" valign="top"><a id="gac64a29a801a006e76d058bf9700af95b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__containers.html#gac64a29a801a006e76d058bf9700af95b">pmem::obj::wstring</a> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:gac64a29a801a006e76d058bf9700af95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wide char specialization. <br /></td></tr>
<tr class="separator:gac64a29a801a006e76d058bf9700af95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bfd7d22ec6ca6d8c989a08800da30c9"><td class="memItemLeft" align="right" valign="top"><a id="ga5bfd7d22ec6ca6d8c989a08800da30c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__containers.html#ga5bfd7d22ec6ca6d8c989a08800da30c9">pmem::obj::u16string</a> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:ga5bfd7d22ec6ca6d8c989a08800da30c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The char16 specialization. <br /></td></tr>
<tr class="separator:ga5bfd7d22ec6ca6d8c989a08800da30c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39fee64dd7c580144725686618f899ce"><td class="memItemLeft" align="right" valign="top"><a id="ga39fee64dd7c580144725686618f899ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__containers.html#ga39fee64dd7c580144725686618f899ce">pmem::obj::u32string</a> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:ga39fee64dd7c580144725686618f899ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The char32 specialization. <br /></td></tr>
<tr class="separator:ga39fee64dd7c580144725686618f899ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Custom (but STL-like) containers for persistent memory. </p>
<p>Persistent containers are implemented-from-scratch with optimized on-media layouts and algorithms to fully exploit the potential and features of persistent memory. Besides specific internal implementation details, libpmemobj-cpp persistent memory containers have (where possible) the well-known STL-like interface and they work with STL algorithms. Containers' methods guarantee atomicity, consistency and durability. Note that every single modifier method (any one modifying the state of the container, like resize or push_back) opens transaction internally and guarantees full exception safety (modifications will be either committed or rolled-back if an exception was thrown, or crash happened - for more info see <a class="el" href="group__transactions.html">Transactions</a>). There is no need for using transaction when calling modifier methods whatsoever.</p>
<p>There is a separate Feature describing and listing all experimental containers, see <a class="el" href="group__experimental__containers.html">Experimental Containers</a>.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Rationale for implementing pmem-aware containers</h2>
<p>The C++ standard library containers collection is something that persistent memory programmers may want to use. Containers manage the lifetime of held objects through allocation/creation and deallocation/destruction with the use of allocators. Implementing custom persistent allocator for C++ STL (Standard Template Library) containers has two main downsides:</p>
<p>Implementation details:</p><ul>
<li>STL containers do not use algorithms optimal from persistent memory programming point of view.</li>
<li>Persistent memory containers should have durability and consistency properties, while not every STL method guarantees strong exception safety.</li>
<li>Persistent memory containers should be designed with an awareness of fragmentation limitations.</li>
</ul>
<p>Memory layout:</p><ul>
<li>The STL does not guarantee that the container layout will remain unchanged in new library versions.</li>
</ul>
<p>Due to these obstacles, the libpmemobj-cpp contains the set of custom, implemented-from-scratch containers with optimized on-media layouts and algorithms to fully exploit the potential and features of persistent memory. These methods guarantee atomicity, consistency and durability. Besides specific internal implementation details, libpmemobj-cpp persistent memory containers have the well-known STL-like interface and they work with STL algorithms.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Additional resources</h2>
<ul>
<li><a href="https://pmem.io/2018/11/20/cpp-persistent-containers.html">Blog post on pmem.io about libpmemobj-cpp persistent containers</a></li>
<li><a href="https://pmem.io/2018/11/02/cpp-array.html">A blog post about array container</a></li>
<li><a href="https://pmem.io/2019/02/20/cpp-vector.html">Very first description of (then yet experimental) vector container</a></li>
</ul>
<p>For curious readers - back then in 2017 - there was an approach to re-use and modify the STL containers to be pmem-aware. Story of implementing this experiment can be found in <a href="https://pmem.io/2017/07/10/cpp-containers.html">the blog post on pmem.io</a>. The repo with that code is now dead, but left for the reference and historical perspective. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
