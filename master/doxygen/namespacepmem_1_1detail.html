<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git107.g7e59f08f</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacepmem_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pmem::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation details.  
<a href="namespacepmem_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory aware implementation of the concurrent skip list.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1contiguous__iterator.html">contiguous_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for iterators which satisfies RandomAccessIterator and operate on contiguous memory.  <a href="structpmem_1_1detail_1_1contiguous__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const iterator which adds elements to a transaction in a bulk.  <a href="structpmem_1_1detail_1_1range__snapshotting__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1basic__contiguous__iterator.html">basic_contiguous_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default non-const iterator which adds element to a transaction on every access.  <a href="structpmem_1_1detail_1_1basic__contiguous__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1ebr.html">ebr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epoch-based reclamation (EBR).  <a href="classpmem_1_1detail_1_1ebr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1id__manager.html">id_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for assigning unique thread ids so that those ids will be reused in case of thread exit.  <a href="structpmem_1_1detail_1_1id__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1thread__id__type.html">thread_id_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII-style structure for holding thread id.  <a href="structpmem_1_1detail_1_1thread__id__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1enumerable__thread__specific.html">enumerable_thread_specific</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for storing thread local data.  <a href="classpmem_1_1detail_1_1enumerable__thread__specific.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1is__output__iterator.html">is_output_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given parameter type satisfies requirements of OutputIterator.  <a href="structpmem_1_1detail_1_1is__output__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given parameter type satisfies requirements of InputIterator.  <a href="structpmem_1_1detail_1_1is__input__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given parameter type satisfies requirements of ForwardIterator.  <a href="structpmem_1_1detail_1_1is__forward__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given parameter type satisfies requirements of BidirectionalIterator.  <a href="structpmem_1_1detail_1_1is__bidirectional__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1is__random__access__iterator.html">is_random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given parameter type satisfies requirements of RandomAccessIterator.  <a href="structpmem_1_1detail_1_1is__random__access__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">self_relative_ptr base template class  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__accessor.html">self_relative_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class accessor to self_relative_ptr_base.  <a href="classpmem_1_1detail_1_1self__relative__accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1temp__value.html">temp_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for caching objects based on constructor's variadic template arguments and LIBPMEMOBJ_CPP_MAX_STACK_ALLOC_SIZE.  <a href="structpmem_1_1detail_1_1temp__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1volatile__state.html">volatile_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global key value store which allows persistent objects to use volatile memory.  <a href="classpmem_1_1detail_1_1volatile__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1can__do__snapshot_3_01std_1_1atomic_3_01obj_1_1experimental_1_1self__relative__ptr_3_01T_01_4_01_4_01_4.html">can_do_snapshot&lt; std::atomic&lt; obj::experimental::self_relative_ptr&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpmem_1_1detail_1_1can__do__snapshot.html" title="A structure that checks if it is possible to snapshot the specified memory.">pmem::detail::can_do_snapshot</a> atomic specialization for self_relative_ptr.  <a href="structpmem_1_1detail_1_1can__do__snapshot_3_01std_1_1atomic_3_01obj_1_1experimental_1_1self__relative__ptr_3_01T_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1can__do__snapshot.html">can_do_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that checks if it is possible to snapshot the specified memory.  <a href="structpmem_1_1detail_1_1can__do__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html">transaction_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common functionality for basic_transaction and flat_transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2f2f1c873edde23c37b1bbd29994111d"><td class="memItemLeft" align="right" valign="top"><a id="a2f2f1c873edde23c37b1bbd29994111d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>for_each_ptr_function</b> = void(*)(<a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html">obj::persistent_ptr_base</a> &amp;ptr)</td></tr>
<tr class="separator:a2f2f1c873edde23c37b1bbd29994111d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0390e07307ce49b04365e094a5810dfe"><td class="memTemplParams" colspan="2"><a id="a0390e07307ce49b04365e094a5810dfe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0390e07307ce49b04365e094a5810dfe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>t_has_for_each_ptr</b> = typename std::enable_if&lt; std::is_same&lt; decltype(std::declval&lt; T &gt;().for_each_ptr(std::declval&lt; for_each_ptr_function &gt;())), void &gt;::value &gt;::type</td></tr>
<tr class="separator:a0390e07307ce49b04365e094a5810dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cd5babfc217d520356165facfc7dd1"><td class="memTemplParams" colspan="2"><a id="a94cd5babfc217d520356165facfc7dd1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94cd5babfc217d520356165facfc7dd1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>t_is_defragmentable</b> = supports&lt; T, t_has_for_each_ptr &gt;</td></tr>
<tr class="separator:a94cd5babfc217d520356165facfc7dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdcf1ce1f530ca958b475232b9bf9cf"><td class="memTemplParams" colspan="2"><a id="a1fdcf1ce1f530ca958b475232b9bf9cf"></a>
template&lt;size_t... Indices&gt; </td></tr>
<tr class="memitem:a1fdcf1ce1f530ca958b475232b9bf9cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>index_sequence</b> = integer_sequence&lt; size_t, Indices... &gt;</td></tr>
<tr class="separator:a1fdcf1ce1f530ca958b475232b9bf9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1608b20f7d072378a3815ce1860d9e61"><td class="memTemplParams" colspan="2"><a id="a1608b20f7d072378a3815ce1860d9e61"></a>
template&lt;typename T , T N&gt; </td></tr>
<tr class="memitem:a1608b20f7d072378a3815ce1860d9e61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_integer_sequence</b> = typename make_integer_seq_impl&lt; T, N, void &gt;::type</td></tr>
<tr class="separator:a1608b20f7d072378a3815ce1860d9e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab475c81a7cad4cf1e8bb1920af34082f"><td class="memTemplParams" colspan="2"><a id="ab475c81a7cad4cf1e8bb1920af34082f"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ab475c81a7cad4cf1e8bb1920af34082f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_index_sequence</b> = make_integer_sequence&lt; size_t, N &gt;</td></tr>
<tr class="separator:ab475c81a7cad4cf1e8bb1920af34082f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89687d51793b8f1c5e900a1309fe62c4"><td class="memTemplParams" colspan="2"><a id="a89687d51793b8f1c5e900a1309fe62c4"></a>
template&lt;class... Types&gt; </td></tr>
<tr class="memitem:a89687d51793b8f1c5e900a1309fe62c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>index_sequence_for</b> = make_index_sequence&lt; sizeof...(Types)&gt;</td></tr>
<tr class="separator:a89687d51793b8f1c5e900a1309fe62c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5dae67ab1bfb3aef6d468f13f2716e"><td class="memTemplParams" colspan="2"><a id="a5e5dae67ab1bfb3aef6d468f13f2716e"></a>
template&lt;typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:a5e5dae67ab1bfb3aef6d468f13f2716e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tagged_ptr</b> = tagged_ptr_impl&lt; P1, P2, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">obj::experimental::self_relative_ptr</a>&lt; void &gt; &gt;</td></tr>
<tr class="separator:a5e5dae67ab1bfb3aef6d468f13f2716e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc610038f00a735f46dce934d1ae6c3"><td class="memTemplParams" colspan="2"><a id="abcc610038f00a735f46dce934d1ae6c3"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:abcc610038f00a735f46dce934d1ae6c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>void_t</b> = typename make_void&lt; Ts... &gt;::type</td></tr>
<tr class="separator:abcc610038f00a735f46dce934d1ae6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab451ec2d1ec5b0951bcd0ece5bb64eb"><td class="memTemplParams" colspan="2"><a id="aab451ec2d1ec5b0951bcd0ece5bb64eb"></a>
template&lt;typename T , template&lt; typename &gt; class... Checks&gt; </td></tr>
<tr class="memitem:aab451ec2d1ec5b0951bcd0ece5bb64eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>supports</b> = typename supports_impl&lt; T, void, Checks... &gt;::type</td></tr>
<tr class="separator:aab451ec2d1ec5b0951bcd0ece5bb64eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ddec9babe6eb186ca4a2ae319e35e"><td class="memTemplParams" colspan="2"><a id="a1d9ddec9babe6eb186ca4a2ae319e35e"></a>
template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:a1d9ddec9babe6eb186ca4a2ae319e35e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_transparent</b> = typename Compare::is_transparent</td></tr>
<tr class="separator:a1d9ddec9babe6eb186ca4a2ae319e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d57ac0d1a1583bcc73532c8660aa09"><td class="memTemplParams" colspan="2"><a id="a07d57ac0d1a1583bcc73532c8660aa09"></a>
template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:a07d57ac0d1a1583bcc73532c8660aa09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_is_transparent</b> = detail::supports&lt; Compare, is_transparent &gt;</td></tr>
<tr class="separator:a07d57ac0d1a1583bcc73532c8660aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3add26879b2285df85356714e663dcc6"><td class="memTemplParams" colspan="2"><a id="a3add26879b2285df85356714e663dcc6"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3add26879b2285df85356714e663dcc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtraction</b> = decltype(std::declval&lt; Iterator &gt;() - std::declval&lt; Iterator &gt;())</td></tr>
<tr class="separator:a3add26879b2285df85356714e663dcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802f9ce8c8ee8c34fff5e4d6c5d8f107"><td class="memTemplParams" colspan="2"><a id="a802f9ce8c8ee8c34fff5e4d6c5d8f107"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a802f9ce8c8ee8c34fff5e4d6c5d8f107"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_subtraction</b> = supports&lt; Iterator, subtraction &gt;</td></tr>
<tr class="separator:a802f9ce8c8ee8c34fff5e4d6c5d8f107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b98c964c633463059eef66fe7f05ec"><td class="memTemplParams" colspan="2"><a id="a47b98c964c633463059eef66fe7f05ec"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a47b98c964c633463059eef66fe7f05ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pre_decrement</b> = decltype(std::declval&lt; Iterator &gt;().operator--())</td></tr>
<tr class="separator:a47b98c964c633463059eef66fe7f05ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625b72c89cb56e1441669c56c0c0e922"><td class="memTemplParams" colspan="2"><a id="a625b72c89cb56e1441669c56c0c0e922"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a625b72c89cb56e1441669c56c0c0e922"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_pre_decrement</b> = supports&lt; Iterator, pre_decrement &gt;</td></tr>
<tr class="separator:a625b72c89cb56e1441669c56c0c0e922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe268564067c1f72c13f786cf2dd47a"><td class="memTemplParams" colspan="2"><a id="a7fe268564067c1f72c13f786cf2dd47a"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a7fe268564067c1f72c13f786cf2dd47a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>indexing</b> = decltype(std::declval&lt; Iterator &gt;().operator[](std::declval&lt; typename std::iterator_traits&lt; Iterator &gt;::difference_type &gt;()))</td></tr>
<tr class="separator:a7fe268564067c1f72c13f786cf2dd47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebca57cdca63d0fc537df79305e9987"><td class="memTemplParams" colspan="2"><a id="a2ebca57cdca63d0fc537df79305e9987"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a2ebca57cdca63d0fc537df79305e9987"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_indexing</b> = supports&lt; Iterator, indexing &gt;</td></tr>
<tr class="separator:a2ebca57cdca63d0fc537df79305e9987"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac57f67e46a68017285c8f84a121d829f"><td class="memItemLeft" align="right" valign="top"><a id="ac57f67e46a68017285c8f84a121d829f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>try_insert_node_finish_marker</b> ()</td></tr>
<tr class="separator:ac57f67e46a68017285c8f84a121d829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674b0e227f0a024c8bdad4a371eb08f"><td class="memTemplParams" colspan="2"><a id="a5674b0e227f0a024c8bdad4a371eb08f"></a>
template&lt;typename MyAlloc , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a5674b0e227f0a024c8bdad4a371eb08f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a5674b0e227f0a024c8bdad4a371eb08f">allocator_copy_assignment</a> (MyAlloc &amp;my_allocator, OtherAlloc &amp;other_allocator, std::true_type)</td></tr>
<tr class="memdesc:a5674b0e227f0a024c8bdad4a371eb08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment implementation for allocator if propagate_on_container_copy_assignment == true_type. <br /></td></tr>
<tr class="separator:a5674b0e227f0a024c8bdad4a371eb08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36666892812d39edeae39bb4eb623815"><td class="memTemplParams" colspan="2"><a id="a36666892812d39edeae39bb4eb623815"></a>
template&lt;typename MyAlloc , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a36666892812d39edeae39bb4eb623815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a36666892812d39edeae39bb4eb623815">allocator_copy_assignment</a> (MyAlloc &amp;, OtherAlloc &amp;, std::false_type)</td></tr>
<tr class="memdesc:a36666892812d39edeae39bb4eb623815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment implementation for allocator if propagate_on_container_copy_assignment == false_type. <br /></td></tr>
<tr class="separator:a36666892812d39edeae39bb4eb623815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cae8f441ab5b77014f16ace2a44630"><td class="memTemplParams" colspan="2"><a id="a01cae8f441ab5b77014f16ace2a44630"></a>
template&lt;typename MyAlloc , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a01cae8f441ab5b77014f16ace2a44630"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a01cae8f441ab5b77014f16ace2a44630">allocator_move_assignment</a> (MyAlloc &amp;my_allocator, OtherAlloc &amp;other_allocator, std::true_type)</td></tr>
<tr class="memdesc:a01cae8f441ab5b77014f16ace2a44630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment implementation for allocator if propagate_on_container_move_assignment == true_type. <br /></td></tr>
<tr class="separator:a01cae8f441ab5b77014f16ace2a44630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579e5c5c43cdc52c5c26751ea6584af6"><td class="memTemplParams" colspan="2"><a id="a579e5c5c43cdc52c5c26751ea6584af6"></a>
template&lt;typename MyAlloc , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a579e5c5c43cdc52c5c26751ea6584af6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a579e5c5c43cdc52c5c26751ea6584af6">allocator_move_assignment</a> (MyAlloc &amp;, OtherAlloc &amp;, std::false_type)</td></tr>
<tr class="memdesc:a579e5c5c43cdc52c5c26751ea6584af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment implementation for allocator if propagate_on_container_move_assignment == false_type. <br /></td></tr>
<tr class="separator:a579e5c5c43cdc52c5c26751ea6584af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3e7d7b75cd7984cbaec52582be001c"><td class="memTemplParams" colspan="2"><a id="a6e3e7d7b75cd7984cbaec52582be001c"></a>
template&lt;typename MyAlloc , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:a6e3e7d7b75cd7984cbaec52582be001c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a6e3e7d7b75cd7984cbaec52582be001c">allocator_swap</a> (MyAlloc &amp;my_allocator, OtherAlloc &amp;other_allocator, std::true_type)</td></tr>
<tr class="memdesc:a6e3e7d7b75cd7984cbaec52582be001c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap implementation for allocators if propagate_on_container_swap == true_type. <br /></td></tr>
<tr class="separator:a6e3e7d7b75cd7984cbaec52582be001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc73392bf91b0af1e4ecd4a1a1d5bd27"><td class="memTemplParams" colspan="2"><a id="acc73392bf91b0af1e4ecd4a1a1d5bd27"></a>
template&lt;typename MyAlloc , typename OtherAlloc &gt; </td></tr>
<tr class="memitem:acc73392bf91b0af1e4ecd4a1a1d5bd27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#acc73392bf91b0af1e4ecd4a1a1d5bd27">allocator_swap</a> (MyAlloc &amp;, OtherAlloc &amp;, std::false_type)</td></tr>
<tr class="memdesc:acc73392bf91b0af1e4ecd4a1a1d5bd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap implementation for allocators if propagate_on_container_swap == false_type. <br /></td></tr>
<tr class="separator:acc73392bf91b0af1e4ecd4a1a1d5bd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa363dc009886d8d2461e646bc227f6a"><td class="memTemplParams" colspan="2"><a id="afa363dc009886d8d2461e646bc227f6a"></a>
template&lt;typename T , bool M, bool U&gt; </td></tr>
<tr class="memitem:afa363dc009886d8d2461e646bc227f6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const skip_list_iterator&lt; T, M &gt; &amp;lhs, const skip_list_iterator&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="separator:afa363dc009886d8d2461e646bc227f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac274d400aaa620bd496b2220c6cc37ab"><td class="memTemplParams" colspan="2"><a id="ac274d400aaa620bd496b2220c6cc37ab"></a>
template&lt;typename T , bool M, bool U&gt; </td></tr>
<tr class="memitem:ac274d400aaa620bd496b2220c6cc37ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const skip_list_iterator&lt; T, M &gt; &amp;lhs, const skip_list_iterator&lt; T, U &gt; &amp;rhs)</td></tr>
<tr class="separator:ac274d400aaa620bd496b2220c6cc37ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406353d3388f1a1bc26863edff9a125"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1406353d3388f1a1bc26863edff9a125"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a1406353d3388f1a1bc26863edff9a125">conditional_add_to_tx</a> (const T *that, std::size_t count=1, uint64_t flags=0)</td></tr>
<tr class="memdesc:a1406353d3388f1a1bc26863edff9a125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally add 'count' objects to a transaction.  <a href="namespacepmem_1_1detail.html#a1406353d3388f1a1bc26863edff9a125">More...</a><br /></td></tr>
<tr class="separator:a1406353d3388f1a1bc26863edff9a125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b7d2dc38aaf71eff0f5e811931e1e"><td class="memTemplParams" colspan="2"><a id="aec7b7d2dc38aaf71eff0f5e811931e1e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec7b7d2dc38aaf71eff0f5e811931e1e"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#aec7b7d2dc38aaf71eff0f5e811931e1e">type_num</a> ()</td></tr>
<tr class="memdesc:aec7b7d2dc38aaf71eff0f5e811931e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type number for given type. <br /></td></tr>
<tr class="separator:aec7b7d2dc38aaf71eff0f5e811931e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd30b5517b612c517279a81956b8f0ff"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#abd30b5517b612c517279a81956b8f0ff">next_pow_2</a> (uint64_t v)</td></tr>
<tr class="memdesc:abd30b5517b612c517279a81956b8f0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to the next lowest power of 2.  <a href="namespacepmem_1_1detail.html#abd30b5517b612c517279a81956b8f0ff">More...</a><br /></td></tr>
<tr class="separator:abd30b5517b612c517279a81956b8f0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f72eadc170868ccca681867b2b46f5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a09f72eadc170868ccca681867b2b46f5">next_pow_2</a> (uint32_t v)</td></tr>
<tr class="memdesc:a09f72eadc170868ccca681867b2b46f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to the next lowest power of 2.  <a href="namespacepmem_1_1detail.html#a09f72eadc170868ccca681867b2b46f5">More...</a><br /></td></tr>
<tr class="separator:a09f72eadc170868ccca681867b2b46f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a43cffa6cafdaf1ff832b18c4cf3df"><td class="memItemLeft" align="right" valign="top"><a id="af2a43cffa6cafdaf1ff832b18c4cf3df"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Log2</b> (uint64_t x)</td></tr>
<tr class="separator:af2a43cffa6cafdaf1ff832b18c4cf3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda097d34eb4b33caf2d53b564999a56"><td class="memItemLeft" align="right" valign="top"><a id="afda097d34eb4b33caf2d53b564999a56"></a>
static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#afda097d34eb4b33caf2d53b564999a56">mssb_index64</a> (unsigned long long value)</td></tr>
<tr class="memdesc:afda097d34eb4b33caf2d53b564999a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of most significant set bit. <br /></td></tr>
<tr class="separator:afda097d34eb4b33caf2d53b564999a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a11c701502834e959ad5b106c99d8f"><td class="memItemLeft" align="right" valign="top"><a id="a20a11c701502834e959ad5b106c99d8f"></a>
static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a20a11c701502834e959ad5b106c99d8f">mssb_index</a> (unsigned int value)</td></tr>
<tr class="memdesc:a20a11c701502834e959ad5b106c99d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of most significant set bit. <br /></td></tr>
<tr class="separator:a20a11c701502834e959ad5b106c99d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09ef3ec0a6c5744c9b47a4ad96e3388"><td class="memItemLeft" align="right" valign="top"><a id="ae09ef3ec0a6c5744c9b47a4ad96e3388"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>align_up</b> (size_t size, size_t align)</td></tr>
<tr class="separator:ae09ef3ec0a6c5744c9b47a4ad96e3388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4807cfe8ee501d2010f1cd2a5f28957"><td class="memItemLeft" align="right" valign="top"><a id="ac4807cfe8ee501d2010f1cd2a5f28957"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>align_down</b> (size_t size, size_t align)</td></tr>
<tr class="separator:ac4807cfe8ee501d2010f1cd2a5f28957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01e97a9018816a35f80bd32f50b66a8"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration  = typename Clock::duration&gt; </td></tr>
<tr class="memitem:af01e97a9018816a35f80bd32f50b66a8"><td class="memTemplItemLeft" align="right" valign="top">timespec&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#af01e97a9018816a35f80bd32f50b66a8">timepoint_to_timespec</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timepoint)</td></tr>
<tr class="memdesc:af01e97a9018816a35f80bd32f50b66a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert std::chrono::time_point to posix timespec.  <a href="namespacepmem_1_1detail.html#af01e97a9018816a35f80bd32f50b66a8">More...</a><br /></td></tr>
<tr class="separator:af01e97a9018816a35f80bd32f50b66a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5499c09d153e950ffad3fe52d7804907"><td class="memTemplParams" colspan="2"><a id="a5499c09d153e950ffad3fe52d7804907"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a5499c09d153e950ffad3fe52d7804907"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create</b> (typename if_not_array&lt; T &gt;::type *ptr, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a5499c09d153e950ffad3fe52d7804907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e9bfe04f021ff09930eb4a68037c5d"><td class="memTemplParams" colspan="2"><a id="ad0e9bfe04f021ff09930eb4a68037c5d"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ad0e9bfe04f021ff09930eb4a68037c5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create</b> (typename if_size_array&lt; T &gt;::type *ptr, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad0e9bfe04f021ff09930eb4a68037c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e43084af09f9a11fb3b0d6329be46d6"><td class="memTemplParams" colspan="2"><a id="a2e43084af09f9a11fb3b0d6329be46d6"></a>
template&lt;typename T , size_t... Indices, typename Tuple &gt; </td></tr>
<tr class="memitem:a2e43084af09f9a11fb3b0d6329be46d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_from_tuple</b> (void *ptr, index_sequence&lt; Indices... &gt;, Tuple tuple)</td></tr>
<tr class="separator:a2e43084af09f9a11fb3b0d6329be46d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3251b998ebd93318fb756b78c44d02de"><td class="memTemplParams" colspan="2"><a id="a3251b998ebd93318fb756b78c44d02de"></a>
template&lt;typename T , typename Tuple , typename... Args&gt; </td></tr>
<tr class="memitem:a3251b998ebd93318fb756b78c44d02de"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>c_style_construct</b> (void *ptr, void *arg)</td></tr>
<tr class="separator:a3251b998ebd93318fb756b78c44d02de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021ec8a32d07a6201b48b8ee5d29a1e2"><td class="memTemplParams" colspan="2"><a id="a021ec8a32d07a6201b48b8ee5d29a1e2"></a>
template&lt;typename T , typename  = typename std::enable_if&lt;		  !std::is_trivially_destructible&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a021ec8a32d07a6201b48b8ee5d29a1e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>destroy</b> (typename if_not_array&lt; T &gt;::type &amp;arg)</td></tr>
<tr class="separator:a021ec8a32d07a6201b48b8ee5d29a1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb430f51a167d68645a0fbe34cae817"><td class="memTemplParams" colspan="2"><a id="a8fb430f51a167d68645a0fbe34cae817"></a>
template&lt;typename T , typename dummy  = void, typename  = typename std::enable_if&lt;		  std::is_trivially_destructible&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8fb430f51a167d68645a0fbe34cae817"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>destroy</b> (typename if_not_array&lt; T &gt;::type &amp;)</td></tr>
<tr class="separator:a8fb430f51a167d68645a0fbe34cae817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8801acd1d1699ee7957ffb6d9f04ee"><td class="memTemplParams" colspan="2"><a id="aeb8801acd1d1699ee7957ffb6d9f04ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb8801acd1d1699ee7957ffb6d9f04ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>destroy</b> (typename if_size_array&lt; T &gt;::type &amp;arg)</td></tr>
<tr class="separator:aeb8801acd1d1699ee7957ffb6d9f04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96652c8c88abd2efa87de57c0dbba4b"><td class="memTemplParams" colspan="2"><a id="af96652c8c88abd2efa87de57c0dbba4b"></a>
template&lt;typename T , typename Tuple , typename... Args&gt; </td></tr>
<tr class="memitem:af96652c8c88abd2efa87de57c0dbba4b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>obj_constructor</b> (PMEMobjpool *pop, void *ptr, void *arg)</td></tr>
<tr class="separator:af96652c8c88abd2efa87de57c0dbba4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a57d8b4140997f739c66ac1022b1bc"><td class="memTemplParams" colspan="2"><a id="a62a57d8b4140997f739c66ac1022b1bc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62a57d8b4140997f739c66ac1022b1bc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_constructor</b> (PMEMobjpool *pop, void *ptr, void *arg)</td></tr>
<tr class="separator:a62a57d8b4140997f739c66ac1022b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed60d41853358eb8b6294d6e250217"><td class="memTemplParams" colspan="2"><a id="a16ed60d41853358eb8b6294d6e250217"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a16ed60d41853358eb8b6294d6e250217"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a16ed60d41853358eb8b6294d6e250217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193d90ba3183fbd3492619131aec7b59"><td class="memTemplParams" colspan="2"><a id="a193d90ba3183fbd3492619131aec7b59"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a193d90ba3183fbd3492619131aec7b59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a193d90ba3183fbd3492619131aec7b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af115222ec75b1ac4e459a50a69254f4d"><td class="memTemplParams" colspan="2"><a id="af115222ec75b1ac4e459a50a69254f4d"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af115222ec75b1ac4e459a50a69254f4d"><td class="memTemplItemLeft" align="right" valign="top">persistent_pool_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_persistent_pool_pointer_cast</b> (const persistent_pool_ptr&lt; U &gt; &amp;r)</td></tr>
<tr class="separator:af115222ec75b1ac4e459a50a69254f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f0c138fffd276b8a5da225bbf4048f"><td class="memItemLeft" align="right" valign="top"><a id="ab6f0c138fffd276b8a5da225bbf4048f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#ab6f0c138fffd276b8a5da225bbf4048f">errormsg</a> (void)</td></tr>
<tr class="memdesc:ab6f0c138fffd276b8a5da225bbf4048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return last libpmemobj error message as a std::string. <br /></td></tr>
<tr class="separator:ab6f0c138fffd276b8a5da225bbf4048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19517dbf6b62d06c2279dc05c4b42d19"><td class="memTemplParams" colspan="2">template&lt;typename ExcT , size_t... I, typename Tuple &gt; </td></tr>
<tr class="memitem:a19517dbf6b62d06c2279dc05c4b42d19"><td class="memTemplItemLeft" align="right" valign="top">ExcT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a19517dbf6b62d06c2279dc05c4b42d19">exception_with_errormsg_helper</a> (index_sequence&lt; I... &gt;, Tuple &amp;&amp;args)</td></tr>
<tr class="memdesc:a19517dbf6b62d06c2279dc05c4b42d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for exception_with_errormsg.  <a href="namespacepmem_1_1detail.html#a19517dbf6b62d06c2279dc05c4b42d19">More...</a><br /></td></tr>
<tr class="separator:a19517dbf6b62d06c2279dc05c4b42d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5888feacbab544664437549db7e5018a"><td class="memTemplParams" colspan="2">template&lt;class ExcT , typename... Args&gt; </td></tr>
<tr class="memitem:a5888feacbab544664437549db7e5018a"><td class="memTemplItemLeft" align="right" valign="top">ExcT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1detail.html#a5888feacbab544664437549db7e5018a">exception_with_errormsg</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5888feacbab544664437549db7e5018a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error message decorator for pmemobj-based exceptions.  <a href="namespacepmem_1_1detail.html#a5888feacbab544664437549db7e5018a">More...</a><br /></td></tr>
<tr class="separator:a5888feacbab544664437549db7e5018a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation details. </p>
<p>It contains libpmemobj's implementation details, not needed in public headers. It is located within pmem namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1406353d3388f1a1bc26863edff9a125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1406353d3388f1a1bc26863edff9a125">&#9670;&nbsp;</a></span>conditional_add_to_tx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::detail::conditional_add_to_tx </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally add 'count' objects to a transaction. </p>
<p>Adds count objects starting from <code>that</code> to the transaction if '*that' is within a pmemobj pool and there is an active transaction. Does nothing otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">that</td><td>pointer to the first object being added to the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to be added to the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>is a bitmask of values which are described in libpmemobj manpage (pmemobj_tx_xadd_range method) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5888feacbab544664437549db7e5018a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5888feacbab544664437549db7e5018a">&#9670;&nbsp;</a></span>exception_with_errormsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExcT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExcT pmem::detail::exception_with_errormsg </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic error message decorator for pmemobj-based exceptions. </p>
<p>It accepts arbitrary number of parameters. The last parameter must be an error message. </p>

</div>
</div>
<a id="a19517dbf6b62d06c2279dc05c4b42d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19517dbf6b62d06c2279dc05c4b42d19">&#9670;&nbsp;</a></span>exception_with_errormsg_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExcT , size_t... I, typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExcT pmem::detail::exception_with_errormsg_helper </td>
          <td>(</td>
          <td class="paramtype">index_sequence&lt; I... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for exception_with_errormsg. </p>
<p>Accepts tuple with arguments and index_sequence which correspond to all but last argument. The last element in tuple is assumed to be an error message. Before passing it to ExcT constructor it is merged with <a class="el" href="namespacepmem_1_1detail.html#ab6f0c138fffd276b8a5da225bbf4048f" title="Return last libpmemobj error message as a std::string.">detail::errormsg()</a> </p>

</div>
</div>
<a id="a09f72eadc170868ccca681867b2b46f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f72eadc170868ccca681867b2b46f5">&#9670;&nbsp;</a></span>next_pow_2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pmem::detail::next_pow_2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round up to the next lowest power of 2. </p>
<p>Overload for uint32_t argument. </p>

</div>
</div>
<a id="abd30b5517b612c517279a81956b8f0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd30b5517b612c517279a81956b8f0ff">&#9670;&nbsp;</a></span>next_pow_2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t pmem::detail::next_pow_2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round up to the next lowest power of 2. </p>
<p>Overload for uint64_t argument. </p>

</div>
</div>
<a id="af01e97a9018816a35f80bd32f50b66a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01e97a9018816a35f80bd32f50b66a8">&#9670;&nbsp;</a></span>timepoint_to_timespec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename Duration  = typename Clock::duration&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">timespec pmem::detail::timepoint_to_timespec </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timepoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert std::chrono::time_point to posix timespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timepoint</td><td>point in time to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted timespec structure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1detail.html">detail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
