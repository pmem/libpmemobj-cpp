<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git15.ge8f56210</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacepmem_1_1obj.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main libpmemobj namespace.  
<a href="namespacepmem_1_1obj.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepmem_1_1obj_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></td></tr>
<tr class="memdesc:namespacepmem_1_1obj_1_1experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepmem_1_1obj_1_1segment__vector__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj_1_1segment__vector__internal.html">segment_vector_internal</a></td></tr>
<tr class="memdesc:namespacepmem_1_1obj_1_1segment__vector__internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation of pmem's segment vector. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of flag which can be passed to make_persistent.  <a href="structpmem_1_1obj_1_1allocation__flag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of flag which can be passed to make_persistent_atomic.  <a href="structpmem_1_1obj_1_1allocation__flag__atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits.html">object_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates object specific allocator functionality.  <a href="classpmem_1_1obj_1_1object__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits_3_01void_01_4.html">object_traits&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object traits specialization for the void type.  <a href="classpmem_1_1obj_1_1object__traits_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation policy template for a given type.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy_3_01void_01_4.html">standard_alloc_policy&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void specialization of the standard allocation policy.  <a href="classpmem_1_1obj_1_1standard__alloc__policy_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(EXPERIMENTAL) Encapsulates the information about the persistent memory allocation model using PMDK's libpmemobj.  <a href="classpmem_1_1obj_1_1allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html">condition_variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident condition variable.  <a href="classpmem_1_1obj_1_1condition__variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a> - persistent container with std::array compatible interface.  <a href="structpmem_1_1obj_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pmem::obj::string - persistent container with std::basic_string compatible interface.  <a href="classpmem_1_1obj_1_1basic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory aware implementation of Intel TBB <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map.">concurrent_hash_map</a>.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A persistent version of segment vector implementation.  <a href="classpmem_1_1obj_1_1segment__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1vector.html" title="pmem::obj::vector - persistent container with std::vector compatible interface.">pmem::obj::vector</a> - persistent container with std::vector compatible interface.  <a href="classpmem_1_1obj_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1defrag.html">defrag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defrag class.  <a href="classpmem_1_1obj_1_1defrag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent pointer class.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident mutex implementation.  <a href="classpmem_1_1obj_1_1mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resides on pmem class.  <a href="classpmem_1_1obj_1_1p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMEMobj pool class.  <a href="classpmem_1_1obj_1_1pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr_3_01void_01_4.html">persistent_ptr&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> void specialization.  <a href="classpmem_1_1obj_1_1persistent__ptr_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr_3_01const_01void_01_4.html">persistent_ptr&lt; const void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> const void specialization.  <a href="classpmem_1_1obj_1_1persistent__ptr_3_01const_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent_ptr base (non-template) class.  <a href="classpmem_1_1obj_1_1persistent__ptr__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non-template pool base class.  <a href="classpmem_1_1obj_1_1pool__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1shared__mutex.html">shared_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident <a class="el" href="classpmem_1_1obj_1_1shared__mutex.html" title="Persistent memory resident shared_mutex implementation.">shared_mutex</a> implementation.  <a href="classpmem_1_1obj_1_1shared__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1slice.html" title="pmem::obj::slice - provides interface to access sequence of objects.">pmem::obj::slice</a> - provides interface to access sequence of objects.  <a href="classpmem_1_1obj_1_1slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our partial std::string_view implementation.  <a href="classpmem_1_1obj_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1timed__mutex.html">timed_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident <a class="el" href="classpmem_1_1obj_1_1timed__mutex.html" title="Persistent memory resident timed_mutex implementation.">timed_mutex</a> implementation.  <a href="classpmem_1_1obj_1_1timed__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__transaction.html">basic_transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ transaction handler class.  <a href="classpmem_1_1obj_1_1basic__transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html">flat_transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ flat transaction handler class.  <a href="classpmem_1_1obj_1_1flat__transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </td></tr>
<tr class="memitem:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">exponential_size_array_policy</a> = segment_vector_internal::exponential_size_policy&lt; <a class="el" href="structpmem_1_1obj_1_1array.html">segment_vector_internal::array_64</a>, SegmentType &gt;</td></tr>
<tr class="memdesc:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential size policy with pmemobj array of size 64 as a type of segment vector, so this is a static array of segments and each segment is of SegmentType.  <a href="namespacepmem_1_1obj.html#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">More...</a><br /></td></tr>
<tr class="separator:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859b965166fda256885558839d7bb7ec"><td class="memTemplParams" colspan="2">template&lt;size_t SegmentSize = 1024, template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </td></tr>
<tr class="memitem:a859b965166fda256885558839d7bb7ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a859b965166fda256885558839d7bb7ec">fixed_size_vector_policy</a> = segment_vector_internal::fixed_size_policy&lt; <a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType, SegmentSize &gt;</td></tr>
<tr class="memdesc:a859b965166fda256885558839d7bb7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size policy with pmemobj vector of a given size as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType.  <a href="namespacepmem_1_1obj.html#a859b965166fda256885558839d7bb7ec">More...</a><br /></td></tr>
<tr class="separator:a859b965166fda256885558839d7bb7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e84dce66d8c59cdc9070321b8d0d7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </td></tr>
<tr class="memitem:a526e84dce66d8c59cdc9070321b8d0d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a526e84dce66d8c59cdc9070321b8d0d7">exponential_size_vector_policy</a> = segment_vector_internal::exponential_size_policy&lt; <a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType &gt;</td></tr>
<tr class="memdesc:a526e84dce66d8c59cdc9070321b8d0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential size policy with pmemobj vector as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType.  <a href="namespacepmem_1_1obj.html#a526e84dce66d8c59cdc9070321b8d0d7">More...</a><br /></td></tr>
<tr class="separator:a526e84dce66d8c59cdc9070321b8d0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1bf59e796791b4e701e11d5e364cbc"><td class="memItemLeft" align="right" valign="top"><a id="a0d1bf59e796791b4e701e11d5e364cbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; char &gt;</td></tr>
<tr class="separator:a0d1bf59e796791b4e701e11d5e364cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a29a801a006e76d058bf9700af95b"><td class="memItemLeft" align="right" valign="top"><a id="ac64a29a801a006e76d058bf9700af95b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:ac64a29a801a006e76d058bf9700af95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfd7d22ec6ca6d8c989a08800da30c9"><td class="memItemLeft" align="right" valign="top"><a id="a5bfd7d22ec6ca6d8c989a08800da30c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a5bfd7d22ec6ca6d8c989a08800da30c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fee64dd7c580144725686618f899ce"><td class="memItemLeft" align="right" valign="top"><a id="a39fee64dd7c580144725686618f899ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a39fee64dd7c580144725686618f899ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829ee02504fda8d2ad3b39dffea4f9b"><td class="memItemLeft" align="right" valign="top"><a id="ab829ee02504fda8d2ad3b39dffea4f9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_view</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;</td></tr>
<tr class="separator:ab829ee02504fda8d2ad3b39dffea4f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef8955a4780c37dcc9b0bac159585e4"><td class="memItemLeft" align="right" valign="top"><a id="a0ef8955a4780c37dcc9b0bac159585e4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_view</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a0ef8955a4780c37dcc9b0bac159585e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dc381ab71a5c2f1d990245402e2aad"><td class="memItemLeft" align="right" valign="top"><a id="a97dc381ab71a5c2f1d990245402e2aad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_view</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a97dc381ab71a5c2f1d990245402e2aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad117212d298191fb86a65ecad69ab8"><td class="memItemLeft" align="right" valign="top"><a id="aaad117212d298191fb86a65ecad69ab8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_view</b> = <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:aaad117212d298191fb86a65ecad69ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584f6676f0d014e94253e19f2d18da43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">transaction</a> = <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html">basic_transaction</a></td></tr>
<tr class="memdesc:a584f6676f0d014e94253e19f2d18da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43" title="By default, pmem::obj::transaction is an alias to pmem::obj::basic_transaction.">pmem::obj::transaction</a> is an alias to <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html" title="C++ transaction handler class.">pmem::obj::basic_transaction</a>.  <a href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">More...</a><br /></td></tr>
<tr class="separator:a584f6676f0d014e94253e19f2d18da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0859d54746968bec03dba45dd32f6afd"><td class="memTemplParams" colspan="2"><a id="a0859d54746968bec03dba45dd32f6afd"></a>
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </td></tr>
<tr class="memitem:a0859d54746968bec03dba45dd32f6afd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;a, const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;b)</td></tr>
<tr class="separator:a0859d54746968bec03dba45dd32f6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba601e7c52d817046b6198708a81a13"><td class="memTemplParams" colspan="2"><a id="a1ba601e7c52d817046b6198708a81a13"></a>
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </td></tr>
<tr class="memitem:a1ba601e7c52d817046b6198708a81a13"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;a, const <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;b)</td></tr>
<tr class="separator:a1ba601e7c52d817046b6198708a81a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b9e8860a7bcfd8f8ce34d6e5a11d7"><td class="memTemplParams" colspan="2"><a id="ab70b9e8860a7bcfd8f8ce34d6e5a11d7"></a>
template&lt;typename Key , typename T , typename Hash , typename KeyEqual , typename MutexType , typename ScopedLockType &gt; </td></tr>
<tr class="memitem:ab70b9e8860a7bcfd8f8ce34d6e5a11d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;a, <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a>&lt; Key, T, Hash, KeyEqual, MutexType, ScopedLockType &gt; &amp;b)</td></tr>
<tr class="separator:ab70b9e8860a7bcfd8f8ce34d6e5a11d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="memTemplParams" colspan="2"><a id="a2eaf529f99d9ee39c30b32ea8a82a965"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4500f832c5be4483fb0664c870b7127b"><td class="memTemplParams" colspan="2"><a id="a4500f832c5be4483fb0664c870b7127b"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a4500f832c5be4483fb0664c870b7127b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a4500f832c5be4483fb0664c870b7127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521f60b2723b9d069c4cc5af13bda399"><td class="memTemplParams" colspan="2"><a id="a521f60b2723b9d069c4cc5af13bda399"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a521f60b2723b9d069c4cc5af13bda399"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a521f60b2723b9d069c4cc5af13bda399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175622e13aec283fb56ca7ccedacf9b"><td class="memTemplParams" colspan="2"><a id="a5175622e13aec283fb56ca7ccedacf9b"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a5175622e13aec283fb56ca7ccedacf9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a5175622e13aec283fb56ca7ccedacf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba953ad63f462d920bc79de271f39a9"><td class="memTemplParams" colspan="2"><a id="a1ba953ad63f462d920bc79de271f39a9"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a1ba953ad63f462d920bc79de271f39a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a1ba953ad63f462d920bc79de271f39a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="memTemplParams" colspan="2"><a id="a16b8bf77fa26fc0afcc40b6a3aed7e79"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a840c5a7d0056269dbaef5a43af74"><td class="memTemplParams" colspan="2"><a id="a463a840c5a7d0056269dbaef5a43af74"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a463a840c5a7d0056269dbaef5a43af74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a463a840c5a7d0056269dbaef5a43af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="memTemplParams" colspan="2"><a id="ae5d793d76be641b82a1ffa96bbf4c06c"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="memTemplParams" colspan="2"><a id="adb72e4a3d5ebcdf650ca64a14b89eeec"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="memTemplParams" colspan="2"><a id="a26c3d5b212ac54fbc0d5ad9e9ce5685b"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433769b18c43b2b1ca9fcb25c62b203f"><td class="memTemplParams" colspan="2"><a id="a433769b18c43b2b1ca9fcb25c62b203f"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a433769b18c43b2b1ca9fcb25c62b203f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a433769b18c43b2b1ca9fcb25c62b203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9305236fa00130f6d27bacd5fb93c4ee"><td class="memTemplParams" colspan="2"><a id="a9305236fa00130f6d27bacd5fb93c4ee"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a9305236fa00130f6d27bacd5fb93c4ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a9305236fa00130f6d27bacd5fb93c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eb19512a32487e9294c25219e3c234"><td class="memTemplParams" colspan="2"><a id="ab7eb19512a32487e9294c25219e3c234"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:ab7eb19512a32487e9294c25219e3c234"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ab7eb19512a32487e9294c25219e3c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="memTemplParams" colspan="2"><a id="a2b6f5b69d0d397ba27c0035cafce8bec"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613a93583aec0a95ffb9145fd21fa1c3"><td class="memTemplParams" colspan="2"><a id="a613a93583aec0a95ffb9145fd21fa1c3"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a613a93583aec0a95ffb9145fd21fa1c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a613a93583aec0a95ffb9145fd21fa1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e6aab454db03fee92e3b417ea94bd0"><td class="memTemplParams" colspan="2"><a id="a89e6aab454db03fee92e3b417ea94bd0"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a89e6aab454db03fee92e3b417ea94bd0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a89e6aab454db03fee92e3b417ea94bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f62693161b852a8a897973f0ea67cb"><td class="memTemplParams" colspan="2"><a id="a84f62693161b852a8a897973f0ea67cb"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a84f62693161b852a8a897973f0ea67cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:a84f62693161b852a8a897973f0ea67cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="memTemplParams" colspan="2"><a id="acfe18f4fe61e0fbe10034f84a4b3a691"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed237e8ec30fc8cd3efbf780eb476125"><td class="memTemplParams" colspan="2"><a id="aed237e8ec30fc8cd3efbf780eb476125"></a>
template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:aed237e8ec30fc8cd3efbf780eb476125"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="separator:aed237e8ec30fc8cd3efbf780eb476125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="memTemplParams" colspan="2"><a id="a46a6c5333f2e9859d6f152f1dc8f1832"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7ea0da2be2d117a026e3fa58a3369d"><td class="memTemplParams" colspan="2"><a id="aae7ea0da2be2d117a026e3fa58a3369d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae7ea0da2be2d117a026e3fa58a3369d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aae7ea0da2be2d117a026e3fa58a3369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399b4199506661eccff459a7a878f3d9"><td class="memTemplParams" colspan="2"><a id="a399b4199506661eccff459a7a878f3d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a399b4199506661eccff459a7a878f3d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a399b4199506661eccff459a7a878f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4bbcff4664436e0341275606b24314"><td class="memTemplParams" colspan="2"><a id="aec4bbcff4664436e0341275606b24314"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec4bbcff4664436e0341275606b24314"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aec4bbcff4664436e0341275606b24314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6442bae353bd3aab4417d4db85995b07"><td class="memTemplParams" colspan="2"><a id="a6442bae353bd3aab4417d4db85995b07"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6442bae353bd3aab4417d4db85995b07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a6442bae353bd3aab4417d4db85995b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e824a963007146618891278f455c6df"><td class="memTemplParams" colspan="2"><a id="a2e824a963007146618891278f455c6df"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e824a963007146618891278f455c6df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a2e824a963007146618891278f455c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0311022343df6a9d6630d0025e99c1"><td class="memTemplParams" colspan="2"><a id="a4d0311022343df6a9d6630d0025e99c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d0311022343df6a9d6630d0025e99c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a4d0311022343df6a9d6630d0025e99c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8f8bc8ee773cf3ba486df604a98504"><td class="memTemplParams" colspan="2"><a id="aef8f8bc8ee773cf3ba486df604a98504"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef8f8bc8ee773cf3ba486df604a98504"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aef8f8bc8ee773cf3ba486df604a98504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="memTemplParams" colspan="2"><a id="a1fcbd0d2822d3f235950b044d0da6ac2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="memTemplParams" colspan="2"><a id="a6bc8b97b7a1b71404a4da7907cc0a695"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403e4fdd376acf1404d225856a6109f"><td class="memTemplParams" colspan="2"><a id="a4403e4fdd376acf1404d225856a6109f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4403e4fdd376acf1404d225856a6109f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a4403e4fdd376acf1404d225856a6109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="memTemplParams" colspan="2"><a id="a5bfc1cf4bc0871a89bc16487bd6a8484"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cc30f96742b912f5c70bffcd87fe5a"><td class="memTemplParams" colspan="2"><a id="a29cc30f96742b912f5c70bffcd87fe5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29cc30f96742b912f5c70bffcd87fe5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a29cc30f96742b912f5c70bffcd87fe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa7985535467845be5c2e4605bab72e"><td class="memTemplParams" colspan="2"><a id="a5fa7985535467845be5c2e4605bab72e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fa7985535467845be5c2e4605bab72e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a5fa7985535467845be5c2e4605bab72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659d49015c82ef1dc044e2142224269d"><td class="memTemplParams" colspan="2"><a id="a659d49015c82ef1dc044e2142224269d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a659d49015c82ef1dc044e2142224269d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a659d49015c82ef1dc044e2142224269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="memTemplParams" colspan="2"><a id="a0dcb348e953ea0a5b1ed1a3f5c29d2dd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6137a8d89c6046241b600ab14a63b6de"><td class="memTemplParams" colspan="2"><a id="a6137a8d89c6046241b600ab14a63b6de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6137a8d89c6046241b600ab14a63b6de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a6137a8d89c6046241b600ab14a63b6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ea4849c06b3f401ac3673ded5a3227"><td class="memTemplParams" colspan="2"><a id="ad6ea4849c06b3f401ac3673ded5a3227"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6ea4849c06b3f401ac3673ded5a3227"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ad6ea4849c06b3f401ac3673ded5a3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963062a2970d5133a82fa906f0b7eddd"><td class="memTemplParams" colspan="2"><a id="a963062a2970d5133a82fa906f0b7eddd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a963062a2970d5133a82fa906f0b7eddd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a963062a2970d5133a82fa906f0b7eddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917f08b1869d3b1bb361976d08163de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7917f08b1869d3b1bb361976d08163de"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::enable_if&lt; detail::t_is_defragmentable&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7917f08b1869d3b1bb361976d08163de">is_defragmentable</a> () noexcept</td></tr>
<tr class="memdesc:a7917f08b1869d3b1bb361976d08163de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if provided T type is defragmentable.  <a href="namespacepmem_1_1obj.html#a7917f08b1869d3b1bb361976d08163de">More...</a><br /></td></tr>
<tr class="separator:a7917f08b1869d3b1bb361976d08163de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23adee8f9c8707cfd978e45e130df05b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23adee8f9c8707cfd978e45e130df05b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::enable_if&lt;!detail::t_is_defragmentable&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a23adee8f9c8707cfd978e45e130df05b">is_defragmentable</a> () noexcept</td></tr>
<tr class="memdesc:a23adee8f9c8707cfd978e45e130df05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if provided T type is defragmentable.  <a href="namespacepmem_1_1obj.html#a23adee8f9c8707cfd978e45e130df05b">More...</a><br /></td></tr>
<tr class="separator:a23adee8f9c8707cfd978e45e130df05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749a7a0efb9a9df19880a4501c2ddec7"><td class="memTemplParams" colspan="2"><a id="a749a7a0efb9a9df19880a4501c2ddec7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a749a7a0efb9a9df19880a4501c2ddec7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctl_get_detail</b> (PMEMobjpool *<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, const std::string &amp;name)</td></tr>
<tr class="separator:a749a7a0efb9a9df19880a4501c2ddec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9847440a1a773fbaff99399e9694ad"><td class="memTemplParams" colspan="2"><a id="a2b9847440a1a773fbaff99399e9694ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b9847440a1a773fbaff99399e9694ad"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctl_set_detail</b> (PMEMobjpool *<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, const std::string &amp;name, T arg)</td></tr>
<tr class="separator:a2b9847440a1a773fbaff99399e9694ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cdba45753ed102b5462ec667d65934"><td class="memTemplParams" colspan="2"><a id="af2cdba45753ed102b5462ec667d65934"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2cdba45753ed102b5462ec667d65934"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctl_exec_detail</b> (PMEMobjpool *<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, const std::string &amp;name, T arg)</td></tr>
<tr class="separator:af2cdba45753ed102b5462ec667d65934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d555c2e067fb558906a167d4210ce6c"><td class="memTemplParams" colspan="2"><a id="a7d555c2e067fb558906a167d4210ce6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d555c2e067fb558906a167d4210ce6c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctl_get_detail</b> (PMEMobjpool *<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, const std::wstring &amp;name)</td></tr>
<tr class="separator:a7d555c2e067fb558906a167d4210ce6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb57456eea259b55e94012f35a6a4438"><td class="memTemplParams" colspan="2"><a id="acb57456eea259b55e94012f35a6a4438"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb57456eea259b55e94012f35a6a4438"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctl_set_detail</b> (PMEMobjpool *<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, const std::wstring &amp;name, T arg)</td></tr>
<tr class="separator:acb57456eea259b55e94012f35a6a4438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bed19b4d399b3ceaeed935cbfe2780"><td class="memTemplParams" colspan="2"><a id="ab1bed19b4d399b3ceaeed935cbfe2780"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1bed19b4d399b3ceaeed935cbfe2780"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ctl_exec_detail</b> (PMEMobjpool *<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, const std::wstring &amp;name, T arg)</td></tr>
<tr class="separator:ab1bed19b4d399b3ceaeed935cbfe2780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e090bf5d2b950fba759c7560c16e08e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga9e090bf5d2b950fba759c7560c16e08e"><td class="memTemplItemLeft" align="right" valign="top">detail::pp_if_not_array&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga9e090bf5d2b950fba759c7560c16e08e">make_persistent</a> (<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a> flag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga9e090bf5d2b950fba759c7560c16e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an object of type T.  <a href="group__allocation.html#ga9e090bf5d2b950fba759c7560c16e08e">More...</a><br /></td></tr>
<tr class="separator:ga9e090bf5d2b950fba759c7560c16e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77252820ae5e37021b008009c2ec17ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga77252820ae5e37021b008009c2ec17ed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !detail::is_first_arg_same&lt; <a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a>, Args... &gt;::value, typename detail::pp_if_not_array&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga77252820ae5e37021b008009c2ec17ed">make_persistent</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga77252820ae5e37021b008009c2ec17ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an object of type T.  <a href="group__allocation.html#ga77252820ae5e37021b008009c2ec17ed">More...</a><br /></td></tr>
<tr class="separator:ga77252820ae5e37021b008009c2ec17ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714693f9ebbc9db6cd47ee40e10ccbaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga714693f9ebbc9db6cd47ee40e10ccbaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga714693f9ebbc9db6cd47ee40e10ccbaf">delete_persistent</a> (typename detail::pp_if_not_array&lt; T &gt;::type ptr)</td></tr>
<tr class="memdesc:ga714693f9ebbc9db6cd47ee40e10ccbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally free an object of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="group__allocation.html#ga714693f9ebbc9db6cd47ee40e10ccbaf">More...</a><br /></td></tr>
<tr class="separator:ga714693f9ebbc9db6cd47ee40e10ccbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe3504b5f576c05b190770ae0e4b528"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8fe3504b5f576c05b190770ae0e4b528"><td class="memTemplItemLeft" align="right" valign="top">detail::pp_if_array&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga8fe3504b5f576c05b190770ae0e4b528">make_persistent</a> (std::size_t N, <a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html#ae89f1ed6c125d3bd67fd33c0cff27c76">allocation_flag::none</a>())</td></tr>
<tr class="memdesc:ga8fe3504b5f576c05b190770ae0e4b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an array of objects of type T.  <a href="group__allocation.html#ga8fe3504b5f576c05b190770ae0e4b528">More...</a><br /></td></tr>
<tr class="separator:ga8fe3504b5f576c05b190770ae0e4b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0799ef351bd641499230292365d427a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0799ef351bd641499230292365d427a7"><td class="memTemplItemLeft" align="right" valign="top">detail::pp_if_size_array&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga0799ef351bd641499230292365d427a7">make_persistent</a> (<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html#ae89f1ed6c125d3bd67fd33c0cff27c76">allocation_flag::none</a>())</td></tr>
<tr class="memdesc:ga0799ef351bd641499230292365d427a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an array of objects of type T.  <a href="group__allocation.html#ga0799ef351bd641499230292365d427a7">More...</a><br /></td></tr>
<tr class="separator:ga0799ef351bd641499230292365d427a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4222feb628a4d6f8ac2b3a5dbe42c5e6">delete_persistent</a> (typename detail::pp_if_array&lt; T &gt;::type ptr, std::size_t N)</td></tr>
<tr class="memdesc:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a4222feb628a4d6f8ac2b3a5dbe42c5e6">More...</a><br /></td></tr>
<tr class="separator:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5582033bf768fea635b40b3ba766fbef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5582033bf768fea635b40b3ba766fbef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5582033bf768fea635b40b3ba766fbef">delete_persistent</a> (typename detail::pp_if_size_array&lt; T &gt;::type ptr)</td></tr>
<tr class="memdesc:a5582033bf768fea635b40b3ba766fbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a5582033bf768fea635b40b3ba766fbef">More...</a><br /></td></tr>
<tr class="separator:a5582033bf768fea635b40b3ba766fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b14ac5b07d58902df4c24deb7096d12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b14ac5b07d58902df4c24deb7096d12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7b14ac5b07d58902df4c24deb7096d12">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_array&lt; T &gt;::type &amp;ptr, std::size_t N, <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>())</td></tr>
<tr class="memdesc:a7b14ac5b07d58902df4c24deb7096d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate an array of objects.  <a href="namespacepmem_1_1obj.html#a7b14ac5b07d58902df4c24deb7096d12">More...</a><br /></td></tr>
<tr class="separator:a7b14ac5b07d58902df4c24deb7096d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d456157a9ddd13772036944fab68b01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d456157a9ddd13772036944fab68b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1d456157a9ddd13772036944fab68b01">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_size_array&lt; T &gt;::type &amp;ptr, <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>())</td></tr>
<tr class="memdesc:a1d456157a9ddd13772036944fab68b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate an array of objects.  <a href="namespacepmem_1_1obj.html#a1d456157a9ddd13772036944fab68b01">More...</a><br /></td></tr>
<tr class="separator:a1d456157a9ddd13772036944fab68b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2009e20a7365ba802a5f1acbff2f2336"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2009e20a7365ba802a5f1acbff2f2336"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2009e20a7365ba802a5f1acbff2f2336">delete_persistent_atomic</a> (typename detail::pp_if_array&lt; T &gt;::type &amp;ptr, std::size_t)</td></tr>
<tr class="memdesc:a2009e20a7365ba802a5f1acbff2f2336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deallocate an array of objects.  <a href="namespacepmem_1_1obj.html#a2009e20a7365ba802a5f1acbff2f2336">More...</a><br /></td></tr>
<tr class="separator:a2009e20a7365ba802a5f1acbff2f2336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774f709132747433efe83cf8060186a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a774f709132747433efe83cf8060186a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a774f709132747433efe83cf8060186a3">delete_persistent_atomic</a> (typename detail::pp_if_size_array&lt; T &gt;::type &amp;ptr)</td></tr>
<tr class="memdesc:a774f709132747433efe83cf8060186a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deallocate an array of objects.  <a href="namespacepmem_1_1obj.html#a774f709132747433efe83cf8060186a3">More...</a><br /></td></tr>
<tr class="separator:a774f709132747433efe83cf8060186a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b463d8cf7358dda467d0f63e130d410"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga6b463d8cf7358dda467d0f63e130d410"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga6b463d8cf7358dda467d0f63e130d410">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_not_array&lt; T &gt;::type &amp;ptr, <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a> flag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga6b463d8cf7358dda467d0f63e130d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate and construct an object.  <a href="group__allocation.html#ga6b463d8cf7358dda467d0f63e130d410">More...</a><br /></td></tr>
<tr class="separator:ga6b463d8cf7358dda467d0f63e130d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b6596bf5b91ebcc5fbaeb899d59599"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:gaa2b6596bf5b91ebcc5fbaeb899d59599"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!detail::is_first_arg_same&lt; <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>, Args... &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#gaa2b6596bf5b91ebcc5fbaeb899d59599">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_not_array&lt; T &gt;::type &amp;ptr, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa2b6596bf5b91ebcc5fbaeb899d59599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate and construct an object.  <a href="group__allocation.html#gaa2b6596bf5b91ebcc5fbaeb899d59599">More...</a><br /></td></tr>
<tr class="separator:gaa2b6596bf5b91ebcc5fbaeb899d59599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa55bbcf44c93a0ca9a8965cded6e40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2aa55bbcf44c93a0ca9a8965cded6e40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation.html#ga2aa55bbcf44c93a0ca9a8965cded6e40">delete_persistent_atomic</a> (typename detail::pp_if_not_array&lt; T &gt;::type &amp;ptr) noexcept</td></tr>
<tr class="memdesc:ga2aa55bbcf44c93a0ca9a8965cded6e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deallocate an object.  <a href="group__allocation.html#ga2aa55bbcf44c93a0ca9a8965cded6e40">More...</a><br /></td></tr>
<tr class="separator:ga2aa55bbcf44c93a0ca9a8965cded6e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89f45b433f00601332cc8b026c8094b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa89f45b433f00601332cc8b026c8094b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa89f45b433f00601332cc8b026c8094b">ctl_get</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa89f45b433f00601332cc8b026c8094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#aa89f45b433f00601332cc8b026c8094b">More...</a><br /></td></tr>
<tr class="separator:aa89f45b433f00601332cc8b026c8094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a35c4923f7973d6d9eeefdc6eeb16a4f1">ctl_set</a> (const std::string &amp;name, T arg)</td></tr>
<tr class="memdesc:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#a35c4923f7973d6d9eeefdc6eeb16a4f1">More...</a><br /></td></tr>
<tr class="separator:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5828e2ef9f44c67de727e4498c89f1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5828e2ef9f44c67de727e4498c89f1f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae5828e2ef9f44c67de727e4498c89f1f">ctl_exec</a> (const std::string &amp;name, T arg)</td></tr>
<tr class="memdesc:ae5828e2ef9f44c67de727e4498c89f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at global scope.  <a href="namespacepmem_1_1obj.html#ae5828e2ef9f44c67de727e4498c89f1f">More...</a><br /></td></tr>
<tr class="separator:ae5828e2ef9f44c67de727e4498c89f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64434e59ff1de9be9e73a9eb8d364b45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64434e59ff1de9be9e73a9eb8d364b45"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a64434e59ff1de9be9e73a9eb8d364b45">ctl_get</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a64434e59ff1de9be9e73a9eb8d364b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#a64434e59ff1de9be9e73a9eb8d364b45">More...</a><br /></td></tr>
<tr class="separator:a64434e59ff1de9be9e73a9eb8d364b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3269602e36bbce39e864116f35aa7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb3269602e36bbce39e864116f35aa7e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#adb3269602e36bbce39e864116f35aa7e">ctl_set</a> (const std::wstring &amp;name, T arg)</td></tr>
<tr class="memdesc:adb3269602e36bbce39e864116f35aa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#adb3269602e36bbce39e864116f35aa7e">More...</a><br /></td></tr>
<tr class="separator:adb3269602e36bbce39e864116f35aa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c488369b0b5864774ebe7ab4e33d78a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c488369b0b5864774ebe7ab4e33d78a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6c488369b0b5864774ebe7ab4e33d78a">ctl_exec</a> (const std::wstring &amp;name, T arg)</td></tr>
<tr class="memdesc:a6c488369b0b5864774ebe7ab4e33d78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at global scope.  <a href="namespacepmem_1_1obj.html#a6c488369b0b5864774ebe7ab4e33d78a">More...</a><br /></td></tr>
<tr class="separator:a6c488369b0b5864774ebe7ab4e33d78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ac392b8f634101ffeebb3c6838ebe3f8a">pool_by_vptr</a> (const T *that)</td></tr>
<tr class="memdesc:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve pool handle for the given pointer.  <a href="namespacepmem_1_1obj.html#ac392b8f634101ffeebb3c6838ebe3f8a">More...</a><br /></td></tr>
<tr class="separator:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a91c6d7a276ccbdfd1eee3f10431aa71f">pool_by_pptr</a> (const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve pool handle for the given <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a91c6d7a276ccbdfd1eee3f10431aa71f">More...</a><br /></td></tr>
<tr class="separator:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main libpmemobj namespace. </p>
<p>It contains all libpmemobj's public types, enums, classes with their functions and members. It is located within pmem namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">&#9670;&nbsp;</a></span>exponential_size_array_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">pmem::obj::exponential_size_array_policy</a> = typedef segment_vector_internal::exponential_size_policy&lt; <a class="el" href="structpmem_1_1obj_1_1array.html">segment_vector_internal::array_64</a>, SegmentType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential size policy with pmemobj array of size 64 as a type of segment vector, so this is a static array of segments and each segment is of SegmentType. </p>
<ul>
<li>requires more memory than exponential_size_vector_policy</li>
<li>is faster and more efficient than exponential_size_vector_policy </li>
</ul>

</div>
</div>
<a id="a526e84dce66d8c59cdc9070321b8d0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526e84dce66d8c59cdc9070321b8d0d7">&#9670;&nbsp;</a></span>exponential_size_vector_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#a526e84dce66d8c59cdc9070321b8d0d7">pmem::obj::exponential_size_vector_policy</a> = typedef segment_vector_internal::exponential_size_policy&lt;<a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential size policy with pmemobj vector as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType. </p>
<ul>
<li>requires less memory than exponential_size_array_policy</li>
<li>is slower and less efficient than exponential_size_array_policy </li>
</ul>

</div>
</div>
<a id="a859b965166fda256885558839d7bb7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859b965166fda256885558839d7bb7ec">&#9670;&nbsp;</a></span>fixed_size_vector_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SegmentSize = 1024, template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#a859b965166fda256885558839d7bb7ec">pmem::obj::fixed_size_vector_policy</a> = typedef segment_vector_internal::fixed_size_policy&lt;<a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType, SegmentSize&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed size policy with pmemobj vector of a given size as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType. </p>
<ul>
<li>is slower than the exponential one (because it has more segments)</li>
<li>causes less fragmentation than the exponential one </li>
</ul>

</div>
</div>
<a id="a584f6676f0d014e94253e19f2d18da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584f6676f0d014e94253e19f2d18da43">&#9670;&nbsp;</a></span>transaction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">pmem::obj::transaction</a> = typedef <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html">basic_transaction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43" title="By default, pmem::obj::transaction is an alias to pmem::obj::basic_transaction.">pmem::obj::transaction</a> is an alias to <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html" title="C++ transaction handler class.">pmem::obj::basic_transaction</a>. </p>
<p>To change it to <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html" title="C++ flat transaction handler class.">pmem::obj::flat_transaction</a> define LIBPMEMOBJ_CPP_USE_FLAT_TRANSACTION macro.</p>
<p>To see what is the difference between the two please look at the examples for flat tx: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_flat_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        p&lt;int&gt; count;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, [&amp;] {</div>
<div class="line">            proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                    proot-&gt;count++;</div>
<div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;some error&quot;</span>);</div>
<div class="line">                });</div>
<div class="line">            } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">                <span class="comment">/* Transaction is not aborted yet (unlike for</span></div>
<div class="line"><span class="comment">                 * basic_transaction). */</span></div>
<div class="line">                assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line">                assert(proot-&gt;count == 2);</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* An internal transaction error occurred, outer tx aborted just</span></div>
<div class="line"><span class="comment">         * now. Reacquire locks if necessary. */</span></div>
<div class="line">        assert(proot-&gt;count == 0);</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* Some other exception thrown, outer tx aborted just now.</span></div>
<div class="line"><span class="comment">         * Reacquire locks if necessary. */</span></div>
<div class="line">        assert(proot-&gt;count == 0);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1flat__transaction_html_a6162d1d30b3c679814498da961147c54"><div class="ttname"><a href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">pmem::obj::flat_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:830</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:696</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__error_html"><div class="ttname"><a href="classpmem_1_1transaction__error.html">pmem::transaction_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:91</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">Persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="apext_8hpp_html"><div class="ttname"><a href="pext_8hpp.html">pext.hpp</a></div><div class="ttdoc">Convenience extensions for the resides on pmem property template.</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>simple_ptr {</div>
<div class="line">    simple_ptr()</div>
<div class="line">    {</div>
<div class="line">        assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line">        ptr = make_persistent&lt;T&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~simple_ptr()</div>
<div class="line">    {</div>
<div class="line">        assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            delete_persistent&lt;T&gt;(ptr);</div>
<div class="line">        } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            std::terminate();</div>
<div class="line">        } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__scope__error.html">pmem::transaction_scope_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            std::terminate();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    persistent_ptr&lt;T&gt; ptr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>A {</div>
<div class="line">    A() : ptr1(), ptr2()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    simple_ptr&lt;int&gt; ptr1;</div>
<div class="line">    simple_ptr&lt;<span class="keywordtype">char</span>[(1ULL &lt;&lt; 30)]&gt; ptr2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>B {</div>
<div class="line">    B() : ptr1(), ptr2()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> pop = pool_base(pmemobj_pool_by_ptr(<span class="keyword">this</span>));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// It would result in a crash!</span></div>
<div class="line">        <span class="comment">// basic_transaction::run(pop, [&amp;]{ throw</span></div>
<div class="line">        <span class="comment">// std::runtime_error(&quot;Error&quot;); });</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(</div>
<div class="line">            pop, [&amp;] { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Error&quot;</span>); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    simple_ptr&lt;int&gt; ptr1;</div>
<div class="line">    simple_ptr&lt;int&gt; ptr2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_nested_struct_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        persistent_ptr&lt;A&gt; ptrA;</div>
<div class="line">        persistent_ptr&lt;B&gt; ptrB;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> create_a = [&amp;] { proot-&gt;ptrA = make_persistent&lt;A&gt;(); };</div>
<div class="line">    <span class="keyword">auto</span> create_b = [&amp;] { proot-&gt;ptrB = make_persistent&lt;B&gt;(); };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// It would result in a crash!</span></div>
<div class="line">        <span class="comment">// basic_transaction::run(pop, create_a);</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, create_a);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* To see why flat_transaction is necessary let&#39;s</span></div>
<div class="line"><span class="comment">         * consider what happens when calling A ctor. The call stack</span></div>
<div class="line"><span class="comment">         * will look like this:</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         *  | ptr2 ctor |</span></div>
<div class="line"><span class="comment">         *  |-----------|</span></div>
<div class="line"><span class="comment">         *  | ptr1 ctor |</span></div>
<div class="line"><span class="comment">         *  |-----------|</span></div>
<div class="line"><span class="comment">         *  |  A ctor   |</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Since ptr2 is a pointer to some huge array of elements,</span></div>
<div class="line"><span class="comment">         * calling ptr2 ctor will most likely result in make_persistent</span></div>
<div class="line"><span class="comment">         * throwing an exception (due to out of memory). This exception</span></div>
<div class="line"><span class="comment">         * will, in turn, cause stack unwinding - already constructed</span></div>
<div class="line"><span class="comment">         * elements must be destroyed (in this example ptr1 destructor</span></div>
<div class="line"><span class="comment">         * will be called).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * If we&#39;d use basic_transaction the allocation failure, apart</span></div>
<div class="line"><span class="comment">         * from throwing an exception, would also cause the transaction</span></div>
<div class="line"><span class="comment">         * to abort (by default, in basic_transaction, all transactional</span></div>
<div class="line"><span class="comment">         * functions failures cause tx abort). This is problematic since</span></div>
<div class="line"><span class="comment">         * the ptr1 destructor, which is called during stack unwinding,</span></div>
<div class="line"><span class="comment">         * expects the transaction to be in WORK stage (and the actual</span></div>
<div class="line"><span class="comment">         * stage is ABORTED). As a result the application will fail on</span></div>
<div class="line"><span class="comment">         * assert (and probably crash in NDEBUG mode).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Now, consider what will happen if we&#39;d use flat_transaction</span></div>
<div class="line"><span class="comment">         * instead. In this case, make_persistent failure will not abort</span></div>
<div class="line"><span class="comment">         * the transaction, it will only result in an exception. This</span></div>
<div class="line"><span class="comment">         * means that the transaction is still in WORK stage during</span></div>
<div class="line"><span class="comment">         * stack unwinding. Only after it completes, the transaction is</span></div>
<div class="line"><span class="comment">         * aborted (it&#39;s happening at the outermost level, when exiting</span></div>
<div class="line"><span class="comment">         * create_a lambda).</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">basic_transaction::run</a>(pop, create_b);</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, create_b);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Running create_b can be done both within basic and flat</span></div>
<div class="line"><span class="comment">         * transaction. However, note that the transaction used in the B</span></div>
<div class="line"><span class="comment">         * constructor MUST be a flat_transaction. This is because</span></div>
<div class="line"><span class="comment">         * flat_transaction does not abort immediately when catching an</span></div>
<div class="line"><span class="comment">         * exception. Instead it passes it to the outermost transaction</span></div>
<div class="line"><span class="comment">         * - the abort is performed at that outermost level. In case of</span></div>
<div class="line"><span class="comment">         * a basic_transaction the abort would be done within the B ctor</span></div>
<div class="line"><span class="comment">         * and it would result in the same problems as with the previous</span></div>
<div class="line"><span class="comment">         * example.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_a9564707de1779ca1bce7041fb7c9855c"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::basic_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:700</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__free__error_html"><div class="ttname"><a href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:184</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__scope__error_html"><div class="ttname"><a href="classpmem_1_1transaction__scope__error.html">pmem::transaction_scope_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:206</div></div>
</div><!-- fragment --><p> and basic tx: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__mutex_8hpp.html">libpmemobj++/shared_mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">manual_tx_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        mutex pmutex;</div>
<div class="line">        shared_mutex shared_pmutex;</div>
<div class="line">        p&lt;int&gt; count;</div>
<div class="line">        persistent_ptr&lt;root&gt; another_root;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#ad86b8b9def7073307927ba6e41d0fbf5">transaction::manual</a> tx(pop, proot-&gt;pmutex,</div>
<div class="line">                       proot-&gt;shared_pmutex);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically allocate objects */</span></div>
<div class="line">        proot-&gt;another_root = make_persistent&lt;root&gt;();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically modify objects */</span></div>
<div class="line">        proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* It&#39;s necessary to commit the transaction manually and</span></div>
<div class="line"><span class="comment">         * it has to be the last operation in the transaction. */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">transaction::commit</a>();</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* an internal transaction error occurred, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* some other exception thrown, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* In complex cases with library calls, remember to check the status of</span></div>
<div class="line"><span class="comment">     * the previous transaction. */</span></div>
<div class="line">    <span class="keywordflow">return</span> transaction::error();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspmem_1_1detail_1_1transaction__base_html_a16c0d86f943d6727e1caa7573cc83edb"><div class="ttname"><a href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">pmem::detail::transaction_base&lt; false &gt;::commit</a></div><div class="ttdeci">static void commit()</div><div class="ttdoc">Manually commit a transaction.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:330</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_ad86b8b9def7073307927ba6e41d0fbf5"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#ad86b8b9def7073307927ba6e41d0fbf5">pmem::obj::basic_transaction::manual</a></div><div class="ttdeci">typename detail::transaction_base&lt; false &gt;::manual manual</div><div class="ttdoc">C++ manual scope transaction class.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:639</div></div>
<div class="ttc" id="amutex_8hpp_html"><div class="ttname"><a href="mutex_8hpp.html">mutex.hpp</a></div><div class="ttdoc">Pmem-resident mutex.</div></div>
<div class="ttc" id="ashared__mutex_8hpp_html"><div class="ttname"><a href="shared__mutex_8hpp.html">shared_mutex.hpp</a></div><div class="ttdoc">Pmem-resident shared mutex.</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae5828e2ef9f44c67de727e4498c89f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5828e2ef9f44c67de727e4498c89f1f">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute function at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a6c488369b0b5864774ebe7ab4e33d78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c488369b0b5864774ebe7ab4e33d78a">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute function at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="aa89f45b433f00601332cc8b026c8094b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89f45b433f00601332cc8b026c8094b">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a64434e59ff1de9be9e73a9eb8d364b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64434e59ff1de9be9e73a9eb8d364b45">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a35c4923f7973d6d9eeefdc6eeb16a4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c4923f7973d6d9eeefdc6eeb16a4f1">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="adb3269602e36bbce39e864116f35aa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3269602e36bbce39e864116f35aa7e">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a4222feb628a4d6f8ac2b3a5dbe42c5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4222feb628a4d6f8ac2b3a5dbe42c5e6">&#9670;&nbsp;</a></span>delete_persistent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_array&lt; T &gt;::type&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<p>This function can be used to <em>transactionally</em> free an array of objects. Calls the objects' destructors before freeing memory. This overload only participates in overload resolution if T is an array.</p>
<p>To ensure that proper recovery is possible, ptr should be set to null after delete_persistent call and within the same transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>persistent pointer to an array of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>the size of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a></td><td>on transactional free failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5582033bf768fea635b40b3ba766fbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5582033bf768fea635b40b3ba766fbef">&#9670;&nbsp;</a></span>delete_persistent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_size_array&lt; T &gt;::type&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<p>This function can be used to <em>transactionally</em> free an array of objects. Calls the objects' destructors before freeing memory. This overload only participates in overload resolution if T is an array.</p>
<p>To ensure that proper recovery is possible, ptr should be set to null after delete_persistent call and within the same transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>persistent pointer to an array of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a></td><td>on transactional free failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2009e20a7365ba802a5f1acbff2f2336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2009e20a7365ba802a5f1acbff2f2336">&#9670;&nbsp;</a></span>delete_persistent_atomic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically deallocate an array of objects. </p>
<p>There is no way to atomically destroy an object. Any object specific cleanup must be performed elsewhere. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<p>param[in,out] ptr the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> whose pointee is to be deallocated. </p>

</div>
</div>
<a id="a774f709132747433efe83cf8060186a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774f709132747433efe83cf8060186a3">&#9670;&nbsp;</a></span>delete_persistent_atomic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_size_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically deallocate an array of objects. </p>
<p>There is no way to atomically destroy an object. Any object specific cleanup must be performed elsewhere. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<p>param[in,out] ptr the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> whose pointee is to be deallocated. </p>

</div>
</div>
<a id="a7917f08b1869d3b1bb361976d08163de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7917f08b1869d3b1bb361976d08163de">&#9670;&nbsp;</a></span>is_defragmentable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::enable_if&lt;detail::t_is_defragmentable&lt;T&gt;::value, bool&gt;::type pmem::obj::is_defragmentable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if provided T type is defragmentable. </p>
<p>This is included in public API, but there's no need to check it before calling 'add()', since 'add' method has a specialization for doing nothing in case of non-defragmentable object.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true when object implements 'for_each_ptr' method. </dd></dl>

</div>
</div>
<a id="a23adee8f9c8707cfd978e45e130df05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23adee8f9c8707cfd978e45e130df05b">&#9670;&nbsp;</a></span>is_defragmentable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::enable_if&lt;!detail::t_is_defragmentable&lt;T&gt;::value, bool&gt;::type pmem::obj::is_defragmentable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if provided T type is defragmentable. </p>
<p>Specialization for non-defragmentable objects.</p>
<dl class="section return"><dt>Returns</dt><dd>bool false when object does not implement 'for_each_ptr' method. </dd></dl>

</div>
</div>
<a id="a7b14ac5b07d58902df4c24deb7096d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b14ac5b07d58902df4c24deb7096d12">&#9670;&nbsp;</a></span>make_persistent_atomic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::make_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::pp_if_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically allocate an array of objects. </p>
<p>This function can be used to atomically allocate an array of objects. Cannot be used for simple objects. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool from which the object will be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>the persistent pointer to which the allocation will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>the number of array elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d456157a9ddd13772036944fab68b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d456157a9ddd13772036944fab68b01">&#9670;&nbsp;</a></span>make_persistent_atomic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::make_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::pp_if_size_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically allocate an array of objects. </p>
<p>This function can be used to atomically allocate an array of objects. Cannot be used for simple objects. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool from which the object will be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>the persistent pointer to which the allocation will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91c6d7a276ccbdfd1eee3f10431aa71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c6d7a276ccbdfd1eee3f10431aa71f">&#9670;&nbsp;</a></span>pool_by_pptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> pmem::obj::pool_by_pptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve pool handle for the given <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to an object from a persistent memory pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the pool containing the object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>if the given pointer does not belong to an open pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac392b8f634101ffeebb3c6838ebe3f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac392b8f634101ffeebb3c6838ebe3f8a">&#9670;&nbsp;</a></span>pool_by_vptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> pmem::obj::pool_by_vptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve pool handle for the given pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">that</td><td>pointer to an object from a persistent memory pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the pool containing the object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>if the given pointer does not belong to an open pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
