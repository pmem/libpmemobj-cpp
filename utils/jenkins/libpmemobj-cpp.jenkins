// SPDX-License-Identifier: BSD-3-Clause
/* Copyright 2021, Intel Corporation */

/* libpmemobj-cpp.jenkins - pipeline for libpmemobj-cpp jenkins job. */

/* declare a map object for holding loaded libraries: */
libs = [:]

currentBuild.displayName = "#$currentBuild.id $LABEL: $BRANCH - $TEST_TYPE, coverage: $COVERAGE"
currentBuild.description = "$DESCRIPTION"

REPO_DIR='libpmemobj-cpp'

/* Send report summary via email. */
def send_mail(attachments, msg) {

    def recipients = params.EMAIL_RECIPIENTS
    def message_title = "[Jenkins/libpmemobj-cpp] Report ${currentBuild.projectName} ${currentBuild.displayName}"
    def message_body = """
        <p>---<br />Auto-generated by <a href="${env.JENKINS_URL}">Jenkins</a></p>
        <p>---<br /><a href="${params.REPO_URL}">${params.REPO_URL}</a> BRANCH: ${params.BRANCH}</p>
        <p><br /><a href="${env.JENKINS_URL}view/all/job/${currentBuild.projectName}/${currentBuild.id}">Build link</a></p>
        <p> <b> Description: </b> ${params.DESCRIPTION} </p>
    """

    message_body += msg

    emailext (
        to: recipients,
        subject: message_title,
        body: message_body,
        mimeType: "text/html",
        attachmentsPattern: attachments
    )
}

pipeline {
	/* put timestamps in output log. */
	options { timestamps () }

	/* execute this pipeline job on node in "LABEL" group in Jenkins. */
	agent { label params.LABEL }

	/* each stage represents pipeline step. */
	stages {
		/* preparation stage: clean workspace, create output directories, log file,
		clone repository containing Jenkins pipelines, load libraries, set warning on DUT, etc. */
		stage('Prepare workspace') {
			steps {
				print "Deleting ${WORKSPACE} directory"
				deleteDir()

				print "Creating ${WORKSPACE}/output directory"
				dir('output') {
					writeFile file: 'console.log', text: ''
				}

				print "Checkout repository containing Jenkins libraries and additional scripts"
				checkout([$class: 'GitSCM', branches: [[name: jenkins_files_branch]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'dev-utils-kit']], submoduleCfg: [], userRemoteConfigs: [[url: jenkins_files_repo]]])

				print "Loading pipeline libraries"
				script {
					libs.api = load api_lib
					libs.api.set_jenkins_warning_on_dut()
				}
			}
		}
		/* gather system info. */
		stage('System-info'){
			steps {
				script {
					libs.api.system_info()
				}
			}
		}
		/* clone libpmemobj-cpp repository to be tested */
		stage('Repo Checkout libpmemobj-cpp') {
			steps {
				script {
					def REPO_PATH="${WORKSPACE_DIR}/${REPO_DIR}"
					libs.api.clone_repository(params.REPO_URL, params.BRANCH, REPO_DIR)
				}
			}
		}
		stage('Run test') {
			steps {
				script {
				warnError('Build unstable.') {
					libs.api.echo_header("Running tests")
					libs.api.run_bash_script("""
						echo "DEVICE TYPE: ${params.DEVICE_TYPE}"
						echo "TEST TYPE: ${params.TEST_TYPE}"
						echo "CPP_STYLE: ${params.CHECK_CPP_STYLE}"
						echo "LONG: ${params.TESTS_LONG}"
						echo "TBB: ${params.TESTS_TBB}"
						echo "PMREORDER: ${params.TESTS_PMREORDER}"
						echo "TIMEOUT: ${params.TEST_TIMEOUT}"
					""")					
					def COV_PARAM=""
					def TEST_DIR
					if (params.COVERAGE == 'yes') {
						COV_PARAM="export COVERAGE=1"
					}
					def REPO_PATH="${WORKSPACE}/${REPO_DIR}"
					switch (params.DEVICE_TYPE) {
						case 'DAX':
							libs.api.run_bash_script("""
								${SCRIPTS_DIR}/createNamespace.sh -d --size=100G
							""")
							TEST_DIR = "/dev/" + libs.api.run_bash_script("""
								sudo ndctl list -M -N | jq -r '.[] | select(.mode=="devdax").chardev' | head -n 1
							""").output
							break
						case 'PMEM':
							libs.api.run_bash_script("""
								${SCRIPTS_DIR}/createNamespace.sh -p --size=100G
							""")
							TEST_DIR = "/mnt/pmem0"
							break
						case 'NONE':
							TEST_DIR = "/dev/shm"
							break
						}
					def ENV_VAL="export DEFAULT_TEST_DIR=${TEST_DIR}; export WORKDIR=${WORKSPACE_DIR}/${REPO_DIR}; export SCRIPTSDIR=\$WORKDIR/utils/docker; export TESTS_LONG=${params.TESTS_LONG}; export CHECK_CPP_STYLE=${params.CHECK_CPP_STYLE}; export TESTS_PMREORDER=${params.TESTS_PMREORDER}; export TESTS_TBB=${params.TESTS_TBB}; export TERM=xterm-256color; export TEST_TIMEOUT=${params.TEST_TIMEOUT}; export TESTS_USE_FORCED_PMEM=0; ${COV_PARAM}"
					libs.api.echo_header("Running test type: ${params.TEST_TYPE}")
					dir("${REPO_PATH}/utils/docker")
					libs.api.echo_header("Test options: ${params.TEST_OPTIONS}")
					params.TEST_OPTIONS.split().each { build ->
						stage("${build}") {
							catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
						libs.api.run_bash_script("""
							${ENV_VAL}
							./run-build.sh ${build}
							""")
							}
						}
					}
					libs.api.echo_header("Finished running tests.")
					}
				}
			}
		}
	}
/* 
	generate post-build artifacts
	write "fail" or "success" in result.txt file
	archive results
*/
	post {
		/* 'always' declarations must be declared first. */
		always {
			script {
				libs.api.unset_jenkins_warning_on_dut()
				libs.api.write_os_branch_repo(params.LABEL, params.BRANCH, params.REPO_URL)
				libs.api.archive_output()
				/* Make sure to uninstall libpmemobj-cpp from the DUT. */
				def REPO_PATH="${WORKSPACE_DIR}/${REPO_DIR}"
				libs.api.run_bash_script("""
							cd ${REPO_PATH}/build || true
							sudo make uninstall || true
							sudo rm /usr/lib64/pkgconfig/libpmemobj++.pc || true
						""")
			}
		}
		success {
			script {
				libs.api.write_result_and_archive('success')
				if (params.SEND_RESULTS) {
					def build_info = "Build" + " #$currentBuild.id " + "succeeded"
					send_mail('', build_info)
					}
			}
		}
		failure {
			script {
				libs.api.write_result_and_archive('fail')
				if (params.SEND_RESULTS) {
					def build_info = "Build" + " #$currentBuild.id " + "failed"
					send_mail('', build_info)
				}
			}
		}
		unstable {
			script {
				libs.api.write_result_and_archive('fail')
				if (params.SEND_RESULTS) {
					def build_info = "Build" + " #$currentBuild.id " + "failed"
					send_mail('', build_info)
				}
			}
		}
	}
}
