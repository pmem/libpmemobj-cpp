<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::detail::concurrent_skip_list&lt; Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.10</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classpmem_1_1detail_1_1concurrent__skip__list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::detail::concurrent_skip_list&lt; Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent memory aware implementation of the concurrent skip list.  
 <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concurrent__skip__list__impl_8hpp_source.html">libpmemobj++/container/detail/concurrent_skip_list_impl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a584560a7186d5d8b6bda1f849921df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3a584560a7186d5d8b6bda1f849921df">concurrent_skip_list</a> ()</td></tr>
<tr class="memdesc:a3a584560a7186d5d8b6bda1f849921df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3a584560a7186d5d8b6bda1f849921df">More...</a><br /></td></tr>
<tr class="separator:a3a584560a7186d5d8b6bda1f849921df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751b1925506cb312d459a9f045edc88f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a751b1925506cb312d459a9f045edc88f">concurrent_skip_list</a> (const key_compare &amp;comp, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a751b1925506cb312d459a9f045edc88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a751b1925506cb312d459a9f045edc88f">More...</a><br /></td></tr>
<tr class="separator:a751b1925506cb312d459a9f045edc88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98469541d7990b8a5f6200da8eef6e37"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a98469541d7990b8a5f6200da8eef6e37"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a98469541d7990b8a5f6200da8eef6e37">concurrent_skip_list</a> (InputIt first, InputIt last, const key_compare &amp;comp=key_compare(), const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a98469541d7990b8a5f6200da8eef6e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a98469541d7990b8a5f6200da8eef6e37">More...</a><br /></td></tr>
<tr class="separator:a98469541d7990b8a5f6200da8eef6e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8124cbb5057bb8203c29c5a0039a78e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8124cbb5057bb8203c29c5a0039a78e8">concurrent_skip_list</a> (const <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;other)</td></tr>
<tr class="memdesc:a8124cbb5057bb8203c29c5a0039a78e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8124cbb5057bb8203c29c5a0039a78e8">More...</a><br /></td></tr>
<tr class="separator:a8124cbb5057bb8203c29c5a0039a78e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2820af7de7052245e993dd8549abc65b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a2820af7de7052245e993dd8549abc65b">concurrent_skip_list</a> (const <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;other, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:a2820af7de7052245e993dd8549abc65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a2820af7de7052245e993dd8549abc65b">More...</a><br /></td></tr>
<tr class="separator:a2820af7de7052245e993dd8549abc65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eae361baf98dd2b0ca4554c955559b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4eae361baf98dd2b0ca4554c955559b7">concurrent_skip_list</a> (<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a4eae361baf98dd2b0ca4554c955559b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4eae361baf98dd2b0ca4554c955559b7">More...</a><br /></td></tr>
<tr class="separator:a4eae361baf98dd2b0ca4554c955559b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ac5792b79b8d661b13d9caf24603ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab4ac5792b79b8d661b13d9caf24603ef">concurrent_skip_list</a> (<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;&amp;other, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:ab4ac5792b79b8d661b13d9caf24603ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab4ac5792b79b8d661b13d9caf24603ef">More...</a><br /></td></tr>
<tr class="separator:ab4ac5792b79b8d661b13d9caf24603ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ead701625a419d46f4592e88bbf6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac1ead701625a419d46f4592e88bbf6af">runtime_initialize</a> ()</td></tr>
<tr class="memdesc:ac1ead701625a419d46f4592e88bbf6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intialize <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> after process restart.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac1ead701625a419d46f4592e88bbf6af">More...</a><br /></td></tr>
<tr class="separator:ac1ead701625a419d46f4592e88bbf6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb23bea4c5cd65f97e9708a9f6847621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#acb23bea4c5cd65f97e9708a9f6847621">free_data</a> ()</td></tr>
<tr class="memdesc:acb23bea4c5cd65f97e9708a9f6847621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should be called before <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> destructor is called.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#acb23bea4c5cd65f97e9708a9f6847621">More...</a><br /></td></tr>
<tr class="separator:acb23bea4c5cd65f97e9708a9f6847621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3449d0457c698cf4cc0e8bb41aeab003"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3449d0457c698cf4cc0e8bb41aeab003">~concurrent_skip_list</a> ()</td></tr>
<tr class="memdesc:a3449d0457c698cf4cc0e8bb41aeab003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3449d0457c698cf4cc0e8bb41aeab003">More...</a><br /></td></tr>
<tr class="separator:a3449d0457c698cf4cc0e8bb41aeab003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc9be9e3ac76caf18bdaa15bbc1c8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a1cc9be9e3ac76caf18bdaa15bbc1c8c7">operator=</a> (const <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;other)</td></tr>
<tr class="memdesc:a1cc9be9e3ac76caf18bdaa15bbc1c8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a1cc9be9e3ac76caf18bdaa15bbc1c8c7">More...</a><br /></td></tr>
<tr class="separator:a1cc9be9e3ac76caf18bdaa15bbc1c8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dc6802e7cbc6ec92e280019f7068dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab5dc6802e7cbc6ec92e280019f7068dc">operator=</a> (<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ab5dc6802e7cbc6ec92e280019f7068dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab5dc6802e7cbc6ec92e280019f7068dc">More...</a><br /></td></tr>
<tr class="separator:ab5dc6802e7cbc6ec92e280019f7068dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961aec86879c4a85eb82464da68eb05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a961aec86879c4a85eb82464da68eb05a">operator=</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a961aec86879c4a85eb82464da68eb05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list il.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a961aec86879c4a85eb82464da68eb05a">More...</a><br /></td></tr>
<tr class="separator:a961aec86879c4a85eb82464da68eb05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdeb36f2617cde6e05dfcc97058b868"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a9cdeb36f2617cde6e05dfcc97058b868">insert</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:a9cdeb36f2617cde6e05dfcc97058b868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in a thread-safe way.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a9cdeb36f2617cde6e05dfcc97058b868">More...</a><br /></td></tr>
<tr class="separator:a9cdeb36f2617cde6e05dfcc97058b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264928915cee8f7602a84feb14e22e1b"><td class="memTemplParams" colspan="2">template&lt;typename P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp; &gt;::value &gt;::type &gt; </td></tr>
<tr class="memitem:a264928915cee8f7602a84feb14e22e1b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a264928915cee8f7602a84feb14e22e1b">insert</a> (P &amp;&amp;value)</td></tr>
<tr class="memdesc:a264928915cee8f7602a84feb14e22e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a264928915cee8f7602a84feb14e22e1b">More...</a><br /></td></tr>
<tr class="separator:a264928915cee8f7602a84feb14e22e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62482ff535491db93f2773b7957221d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#af62482ff535491db93f2773b7957221d">insert</a> (value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:af62482ff535491db93f2773b7957221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value using move semantic.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#af62482ff535491db93f2773b7957221d">More...</a><br /></td></tr>
<tr class="separator:af62482ff535491db93f2773b7957221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7011ac4ac2c996895033d17ebbac1972"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7011ac4ac2c996895033d17ebbac1972">insert</a> (const_iterator hint, const_reference value)</td></tr>
<tr class="memdesc:a7011ac4ac2c996895033d17ebbac1972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible, just prior to hint.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7011ac4ac2c996895033d17ebbac1972">More...</a><br /></td></tr>
<tr class="separator:a7011ac4ac2c996895033d17ebbac1972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa54447a3d2cbf27bed78272f919915"><td class="memTemplParams" colspan="2">template&lt;typename P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp; &gt;::value &gt;::type &gt; </td></tr>
<tr class="memitem:a7aa54447a3d2cbf27bed78272f919915"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7aa54447a3d2cbf27bed78272f919915">insert</a> (const_iterator hint, P &amp;&amp;value)</td></tr>
<tr class="memdesc:a7aa54447a3d2cbf27bed78272f919915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible, just prior to hint.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7aa54447a3d2cbf27bed78272f919915">More...</a><br /></td></tr>
<tr class="separator:a7aa54447a3d2cbf27bed78272f919915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7451afd50012693e465c60099e2ec"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab8c7451afd50012693e465c60099e2ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab8c7451afd50012693e465c60099e2ec">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ab8c7451afd50012693e465c60099e2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last).  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab8c7451afd50012693e465c60099e2ec">More...</a><br /></td></tr>
<tr class="separator:ab8c7451afd50012693e465c60099e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92942fa69d742306d29c4a0c9932354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae92942fa69d742306d29c4a0c9932354">insert</a> (std::initializer_list&lt; value_type &gt; ilist)</td></tr>
<tr class="memdesc:ae92942fa69d742306d29c4a0c9932354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae92942fa69d742306d29c4a0c9932354">More...</a><br /></td></tr>
<tr class="separator:ae92942fa69d742306d29c4a0c9932354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397dcf122ef8b9b8b28f459a54031d4c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a397dcf122ef8b9b8b28f459a54031d4c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a397dcf122ef8b9b8b28f459a54031d4c">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a397dcf122ef8b9b8b28f459a54031d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a397dcf122ef8b9b8b28f459a54031d4c">More...</a><br /></td></tr>
<tr class="separator:a397dcf122ef8b9b8b28f459a54031d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806470149461716d40fcf69e579c54f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab806470149461716d40fcf69e579c54f"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab806470149461716d40fcf69e579c54f">emplace_hint</a> (const_iterator hint, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab806470149461716d40fcf69e579c54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element to the container as close as possible to the position just before hint.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab806470149461716d40fcf69e579c54f">More...</a><br /></td></tr>
<tr class="separator:ab806470149461716d40fcf69e579c54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c482dc978e488e306d5dc6fcd14fa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acd7c482dc978e488e306d5dc6fcd14fa"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#acd7c482dc978e488e306d5dc6fcd14fa">try_emplace</a> (const key_type &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acd7c482dc978e488e306d5dc6fcd14fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#acd7c482dc978e488e306d5dc6fcd14fa">More...</a><br /></td></tr>
<tr class="separator:acd7c482dc978e488e306d5dc6fcd14fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad614034918785ab4e003cbe2142c2282"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad614034918785ab4e003cbe2142c2282"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ad614034918785ab4e003cbe2142c2282">try_emplace</a> (key_type &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad614034918785ab4e003cbe2142c2282"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ad614034918785ab4e003cbe2142c2282">More...</a><br /></td></tr>
<tr class="separator:ad614034918785ab4e003cbe2142c2282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a846634822804cf6880ddfbd75674"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a731a846634822804cf6880ddfbd75674"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; has_is_transparent&lt; key_compare &gt;::value &amp;&amp;std::is_constructible&lt; key_type, K &amp;&amp; &gt;::value, std::pair&lt; iterator, bool &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a731a846634822804cf6880ddfbd75674">try_emplace</a> (K &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a731a846634822804cf6880ddfbd75674"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a731a846634822804cf6880ddfbd75674">More...</a><br /></td></tr>
<tr class="separator:a731a846634822804cf6880ddfbd75674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacf1ffa9af826b7aa6d690cd2d0fb13"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#acacf1ffa9af826b7aa6d690cd2d0fb13">unsafe_erase</a> (iterator pos)</td></tr>
<tr class="memdesc:acacf1ffa9af826b7aa6d690cd2d0fb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos from the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#acacf1ffa9af826b7aa6d690cd2d0fb13">More...</a><br /></td></tr>
<tr class="separator:acacf1ffa9af826b7aa6d690cd2d0fb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1efd461bdbe61a097b342c565a249"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa2d1efd461bdbe61a097b342c565a249">unsafe_erase</a> (const_iterator pos)</td></tr>
<tr class="memdesc:aa2d1efd461bdbe61a097b342c565a249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos from the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa2d1efd461bdbe61a097b342c565a249">More...</a><br /></td></tr>
<tr class="separator:aa2d1efd461bdbe61a097b342c565a249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9ab4327934dc1f8eb6fccd0f0fc01c"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aea9ab4327934dc1f8eb6fccd0f0fc01c">unsafe_erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:aea9ab4327934dc1f8eb6fccd0f0fc01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aea9ab4327934dc1f8eb6fccd0f0fc01c">More...</a><br /></td></tr>
<tr class="separator:aea9ab4327934dc1f8eb6fccd0f0fc01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6214064458c8e1233d20791147b21c9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab6214064458c8e1233d20791147b21c9">unsafe_erase</a> (const key_type &amp;key)</td></tr>
<tr class="memdesc:ab6214064458c8e1233d20791147b21c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab6214064458c8e1233d20791147b21c9">More...</a><br /></td></tr>
<tr class="separator:ab6214064458c8e1233d20791147b21c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed01e6a61410cc886a8ab406b7a4518"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			has_is_transparent&lt;key_compare&gt;::value &amp;&amp;				!std::is_convertible&lt;K, iterator&gt;::value &amp;&amp;				!std::is_convertible&lt;K, const_iterator&gt;::value,			K&gt;::type&gt; </td></tr>
<tr class="memitem:a7ed01e6a61410cc886a8ab406b7a4518"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7ed01e6a61410cc886a8ab406b7a4518">unsafe_erase</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a7ed01e6a61410cc886a8ab406b7a4518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7ed01e6a61410cc886a8ab406b7a4518">More...</a><br /></td></tr>
<tr class="separator:a7ed01e6a61410cc886a8ab406b7a4518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e97aa16c83e5a2c5c0f40c3935cd520"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e97aa16c83e5a2c5c0f40c3935cd520">lower_bound</a> (const key_type &amp;key)</td></tr>
<tr class="memdesc:a3e97aa16c83e5a2c5c0f40c3935cd520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e97aa16c83e5a2c5c0f40c3935cd520">More...</a><br /></td></tr>
<tr class="separator:a3e97aa16c83e5a2c5c0f40c3935cd520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d5b68ce347b64f50752c768d3c1644"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a18d5b68ce347b64f50752c768d3c1644">lower_bound</a> (const key_type &amp;key) const</td></tr>
<tr class="memdesc:a18d5b68ce347b64f50752c768d3c1644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a18d5b68ce347b64f50752c768d3c1644">More...</a><br /></td></tr>
<tr class="separator:a18d5b68ce347b64f50752c768d3c1644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953e591abc97e924172053c323911f7b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a953e591abc97e924172053c323911f7b"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a953e591abc97e924172053c323911f7b">lower_bound</a> (const K &amp;x)</td></tr>
<tr class="memdesc:a953e591abc97e924172053c323911f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a953e591abc97e924172053c323911f7b">More...</a><br /></td></tr>
<tr class="separator:a953e591abc97e924172053c323911f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f895b664a9115a2bf252fe5b4f1fbb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:ac9f895b664a9115a2bf252fe5b4f1fbb"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac9f895b664a9115a2bf252fe5b4f1fbb">lower_bound</a> (const K &amp;x) const</td></tr>
<tr class="memdesc:ac9f895b664a9115a2bf252fe5b4f1fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac9f895b664a9115a2bf252fe5b4f1fbb">More...</a><br /></td></tr>
<tr class="separator:ac9f895b664a9115a2bf252fe5b4f1fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da476e8cc35fc497d70a60a19e594f3"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3da476e8cc35fc497d70a60a19e594f3">upper_bound</a> (const key_type &amp;key)</td></tr>
<tr class="memdesc:a3da476e8cc35fc497d70a60a19e594f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3da476e8cc35fc497d70a60a19e594f3">More...</a><br /></td></tr>
<tr class="separator:a3da476e8cc35fc497d70a60a19e594f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f8cbc4421f7fcfe3e411bacfa3ee29"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3f8cbc4421f7fcfe3e411bacfa3ee29">upper_bound</a> (const key_type &amp;key) const</td></tr>
<tr class="memdesc:ae3f8cbc4421f7fcfe3e411bacfa3ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3f8cbc4421f7fcfe3e411bacfa3ee29">More...</a><br /></td></tr>
<tr class="separator:ae3f8cbc4421f7fcfe3e411bacfa3ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0d7d6cd7a863ea75a9150136cb4c0a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:abd0d7d6cd7a863ea75a9150136cb4c0a"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#abd0d7d6cd7a863ea75a9150136cb4c0a">upper_bound</a> (const K &amp;x)</td></tr>
<tr class="memdesc:abd0d7d6cd7a863ea75a9150136cb4c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value x.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#abd0d7d6cd7a863ea75a9150136cb4c0a">More...</a><br /></td></tr>
<tr class="separator:abd0d7d6cd7a863ea75a9150136cb4c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac21642d5dbdff2764d243038f7b2e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:ad5ac21642d5dbdff2764d243038f7b2e"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ad5ac21642d5dbdff2764d243038f7b2e">upper_bound</a> (const K &amp;x) const</td></tr>
<tr class="memdesc:ad5ac21642d5dbdff2764d243038f7b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value x.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ad5ac21642d5dbdff2764d243038f7b2e">More...</a><br /></td></tr>
<tr class="separator:ad5ac21642d5dbdff2764d243038f7b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91107b1c17399ee3db02b08d3e272523"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a91107b1c17399ee3db02b08d3e272523">find</a> (const key_type &amp;key)</td></tr>
<tr class="memdesc:a91107b1c17399ee3db02b08d3e272523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a91107b1c17399ee3db02b08d3e272523">More...</a><br /></td></tr>
<tr class="separator:a91107b1c17399ee3db02b08d3e272523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f6033d2832d7c8a5395c9a985c4481"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a91f6033d2832d7c8a5395c9a985c4481">find</a> (const key_type &amp;key) const</td></tr>
<tr class="memdesc:a91f6033d2832d7c8a5395c9a985c4481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a91f6033d2832d7c8a5395c9a985c4481">More...</a><br /></td></tr>
<tr class="separator:a91f6033d2832d7c8a5395c9a985c4481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b414ba69315d80ce7ed39354af8ed2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:aa4b414ba69315d80ce7ed39354af8ed2"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa4b414ba69315d80ce7ed39354af8ed2">find</a> (const K &amp;x)</td></tr>
<tr class="memdesc:aa4b414ba69315d80ce7ed39354af8ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value x.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa4b414ba69315d80ce7ed39354af8ed2">More...</a><br /></td></tr>
<tr class="separator:aa4b414ba69315d80ce7ed39354af8ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33565af7168c79a33ed2707e303973be"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a33565af7168c79a33ed2707e303973be"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a33565af7168c79a33ed2707e303973be">find</a> (const K &amp;x) const</td></tr>
<tr class="memdesc:a33565af7168c79a33ed2707e303973be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value x.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a33565af7168c79a33ed2707e303973be">More...</a><br /></td></tr>
<tr class="separator:a33565af7168c79a33ed2707e303973be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bc13511e419c74cf472c0ea500f9e9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac2bc13511e419c74cf472c0ea500f9e9">count</a> (const key_type &amp;key) const</td></tr>
<tr class="memdesc:ac2bc13511e419c74cf472c0ea500f9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac2bc13511e419c74cf472c0ea500f9e9">More...</a><br /></td></tr>
<tr class="separator:ac2bc13511e419c74cf472c0ea500f9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d49d6ba2ca744a9d6fa05f3fb92f3d8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a7d49d6ba2ca744a9d6fa05f3fb92f3d8"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7d49d6ba2ca744a9d6fa05f3fb92f3d8">count</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a7d49d6ba2ca744a9d6fa05f3fb92f3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7d49d6ba2ca744a9d6fa05f3fb92f3d8">More...</a><br /></td></tr>
<tr class="separator:a7d49d6ba2ca744a9d6fa05f3fb92f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f6fc748b3e3cc93f101270eeb56562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a07f6fc748b3e3cc93f101270eeb56562">contains</a> (const key_type &amp;key) const</td></tr>
<tr class="memdesc:a07f6fc748b3e3cc93f101270eeb56562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a07f6fc748b3e3cc93f101270eeb56562">More...</a><br /></td></tr>
<tr class="separator:a07f6fc748b3e3cc93f101270eeb56562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4d7504452f1b6990993db6ad487e86"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a8d4d7504452f1b6990993db6ad487e86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8d4d7504452f1b6990993db6ad487e86">contains</a> (const K &amp;x) const</td></tr>
<tr class="memdesc:a8d4d7504452f1b6990993db6ad487e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value x.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8d4d7504452f1b6990993db6ad487e86">More...</a><br /></td></tr>
<tr class="separator:a8d4d7504452f1b6990993db6ad487e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3794b5214e8bab05762329d909ca258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab3794b5214e8bab05762329d909ca258">clear</a> ()</td></tr>
<tr class="memdesc:ab3794b5214e8bab05762329d909ca258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container transactionally.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ab3794b5214e8bab05762329d909ca258">More...</a><br /></td></tr>
<tr class="separator:ab3794b5214e8bab05762329d909ca258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad55d7ae8a1973e75b8142984235eed"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4ad55d7ae8a1973e75b8142984235eed">begin</a> ()</td></tr>
<tr class="memdesc:a4ad55d7ae8a1973e75b8142984235eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4ad55d7ae8a1973e75b8142984235eed">More...</a><br /></td></tr>
<tr class="separator:a4ad55d7ae8a1973e75b8142984235eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa4214acfb506f7b5ee5fb6abc26365"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3fa4214acfb506f7b5ee5fb6abc26365">begin</a> () const</td></tr>
<tr class="memdesc:a3fa4214acfb506f7b5ee5fb6abc26365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3fa4214acfb506f7b5ee5fb6abc26365">More...</a><br /></td></tr>
<tr class="separator:a3fa4214acfb506f7b5ee5fb6abc26365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dca3851b967fd4cce066d814a375a31"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3dca3851b967fd4cce066d814a375a31">cbegin</a> () const</td></tr>
<tr class="memdesc:a3dca3851b967fd4cce066d814a375a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3dca3851b967fd4cce066d814a375a31">More...</a><br /></td></tr>
<tr class="separator:a3dca3851b967fd4cce066d814a375a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910dcecf8afddfc4144b2c0df13abd01"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01">end</a> ()</td></tr>
<tr class="memdesc:a910dcecf8afddfc4144b2c0df13abd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01">More...</a><br /></td></tr>
<tr class="separator:a910dcecf8afddfc4144b2c0df13abd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b1ff228b6d31d473a070e5ae76f638"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa9b1ff228b6d31d473a070e5ae76f638">end</a> () const</td></tr>
<tr class="memdesc:aa9b1ff228b6d31d473a070e5ae76f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa9b1ff228b6d31d473a070e5ae76f638">More...</a><br /></td></tr>
<tr class="separator:aa9b1ff228b6d31d473a070e5ae76f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3574b8bb76170c7b2caf9b93e91ebffa"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3574b8bb76170c7b2caf9b93e91ebffa">cend</a> () const</td></tr>
<tr class="memdesc:a3574b8bb76170c7b2caf9b93e91ebffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3574b8bb76170c7b2caf9b93e91ebffa">More...</a><br /></td></tr>
<tr class="separator:a3574b8bb76170c7b2caf9b93e91ebffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b0431150249293ef47de210d2c21ff"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff">size</a> () const</td></tr>
<tr class="memdesc:ae3b0431150249293ef47de210d2c21ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff">More...</a><br /></td></tr>
<tr class="separator:ae3b0431150249293ef47de210d2c21ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a3191b19596140bbd407ec969ff73b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a60a3191b19596140bbd407ec969ff73b">max_size</a> () const</td></tr>
<tr class="memdesc:a60a3191b19596140bbd407ec969ff73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a60a3191b19596140bbd407ec969ff73b">More...</a><br /></td></tr>
<tr class="separator:a60a3191b19596140bbd407ec969ff73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae046954775af39f61e769ae5b60071be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae046954775af39f61e769ae5b60071be">empty</a> () const</td></tr>
<tr class="memdesc:ae046954775af39f61e769ae5b60071be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae046954775af39f61e769ae5b60071be">More...</a><br /></td></tr>
<tr class="separator:ae046954775af39f61e769ae5b60071be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d5c4bcda49bb5125d10048fe61303c"><td class="memItemLeft" align="right" valign="top">const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a64d5c4bcda49bb5125d10048fe61303c">get_allocator</a> () const</td></tr>
<tr class="memdesc:a64d5c4bcda49bb5125d10048fe61303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the allocator associated with the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a64d5c4bcda49bb5125d10048fe61303c">More...</a><br /></td></tr>
<tr class="separator:a64d5c4bcda49bb5125d10048fe61303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976eee6fade6c93a4b3a7850f0851e10"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a976eee6fade6c93a4b3a7850f0851e10">get_allocator</a> ()</td></tr>
<tr class="memdesc:a976eee6fade6c93a4b3a7850f0851e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the allocator associated with the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a976eee6fade6c93a4b3a7850f0851e10">More...</a><br /></td></tr>
<tr class="separator:a976eee6fade6c93a4b3a7850f0851e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9e74642157dc47d42291fa72b27215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a2c9e74642157dc47d42291fa72b27215">swap</a> (<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> &amp;other)</td></tr>
<tr class="memdesc:a2c9e74642157dc47d42291fa72b27215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other transactionally.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a2c9e74642157dc47d42291fa72b27215">More...</a><br /></td></tr>
<tr class="separator:a2c9e74642157dc47d42291fa72b27215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8e34898520a23c937dbd1e2dbbb5e7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7e8e34898520a23c937dbd1e2dbbb5e7">equal_range</a> (const key_type &amp;key)</td></tr>
<tr class="memdesc:a7e8e34898520a23c937dbd1e2dbbb5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a7e8e34898520a23c937dbd1e2dbbb5e7">More...</a><br /></td></tr>
<tr class="separator:a7e8e34898520a23c937dbd1e2dbbb5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fae8c656cdb87a1dd815c8a945794ea"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a1fae8c656cdb87a1dd815c8a945794ea">equal_range</a> (const key_type &amp;key) const</td></tr>
<tr class="memdesc:a1fae8c656cdb87a1dd815c8a945794ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a1fae8c656cdb87a1dd815c8a945794ea">More...</a><br /></td></tr>
<tr class="separator:a1fae8c656cdb87a1dd815c8a945794ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50deb4052d193265a3f15f232e7726f5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a50deb4052d193265a3f15f232e7726f5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a50deb4052d193265a3f15f232e7726f5">equal_range</a> (const K &amp;x)</td></tr>
<tr class="memdesc:a50deb4052d193265a3f15f232e7726f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a50deb4052d193265a3f15f232e7726f5">More...</a><br /></td></tr>
<tr class="separator:a50deb4052d193265a3f15f232e7726f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b10f661154ff06a430eaaf9a3c363e7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a8b10f661154ff06a430eaaf9a3c363e7"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8b10f661154ff06a430eaaf9a3c363e7">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a8b10f661154ff06a430eaaf9a3c363e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8b10f661154ff06a430eaaf9a3c363e7">More...</a><br /></td></tr>
<tr class="separator:a8b10f661154ff06a430eaaf9a3c363e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf1507edb172e6a1895552e29427fb7"><td class="memItemLeft" align="right" valign="top">const key_compare &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4cf1507edb172e6a1895552e29427fb7">key_comp</a> () const</td></tr>
<tr class="memdesc:a4cf1507edb172e6a1895552e29427fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the object that compares the keys.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4cf1507edb172e6a1895552e29427fb7">More...</a><br /></td></tr>
<tr class="separator:a4cf1507edb172e6a1895552e29427fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8323760f5061278a5c969888134c37a8"><td class="memItemLeft" align="right" valign="top">key_compare &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8323760f5061278a5c969888134c37a8">key_comp</a> ()</td></tr>
<tr class="memdesc:a8323760f5061278a5c969888134c37a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object that compares the keys.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8323760f5061278a5c969888134c37a8">More...</a><br /></td></tr>
<tr class="separator:a8323760f5061278a5c969888134c37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0e6add27cbb06843dcdffc087da74251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a0e6add27cbb06843dcdffc087da74251">check_tx_stage_work</a> () const</td></tr>
<tr class="memdesc:a0e6add27cbb06843dcdffc087da74251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a0e6add27cbb06843dcdffc087da74251">More...</a><br /></td></tr>
<tr class="separator:a0e6add27cbb06843dcdffc087da74251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedf9b88b9e8602c2219e21986309b7b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename pointer_type , typename comparator &gt; </td></tr>
<tr class="memitem:acedf9b88b9e8602c2219e21986309b7b"><td class="memTemplItemLeft" align="right" valign="top">persistent_node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#acedf9b88b9e8602c2219e21986309b7b">internal_find_position</a> (size_type level, pointer_type &amp;prev, const K &amp;key, const comparator &amp;cmp) const</td></tr>
<tr class="memdesc:acedf9b88b9e8602c2219e21986309b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds position on the.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#acedf9b88b9e8602c2219e21986309b7b">More...</a><br /></td></tr>
<tr class="separator:acedf9b88b9e8602c2219e21986309b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc68cda6170426f66ed2aaa67745f50b"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:afc68cda6170426f66ed2aaa67745f50b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#afc68cda6170426f66ed2aaa67745f50b">find_insert_pos</a> (prev_array_type &amp;prev_nodes, next_array_type &amp;next_nodes, const K &amp;key)</td></tr>
<tr class="memdesc:afc68cda6170426f66ed2aaa67745f50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method finds insert position for the given.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#afc68cda6170426f66ed2aaa67745f50b">More...</a><br /></td></tr>
<tr class="separator:afc68cda6170426f66ed2aaa67745f50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9a45ff580a1250f4e0c380b7a73e6e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename comparator &gt; </td></tr>
<tr class="memitem:ada9a45ff580a1250f4e0c380b7a73e6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ada9a45ff580a1250f4e0c380b7a73e6e">fill_prev_next_arrays</a> (prev_array_type &amp;prev_nodes, next_array_type &amp;next_nodes, const K &amp;key, const comparator &amp;cmp)</td></tr>
<tr class="memdesc:ada9a45ff580a1250f4e0c380b7a73e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method finds successor and predecessr nodes on each level of the skip list for the given.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ada9a45ff580a1250f4e0c380b7a73e6e">More...</a><br /></td></tr>
<tr class="separator:ada9a45ff580a1250f4e0c380b7a73e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e3dcd48725ec3f1b2964f5f4c0d2ca"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa8e3dcd48725ec3f1b2964f5f4c0d2ca"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa8e3dcd48725ec3f1b2964f5f4c0d2ca">internal_unsafe_emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa8e3dcd48725ec3f1b2964f5f4c0d2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not thread-safe but can be called within a transaction.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa8e3dcd48725ec3f1b2964f5f4c0d2ca">More...</a><br /></td></tr>
<tr class="separator:aa8e3dcd48725ec3f1b2964f5f4c0d2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836ab04126a11b12d45bd12b8272e59d"><td class="memTemplParams" colspan="2"><a id="a836ab04126a11b12d45bd12b8272e59d"></a>
template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a836ab04126a11b12d45bd12b8272e59d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a836ab04126a11b12d45bd12b8272e59d">internal_insert</a> (const K &amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a836ab04126a11b12d45bd12b8272e59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert new node to the skip list in a thread-safe way. <br /></td></tr>
<tr class="separator:a836ab04126a11b12d45bd12b8272e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e290cbb037bef111408a033b0728b02"><td class="memTemplParams" colspan="2"><a id="a3e290cbb037bef111408a033b0728b02"></a>
template&lt;typename K , typename PrepareNode &gt; </td></tr>
<tr class="memitem:a3e290cbb037bef111408a033b0728b02"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e290cbb037bef111408a033b0728b02">internal_insert_node</a> (const K &amp;key, size_type height, PrepareNode &amp;&amp;prepare_new_node)</td></tr>
<tr class="memdesc:a3e290cbb037bef111408a033b0728b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to insert new node to the skip list in a thread-safe way. <br /></td></tr>
<tr class="separator:a3e290cbb037bef111408a033b0728b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dea52fdc48f3544f1a4e8b35308ecd"><td class="memTemplParams" colspan="2">template&lt;typename PrepareNode &gt; </td></tr>
<tr class="memitem:ad3dea52fdc48f3544f1a4e8b35308ecd"><td class="memTemplItemLeft" align="right" valign="top">node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ad3dea52fdc48f3544f1a4e8b35308ecd">try_insert_node</a> (prev_array_type &amp;prev_nodes, const next_array_type &amp;next_nodes, size_type height, PrepareNode &amp;&amp;prepare_new_node)</td></tr>
<tr class="memdesc:ad3dea52fdc48f3544f1a4e8b35308ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to insert new node to the skip list.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ad3dea52fdc48f3544f1a4e8b35308ecd">More...</a><br /></td></tr>
<tr class="separator:ad3dea52fdc48f3544f1a4e8b35308ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4810e3642b3c6be0274d6a19f34193c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4810e3642b3c6be0274d6a19f34193c0">check_prev_array</a> (const prev_array_type &amp;prevs, size_type height)</td></tr>
<tr class="memdesc:a4810e3642b3c6be0274d6a19f34193c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used only inside asserts.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4810e3642b3c6be0274d6a19f34193c0">More...</a><br /></td></tr>
<tr class="separator:a4810e3642b3c6be0274d6a19f34193c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080f8c3974f366c13d183cde99ebb7cb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename comparator &gt; </td></tr>
<tr class="memitem:a080f8c3974f366c13d183cde99ebb7cb"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a080f8c3974f366c13d183cde99ebb7cb">internal_get_bound</a> (const K &amp;key, const comparator &amp;cmp) const</td></tr>
<tr class="memdesc:a080f8c3974f366c13d183cde99ebb7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element from the list for which cmp(element, key) is false.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a080f8c3974f366c13d183cde99ebb7cb">More...</a><br /></td></tr>
<tr class="separator:a080f8c3974f366c13d183cde99ebb7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ea96e8b9d72d140c64bd1aaf1c5531"><td class="memTemplParams" colspan="2">template&lt;typename K , typename comparator &gt; </td></tr>
<tr class="memitem:a08ea96e8b9d72d140c64bd1aaf1c5531"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a08ea96e8b9d72d140c64bd1aaf1c5531">internal_get_bound</a> (const K &amp;key, const comparator &amp;cmp)</td></tr>
<tr class="memdesc:a08ea96e8b9d72d140c64bd1aaf1c5531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element from the list for which cmp(element, key) is false.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a08ea96e8b9d72d140c64bd1aaf1c5531">More...</a><br /></td></tr>
<tr class="separator:a08ea96e8b9d72d140c64bd1aaf1c5531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdca0808a03d59470e309c3d42319ac"><td class="memItemLeft" align="right" valign="top">std::pair&lt; persistent_node_ptr, persistent_node_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a9bdca0808a03d59470e309c3d42319ac">internal_extract</a> (const_iterator it)</td></tr>
<tr class="separator:a9bdca0808a03d59470e309c3d42319ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd012db9c1bbfd69cb04cc81d77564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aacfd012db9c1bbfd69cb04cc81d77564">get_pool_base</a> () const</td></tr>
<tr class="memdesc:aacfd012db9c1bbfd69cb04cc81d77564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the persistent memory pool where hashmap resides.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aacfd012db9c1bbfd69cb04cc81d77564">More...</a><br /></td></tr>
<tr class="separator:aacfd012db9c1bbfd69cb04cc81d77564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a500ba9a4e67dc7e81423c38a4ba43"><td class="memItemLeft" align="right" valign="top"><a id="ac5a500ba9a4e67dc7e81423c38a4ba43"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac5a500ba9a4e67dc7e81423c38a4ba43">random_level</a> ()</td></tr>
<tr class="memdesc:ac5a500ba9a4e67dc7e81423c38a4ba43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random level. <br /></td></tr>
<tr class="separator:ac5a500ba9a4e67dc7e81423c38a4ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca89db7d91286b69dff4b242a519945"><td class="memTemplParams" colspan="2"><a id="a0ca89db7d91286b69dff4b242a519945"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0ca89db7d91286b69dff4b242a519945"><td class="memTemplItemLeft" align="right" valign="top">persistent_node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a0ca89db7d91286b69dff4b242a519945">create_node</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0ca89db7d91286b69dff4b242a519945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new node. <br /></td></tr>
<tr class="separator:a0ca89db7d91286b69dff4b242a519945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad65a2ba32ea7c275dc0c65c368b385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8ad65a2ba32ea7c275dc0c65c368b385">create_dummy_head</a> ()</td></tr>
<tr class="memdesc:a8ad65a2ba32ea7c275dc0c65c368b385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates dummy head.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#a8ad65a2ba32ea7c275dc0c65c368b385">More...</a><br /></td></tr>
<tr class="separator:a8ad65a2ba32ea7c275dc0c65c368b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2593256a87c1dc863962f57b4da0b2c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac2593256a87c1dc863962f57b4da0b2c"><td class="memTemplItemLeft" align="right" valign="top">persistent_node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac2593256a87c1dc863962f57b4da0b2c">creates_dummy_node</a> (size_type height, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac2593256a87c1dc863962f57b4da0b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new node, value_type should be constructed separately.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac2593256a87c1dc863962f57b4da0b2c">More...</a><br /></td></tr>
<tr class="separator:ac2593256a87c1dc863962f57b4da0b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7ecb3b94325da4ab98af89af79799e"><td class="memItemLeft" align="right" valign="top"><a id="a6f7ecb3b94325da4ab98af89af79799e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a6f7ecb3b94325da4ab98af89af79799e">tls_restore</a> ()</td></tr>
<tr class="memdesc:a6f7ecb3b94325da4ab98af89af79799e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any information which was saved to tls and clears tls. <br /></td></tr>
<tr class="separator:a6f7ecb3b94325da4ab98af89af79799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa5de4a38ce837e21f0bfca796142fadc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">obj::p</a>&lt; size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa5de4a38ce837e21f0bfca796142fadc">on_init_size</a></td></tr>
<tr class="memdesc:aa5de4a38ce837e21f0bfca796142fadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable holds real size after the skip list is initialized.  <a href="classpmem_1_1detail_1_1concurrent__skip__list.html#aa5de4a38ce837e21f0bfca796142fadc">More...</a><br /></td></tr>
<tr class="separator:aa5de4a38ce837e21f0bfca796142fadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Traits&gt;<br />
class pmem::detail::concurrent_skip_list&lt; Traits &gt;</h3>

<p>Persistent memory aware implementation of the concurrent skip list. </p>
<p>The implementation is based on the lock-based concurrent skip list algorithm described in <a href="https://www.cs.tau.ac.il/~shanir/nir-pubs-web/Papers/OPODIS2006-BA.pdf">https://www.cs.tau.ac.il/~shanir/nir-pubs-web/Papers/OPODIS2006-BA.pdf</a>.</p>
<p>Our concurrent skip list implementation supports concurrent insertion and traversal, but not concurrent erasure. The erase method is prefixed with unsafe_, to indicate that there is no concurrency safety.</p>
<p>Each time, the pool with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> is being opened, the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> requires <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ac1ead701625a419d46f4592e88bbf6af" title="Intialize concurrent_skip_list after process restart.">runtime_initialize()</a> to be called in order to restore the state after process restart.</p>
<p>Traits template parameter allows to specify properties of the concurrent_ski_list. The Traits type should has the following member types:</p><ul>
<li>key_type - type of the key</li>
<li>mapped_type - type of the mapped_value</li>
<li>value_type - type of the value stored inside the skip list node (e.g. pair&lt;const key_type, mapped_type&gt;).</li>
<li>compare_type - The comparison functor used to sort elements in the skip list.</li>
<li>allocator_type - The type of allocator used by the skip list.</li>
<li>max_level - The constant value which specify the number of layers in the skip list.</li>
<li>random_generator_type - The type of random generator used by the skip list. It should be thread-safe. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a584560a7186d5d8b6bda1f849921df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a584560a7186d5d8b6bda1f849921df">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Construct empty skip list.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a751b1925506cb312d459a9f045edc88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751b1925506cb312d459a9f045edc88f">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramtype">const key_compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison function object to use for all comparisons of keys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for inserted elements in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98469541d7990b8a5f6200da8eef6e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98469541d7990b8a5f6200da8eef6e37">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>key_compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>If multiple elements in the range have keys that compare equivalent, the first element is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison function object to use for all comparisons of keys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<p>InputIt must meet the requirements of LegacyInputIterator.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for inserted elements in transaction failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8124cbb5057bb8203c29c5a0039a78e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8124cbb5057bb8203c29c5a0039a78e8">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff" title="Returns the number of elements in the container, i.e.">size()</a> == other.size()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for copied elements in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2820af7de7052245e993dd8549abc65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2820af7de7052245e993dd8549abc65b">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff" title="Returns the number of elements in the container, i.e.">size()</a> == other.size()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for copied elements in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4eae361baf98dd2b0ca4554c955559b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eae361baf98dd2b0ca4554c955559b7">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff" title="Returns the number of elements in the container, i.e.">size()</a> == other.size()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for copied elements in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ac5792b79b8d661b13d9caf24603ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ac5792b79b8d661b13d9caf24603ef">&#9670;&nbsp;</a></span>concurrent_skip_list() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff" title="Returns the number of elements in the container, i.e.">size()</a> == other.size()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for copied elements in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3449d0457c698cf4cc0e8bb41aeab003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3449d0457c698cf4cc0e8bb41aeab003">&#9670;&nbsp;</a></span>~concurrent_skip_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::~<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>free_data should be called before <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> destructor is called. Otherwise, program can terminate if an exception occurs while freeing memory inside dtor.</p>
<p>The skip list map can NOT be used after <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#acb23bea4c5cd65f97e9708a9f6847621" title="Should be called before concurrent_skip_list destructor is called.">free_data()</a> was called (unless it was called in a transaction and that transaction aborted). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ad55d7ae8a1973e75b8142984235eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad55d7ae8a1973e75b8142984235eed">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a3fa4214acfb506f7b5ee5fb6abc26365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa4214acfb506f7b5ee5fb6abc26365">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a3dca3851b967fd4cce066d814a375a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dca3851b967fd4cce066d814a375a31">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a3574b8bb76170c7b2caf9b93e91ebffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3574b8bb76170c7b2caf9b93e91ebffa">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a4810e3642b3c6be0274d6a19f34193c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4810e3642b3c6be0274d6a19f34193c0">&#9670;&nbsp;</a></span>check_prev_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::check_prev_array </td>
          <td>(</td>
          <td class="paramtype">const prev_array_type &amp;&#160;</td>
          <td class="paramname"><em>prevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used only inside asserts. </p>
<p>Checks that prev_array is filled with correct values. </p>

</div>
</div>
<a id="a0e6add27cbb06843dcdffc087da74251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6add27cbb06843dcdffc087da74251">&#9670;&nbsp;</a></span>check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::check_tx_stage_work </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if current transaction stage is equal to TX_STAGE_WORK and throws an exception otherwise.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if current transaction stage is not equal to TX_STAGE_WORK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3794b5214e8bab05762329d909ca258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3794b5214e8bab05762329d909ca258">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff" title="Returns the number of elements in the container, i.e.">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d4d7504452f1b6990993db6ad487e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4d7504452f1b6990993db6ad487e86">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key that compares equivalent to the value x. </p>
<p>This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>a value of any type that can be transparently compared with a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is such an element, otherwise false. </dd></dl>

</div>
</div>
<a id="a07f6fc748b3e3cc93f101270eeb56562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f6fc748b3e3cc93f101270eeb56562">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key equivalent to key in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is such an element, otherwise false. </dd></dl>

</div>
</div>
<a id="a7d49d6ba2ca744a9d6fa05f3fb92f3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d49d6ba2ca744a9d6fa05f3fb92f3d8">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument. </p>
<p>This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>alternative value to compare to the keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to the specified argument. </dd></dl>

</div>
</div>
<a id="ac2bc13511e419c74cf472c0ea500f9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bc13511e419c74cf472c0ea500f9e9">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the element to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to the specified argument. </dd></dl>

</div>
</div>
<a id="a8ad65a2ba32ea7c275dc0c65c368b385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad65a2ba32ea7c275dc0c65c368b385">&#9670;&nbsp;</a></span>create_dummy_head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::create_dummy_head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates dummy head. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Always called from ctor. </dd></dl>

</div>
</div>
<a id="ac2593256a87c1dc863962f57b4da0b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2593256a87c1dc863962f57b4da0b2c">&#9670;&nbsp;</a></span>creates_dummy_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">persistent_node_ptr <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::creates_dummy_node </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new node, value_type should be constructed separately. </p>
<p>Each node object has different size which depends on number of layers the node is linked. In this method we calculate the size of the new node based on the node height. Then required amount of bytes are allcoated and casted to the persistent_node_ptr.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Should be called inside transaction. </dd></dl>

</div>
</div>
<a id="a397dcf122ef8b9b8b28f459a54031d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397dcf122ef8b9b8b28f459a54031d4c">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. </p>
<p>Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair&lt;const Key, T&gt;) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab806470149461716d40fcf69e579c54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806470149461716d40fcf69e579c54f">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element to the container as close as possible to the position just before hint. </p>
<p>The element is constructed in-place, i.e. no copy or move operations are performed.</p>
<p>The constructor of the element type (value_type, that is, std::pair&lt;const Key, T&gt;) is called with exactly the same arguments as supplied to the function, forwarded with std::forward&lt;Args&gt;(args)...</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the newly inserted element.</dd></dl>
<p>If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the inserted element, or to the element that prevented the insertion.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae046954775af39f61e769ae5b60071be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae046954775af39f61e769ae5b60071be">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. </p>
<p>whether <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4ad55d7ae8a1973e75b8142984235eed" title="Returns an iterator to the first element of the container.">begin()</a> == <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a910dcecf8afddfc4144b2c0df13abd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910dcecf8afddfc4144b2c0df13abd01">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="aa9b1ff228b6d31d473a070e5ae76f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b1ff228b6d31d473a070e5ae76f638">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a8b10f661154ff06a430eaaf9a3c363e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b10f661154ff06a430eaaf9a3c363e7">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e97aa16c83e5a2c5c0f40c3935cd520" title="Returns an iterator pointing to the first element that is not less than (i.e.">lower_bound()</a>, and the second with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3da476e8cc35fc497d70a60a19e594f3" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.</p>
<p>Compares the keys to the value x. This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>alternative value that can be compared to Key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the wanted range: the first pointing to the first element that is not less than key and the second pointing to the first element greater than key. If there are no elements not less than key, past-the-end (see <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>) iterator is returned as the first element. Similarly if there are no elements greater than key, past-the-end iterator is returned as the second element. </dd></dl>

</div>
</div>
<a id="a50deb4052d193265a3f15f232e7726f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50deb4052d193265a3f15f232e7726f5">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, iterator&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e97aa16c83e5a2c5c0f40c3935cd520" title="Returns an iterator pointing to the first element that is not less than (i.e.">lower_bound()</a>, and the second with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3da476e8cc35fc497d70a60a19e594f3" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.</p>
<p>Compares the keys to the value x. This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>alternative value that can be compared to Key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the wanted range: the first pointing to the first element that is not less than key and the second pointing to the first element greater than key. If there are no elements not less than key, past-the-end (see <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>) iterator is returned as the first element. Similarly if there are no elements greater than key, past-the-end iterator is returned as the second element. </dd></dl>

</div>
</div>
<a id="a7e8e34898520a23c937dbd1e2dbbb5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8e34898520a23c937dbd1e2dbbb5e7">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, iterator&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e97aa16c83e5a2c5c0f40c3935cd520" title="Returns an iterator pointing to the first element that is not less than (i.e.">lower_bound()</a>, and the second with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3da476e8cc35fc497d70a60a19e594f3" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.</p>
<p>Compares the keys to key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the wanted range: the first pointing to the first element that is not less than key and the second pointing to the first element greater than key. If there are no elements not less than key, past-the-end (see <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>) iterator is returned as the first element. Similarly if there are no elements greater than key, past-the-end iterator is returned as the second element. </dd></dl>

</div>
</div>
<a id="a1fae8c656cdb87a1dd815c8a945794ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fae8c656cdb87a1dd815c8a945794ea">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3e97aa16c83e5a2c5c0f40c3935cd520" title="Returns an iterator pointing to the first element that is not less than (i.e.">lower_bound()</a>, and the second with <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a3da476e8cc35fc497d70a60a19e594f3" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.</p>
<p>Compares the keys to key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the wanted range: the first pointing to the first element that is not less than key and the second pointing to the first element greater than key. If there are no elements not less than key, past-the-end (see <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>) iterator is returned as the first element. Similarly if there are no elements greater than key, past-the-end iterator is returned as the second element. </dd></dl>

</div>
</div>
<a id="ada9a45ff580a1250f4e0c380b7a73e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9a45ff580a1250f4e0c380b7a73e6e">&#9670;&nbsp;</a></span>fill_prev_next_arrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::fill_prev_next_arrays </td>
          <td>(</td>
          <td class="paramtype">prev_array_type &amp;&#160;</td>
          <td class="paramname"><em>prev_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">next_array_type &amp;&#160;</td>
          <td class="paramname"><em>next_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comparator &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method finds successor and predecessr nodes on each level of the skip list for the given. </p>
<ul>
<li>key.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_nodes</td><td>array of pointers to predecessor nodes on each level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_nodes</td><td>array of pointers to successor nodes on each level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>inserted key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparator functor used for the search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4b414ba69315d80ce7ed39354af8ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b414ba69315d80ce7ed39354af8ed2">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value x. </p>
<p>This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>a value of any type that can be transparently compared with a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a33565af7168c79a33ed2707e303973be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33565af7168c79a33ed2707e303973be">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value x. </p>
<p>This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. It allows calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>a value of any type that can be transparently compared with a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a91107b1c17399ee3db02b08d3e272523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91107b1c17399ee3db02b08d3e272523">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a91f6033d2832d7c8a5395c9a985c4481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f6033d2832d7c8a5395c9a985c4481">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="afc68cda6170426f66ed2aaa67745f50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc68cda6170426f66ed2aaa67745f50b">&#9670;&nbsp;</a></span>find_insert_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::find_insert_pos </td>
          <td>(</td>
          <td class="paramtype">prev_array_type &amp;&#160;</td>
          <td class="paramname"><em>prev_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">next_array_type &amp;&#160;</td>
          <td class="paramname"><em>next_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method finds insert position for the given. </p>
<ul>
<li>key. It finds successor and predecessr nodes on each level of the skip list.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_nodes</td><td>array of pointers to predecessor nodes on each level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_nodes</td><td>array of pointers to successor nodes on each level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>inserted key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb23bea4c5cd65f97e9708a9f6847621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb23bea4c5cd65f97e9708a9f6847621">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should be called before <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> destructor is called. </p>
<p>Otherwise, program can terminate if an exception occurs while freeing memory inside dtor.</p>
<p>The skip list map can NOT be used after <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#acb23bea4c5cd65f97e9708a9f6847621" title="Should be called before concurrent_skip_list destructor is called.">free_data()</a> was called (unless it was called in a transaction and that transaction aborted).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::transaction_error</td><td>in case of PMDK transaction failure </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing underlying memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976eee6fade6c93a4b3a7850f0851e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976eee6fade6c93a4b3a7850f0851e10">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the associated allocator. </dd></dl>

</div>
</div>
<a id="a64d5c4bcda49bb5125d10048fe61303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d5c4bcda49bb5125d10048fe61303c">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const allocator_type&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the associated allocator. </dd></dl>

</div>
</div>
<a id="aacfd012db9c1bbfd69cb04cc81d77564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfd012db9c1bbfd69cb04cc81d77564">&#9670;&nbsp;</a></span>get_pool_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a> <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::get_pool_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the persistent memory pool where hashmap resides. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pmem::obj::pool_base</a> object. </dd></dl>

</div>
</div>
<a id="a9cdeb36f2617cde6e05dfcc97058b868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdeb36f2617cde6e05dfcc97058b868">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value in a thread-safe way. </p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7011ac4ac2c996895033d17ebbac1972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7011ac4ac2c996895033d17ebbac1972">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value in the position as close as possible, just prior to hint. </p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the inserted element, or to the element that prevented the insertion.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aa54447a3d2cbf27bed78272f919915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa54447a3d2cbf27bed78272f919915">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp; &gt;::value &gt;::type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value in the position as close as possible, just prior to hint. </p>
<p>No iterators or references are invalidated. This overload is equivalent to emplace_hint(hint, std::forward&lt;P&gt;(value)) and only participates in overload resolution if std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the inserted element, or to the element that prevented the insertion.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c7451afd50012693e465c60099e2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c7451afd50012693e465c60099e2ec">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). </p>
<p>If multiple elements in the range have keys that compare equivalent, the first one is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator of inserted range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a264928915cee8f7602a84feb14e22e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264928915cee8f7602a84feb14e22e1b">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename P , typename std::enable_if&lt; std::is_constructible&lt; value_type, P &amp;&amp; &gt;::value &gt;::type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value. </p>
<p>No iterators or references are invalidated. This overload is equivalent to emplace(std::forward&lt;P&gt;(value)) and only participates in overload resolution if std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae92942fa69d742306d29c4a0c9932354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92942fa69d742306d29c4a0c9932354">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist. </p>
<p>If multiple elements in the range have keys that compare equivalent, the first one is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>first initializer list to insert the values from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af62482ff535491db93f2773b7957221d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62482ff535491db93f2773b7957221d">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value using move semantic. </p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bdca0808a03d59470e309c3d42319ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdca0808a03d59470e309c3d42319ac">&#9670;&nbsp;</a></span>internal_extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;persistent_node_ptr, persistent_node_ptr&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::internal_extract </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to extracted node and a pointer to next node </dd></dl>

</div>
</div>
<a id="acedf9b88b9e8602c2219e21986309b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedf9b88b9e8602c2219e21986309b7b">&#9670;&nbsp;</a></span>internal_find_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename pointer_type , typename comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">persistent_node_ptr <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::internal_find_position </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pointer_type &amp;&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comparator &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds position on the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>using</td></tr>
    <tr><td class="paramname">cmp</td><td></td></tr>
    <tr><td class="paramname">level</td><td>- on which level search prev node </td></tr>
    <tr><td class="paramname">prev</td><td>- pointer to the start node to search </td></tr>
    <tr><td class="paramname">key</td><td>- key to search </td></tr>
    <tr><td class="paramname">cmp</td><td>- callable object to compare two objects (_compare member is default comparator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the node which is not satisfy the comparison with </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ea96e8b9d72d140c64bd1aaf1c5531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ea96e8b9d72d140c64bd1aaf1c5531">&#9670;&nbsp;</a></span>internal_get_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::internal_get_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comparator &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element from the list for which cmp(element, key) is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparator functor used for the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element for which cmp(element, key) is false. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a080f8c3974f366c13d183cde99ebb7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080f8c3974f366c13d183cde99ebb7cb">&#9670;&nbsp;</a></span>internal_get_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename comparator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::internal_get_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comparator &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element from the list for which cmp(element, key) is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>comparator functor used for the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element for which cmp(element, key) is false. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="aa8e3dcd48725ec3f1b2964f5f4c0d2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e3dcd48725ec3f1b2964f5f4c0d2ca">&#9670;&nbsp;</a></span>internal_unsafe_emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::internal_unsafe_emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not thread-safe but can be called within a transaction. </p>
<p>XXX: Need to optimize for single-threaded case. </p>

</div>
</div>
<a id="a8323760f5061278a5c969888134c37a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8323760f5061278a5c969888134c37a8">&#9670;&nbsp;</a></span>key_comp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">key_compare&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object that compares the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the key comparison function object. </dd></dl>

</div>
</div>
<a id="a4cf1507edb172e6a1895552e29427fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf1507edb172e6a1895552e29427fb7">&#9670;&nbsp;</a></span>key_comp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const key_compare&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the object that compares the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the key comparison function object. </dd></dl>

</div>
</div>
<a id="a953e591abc97e924172053c323911f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953e591abc97e924172053c323911f7b">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares not less (i.e. </p>
<p>greater or equal) to the value x. This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>alternative value that can be compared to Key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ac9f895b664a9115a2bf252fe5b4f1fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f895b664a9115a2bf252fe5b4f1fbb">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares not less (i.e. </p>
<p>greater or equal) to the value x. This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>alternative value that can be compared to Key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a3e97aa16c83e5a2c5c0f40c3935cd520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e97aa16c83e5a2c5c0f40c3935cd520">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a18d5b68ce347b64f50752c768d3c1644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d5b68ce347b64f50752c768d3c1644">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a60a3191b19596140bbd407ec969ff73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a3191b19596140bbd407ec969ff73b">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. </p>
<p>std::distance(<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4ad55d7ae8a1973e75b8142984235eed" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>) for the largest container.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a id="ab5dc6802e7cbc6ec92e280019f7068dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dc6802e7cbc6ec92e280019f7068dc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. If std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value is true, the target allocator is replaced by a copy of the source allocator. If it is false and the source and the target allocators do not compare equal, the target cannot take ownership of the source memory and must move-assign each element individually, allocating additional memory using its own allocator as needed. In any case, all elements originally present in *this are either destroyed or replaced by elementwise move-assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old existing elements failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cc9be9e3ac76caf18bdaa15bbc1c8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc9be9e3ac76caf18bdaa15bbc1c8c7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of other transactionally. If std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value is true, the target allocator is replaced by a copy of the source allocator.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#ae3b0431150249293ef47de210d2c21ff" title="Returns the number of elements in the container, i.e.">size()</a> == other.size()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old existing elements failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a961aec86879c4a85eb82464da68eb05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961aec86879c4a85eb82464da68eb05a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&amp; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list il. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer list to use as data source</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old existing elements failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1ead701625a419d46f4592e88bbf6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ead701625a419d46f4592e88bbf6af">&#9670;&nbsp;</a></span>runtime_initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::runtime_initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intialize <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html" title="Persistent memory aware implementation of the concurrent skip list.">concurrent_skip_list</a> after process restart. </p>
<p>MUST be called everytime after process restart. Not thread safe. </p>

</div>
</div>
<a id="ae3b0431150249293ef47de210d2c21ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b0431150249293ef47de210d2c21ff">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. </p>
<p>std::distance(<a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a4ad55d7ae8a1973e75b8142984235eed" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="a2c9e74642157dc47d42291fa72b27215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9e74642157dc47d42291fa72b27215">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">concurrent_skip_list</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other transactionally. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd7c482dc978e488e306d5dc6fcd14fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c482dc978e488e306d5dc6fcd14fa">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a731a846634822804cf6880ddfbd75674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731a846634822804cf6880ddfbd75674">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; has_is_transparent&lt;key_compare&gt;::value &amp;&amp; std::is_constructible&lt;key_type, K &amp;&amp;&gt;::value, std::pair&lt;iterator, bool&gt; &gt;::type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)). This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type and std::is_constructible&lt;Key, K &amp;&amp;&gt;::value == true . It allows calling this function without constructing an instance of Key.</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad614034918785ab4e003cbe2142c2282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad614034918785ab4e003cbe2142c2282">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)).</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if called inside transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3dea52fdc48f3544f1a4e8b35308ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dea52fdc48f3544f1a4e8b35308ecd">&#9670;&nbsp;</a></span>try_insert_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename PrepareNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::try_insert_node </td>
          <td>(</td>
          <td class="paramtype">prev_array_type &amp;&#160;</td>
          <td class="paramname"><em>prev_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const next_array_type &amp;&#160;</td>
          <td class="paramname"><em>next_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrepareNode &amp;&amp;&#160;</td>
          <td class="paramname"><em>prepare_new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to insert new node to the skip list. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new node if it was inserted. Otherwise, returns nullptr. </dd></dl>

</div>
</div>
<a id="a7ed01e6a61410cc886a8ab406b7a4518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed01e6a61410cc886a8ab406b7a4518">&#9670;&nbsp;</a></span>unsafe_erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			has_is_transparent&lt;key_compare&gt;::value &amp;&amp;				!std::is_convertible&lt;K, iterator&gt;::value &amp;&amp;				!std::is_convertible&lt;K, const_iterator&gt;::value,			K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::unsafe_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected. This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type and std::is_convertible&lt;K, iterator&gt;::value != true &amp;&amp; std::is_convertible&lt;K, const_iterator&gt;::value != true. It allows calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6214064458c8e1233d20791147b21c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6214064458c8e1233d20791147b21c9">&#9670;&nbsp;</a></span>unsafe_erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::unsafe_erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value of the elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea9ab4327934dc1f8eb6fccd0f0fc01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9ab4327934dc1f8eb6fccd0f0fc01c">&#9670;&nbsp;</a></span>unsafe_erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::unsafe_erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first; last), which must be a valid range in *this. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator in the range of elements to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator in the range of elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2d1efd461bdbe61a097b342c565a249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d1efd461bdbe61a097b342c565a249">&#9670;&nbsp;</a></span>unsafe_erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::unsafe_erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos from the container. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the element to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acacf1ffa9af826b7aa6d690cd2d0fb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacf1ffa9af826b7aa6d690cd2d0fb13">&#9670;&nbsp;</a></span>unsafe_erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::unsafe_erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos from the container. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html#a910dcecf8afddfc4144b2c0df13abd01" title="Returns an iterator to the element following the last element of the map.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the element to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0d7d6cd7a863ea75a9150136cb4c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0d7d6cd7a863ea75a9150136cb4c0a">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares greater to the value x. </p>
<p>This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>alternative value that can be compared to Key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ad5ac21642d5dbdff2764d243038f7b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ac21642d5dbdff2764d243038f7b2e">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename  = typename std::enable_if&lt;			  has_is_transparent&lt;key_compare&gt;::value, K&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that compares greater to the value x. </p>
<p>This overload only participates in overload resolution if the qualified-id Compare::is_transparent is valid and denotes a type. They allow calling this function without constructing an instance of Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>alternative value that can be compared to Key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a3da476e8cc35fc497d70a60a19e594f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da476e8cc35fc497d70a60a19e594f3">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ae3f8cbc4421f7fcfe3e411bacfa3ee29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f8cbc4421f7fcfe3e411bacfa3ee29">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa5de4a38ce837e21f0bfca796142fadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5de4a38ce837e21f0bfca796142fadc">&#9670;&nbsp;</a></span>on_init_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1p.html">obj::p</a>&lt;size_type&gt; <a class="el" href="classpmem_1_1detail_1_1concurrent__skip__list.html">pmem::detail::concurrent_skip_list</a>&lt; Traits &gt;::on_init_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This variable holds real size after the skip list is initialized. </p>
<p>It holds real value of size only after initialization (before any insert/remove). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/container/detail/<a class="el" href="concurrent__skip__list__impl_8hpp_source.html">concurrent_skip_list_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
