<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::detail::transaction_base&lt; is_flat &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.12-git50.g5401d486</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html">transaction_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classpmem_1_1detail_1_1transaction__base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::detail::transaction_base&lt; is_flat &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common functionality for basic_transaction and flat_transaction.  
 <a href="classpmem_1_1detail_1_1transaction__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transaction_8hpp_source.html">libpmemobj++/transaction.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1detail_1_1transaction__base_1_1tx__data.html">tx_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data is stored along with the pmemobj transaction data using pmemobj_tx_set_data().  <a href="structpmem_1_1detail_1_1transaction__base_1_1tx__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1e4345317108f070b1917aeb58d4c51d"><td class="memItemLeft" align="right" valign="top"><a id="a1e4345317108f070b1917aeb58d4c51d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">stage</a> </td></tr>
<tr class="memdesc:a1e4345317108f070b1917aeb58d4c51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible stages of a transaction, for every stage one or more callbacks can be registered. <br /></td></tr>
<tr class="separator:a1e4345317108f070b1917aeb58d4c51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4aae50c8d4260ae810319d7390cc57c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a4aae50c8d4260ae810319d7390cc57c4">~transaction_base</a> () noexcept=delete</td></tr>
<tr class="memdesc:a4aae50c8d4260ae810319d7390cc57c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classpmem_1_1detail_1_1transaction__base.html#a4aae50c8d4260ae810319d7390cc57c4">More...</a><br /></td></tr>
<tr class="separator:a4aae50c8d4260ae810319d7390cc57c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc3bcf42e4b82b444a2e3a5a21d4ef8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#afc3bcf42e4b82b444a2e3a5a21d4ef8c">abort</a> (int err)</td></tr>
<tr class="memdesc:afc3bcf42e4b82b444a2e3a5a21d4ef8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually abort the current transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#afc3bcf42e4b82b444a2e3a5a21d4ef8c">More...</a><br /></td></tr>
<tr class="separator:afc3bcf42e4b82b444a2e3a5a21d4ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c0d86f943d6727e1caa7573cc83edb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">commit</a> ()</td></tr>
<tr class="memdesc:a16c0d86f943d6727e1caa7573cc83edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually commit a transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">More...</a><br /></td></tr>
<tr class="separator:a16c0d86f943d6727e1caa7573cc83edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1950241b0a503c2ce0628ec03e99f0"><td class="memTemplParams" colspan="2">template&lt;typename... Locks&gt; </td></tr>
<tr class="memitem:ada1950241b0a503c2ce0628ec03e99f0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#ada1950241b0a503c2ce0628ec03e99f0">run</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a> &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</td></tr>
<tr class="memdesc:ada1950241b0a503c2ce0628ec03e99f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a closure-like transaction and lock <code>locks</code>.  <a href="classpmem_1_1detail_1_1transaction__base.html#ada1950241b0a503c2ce0628ec03e99f0">More...</a><br /></td></tr>
<tr class="separator:ada1950241b0a503c2ce0628ec03e99f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dffc5d7316f67f900e4cf8de8b6422"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::can_do_snapshot&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a63dffc5d7316f67f900e4cf8de8b6422"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a63dffc5d7316f67f900e4cf8de8b6422">snapshot</a> (const T *addr, size_t num=1)</td></tr>
<tr class="memdesc:a63dffc5d7316f67f900e4cf8de8b6422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a “snapshot” of given elements of type T number (1 by default), located at the given address ptr in the virtual memory space and saves it to the undo log.  <a href="classpmem_1_1detail_1_1transaction__base.html#a63dffc5d7316f67f900e4cf8de8b6422">More...</a><br /></td></tr>
<tr class="separator:a63dffc5d7316f67f900e4cf8de8b6422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd22aa1c4862fc4e1974e39fca7f3dfa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa">register_callback</a> (<a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">stage</a> stg, std::function&lt; void()&gt; cb)</td></tr>
<tr class="memdesc:abd22aa1c4862fc4e1974e39fca7f3dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers callback to be called on specified stage for the transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#abd22aa1c4862fc4e1974e39fca7f3dfa">More...</a><br /></td></tr>
<tr class="separator:abd22aa1c4862fc4e1974e39fca7f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a02fab7ddf4ecbd848f05ca0ba2a6f332"><td class="memTemplParams" colspan="2">template&lt;typename L , typename... Locks&gt; </td></tr>
<tr class="memitem:a02fab7ddf4ecbd848f05ca0ba2a6f332"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a02fab7ddf4ecbd848f05ca0ba2a6f332">add_lock</a> (L &amp;lock, Locks &amp;... locks) noexcept</td></tr>
<tr class="memdesc:a02fab7ddf4ecbd848f05ca0ba2a6f332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively add locks to the active transaction.  <a href="classpmem_1_1detail_1_1transaction__base.html#a02fab7ddf4ecbd848f05ca0ba2a6f332">More...</a><br /></td></tr>
<tr class="separator:a02fab7ddf4ecbd848f05ca0ba2a6f332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e96263c96a33f4a2c1a4d2e84ff6a2c"><td class="memItemLeft" align="right" valign="top"><a id="a9e96263c96a33f4a2c1a4d2e84ff6a2c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a9e96263c96a33f4a2c1a4d2e84ff6a2c">add_lock</a> () noexcept</td></tr>
<tr class="memdesc:a9e96263c96a33f4a2c1a4d2e84ff6a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method ending the recursive algorithm. <br /></td></tr>
<tr class="separator:a9e96263c96a33f4a2c1a4d2e84ff6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dd1b66ba94864009fcad24dccf2461"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#ae7dd1b66ba94864009fcad24dccf2461">c_callback</a> (PMEMobjpool *pop, enum pobj_tx_stage obj_stage, void *arg)</td></tr>
<tr class="memdesc:ae7dd1b66ba94864009fcad24dccf2461"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style function which is passed as callback to pmemobj_begin.  <a href="classpmem_1_1detail_1_1transaction__base.html#ae7dd1b66ba94864009fcad24dccf2461">More...</a><br /></td></tr>
<tr class="separator:ae7dd1b66ba94864009fcad24dccf2461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c81730099951642bf95882693e84829"><td class="memItemLeft" align="right" valign="top"><a id="a3c81730099951642bf95882693e84829"></a>
static <a class="el" href="structpmem_1_1detail_1_1transaction__base_1_1tx__data.html">tx_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a3c81730099951642bf95882693e84829">get_tx_data</a> ()</td></tr>
<tr class="memdesc:a3c81730099951642bf95882693e84829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tx user data from pmemobj or creates it if this is a first call to this function inside a transaction. <br /></td></tr>
<tr class="separator:a3c81730099951642bf95882693e84829"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;bool is_flat&gt;<br />
class pmem::detail::transaction_base&lt; is_flat &gt;</h3>

<p>Common functionality for basic_transaction and flat_transaction. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4aae50c8d4260ae810319d7390cc57c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aae50c8d4260ae810319d7390cc57c4">&#9670;&nbsp;</a></span>~transaction_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::~<a class="el" href="classpmem_1_1detail_1_1transaction__base.html">transaction_base</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>End pmemobj transaction. If the transaction has not been committed before object destruction, an abort will be issued. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc3bcf42e4b82b444a2e3a5a21d4ef8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3bcf42e4b82b444a2e3a5a21d4ef8c">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually abort the current transaction. </p>
<p>If called within an inner transaction, the outer transactions will also be aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>the error to be reported as the reason of the abort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>if the transaction is in an invalid state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class.">manual_tx_abort</a></td><td>this exception is thrown to signify a transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02fab7ddf4ecbd848f05ca0ba2a6f332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fab7ddf4ecbd848f05ca0ba2a6f332">&#9670;&nbsp;</a></span>add_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::add_lock </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively add locks to the active transaction. </p>
<p>The locks are taken in the provided order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>the lock to add. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>the rest of the locks to be added to the active transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number if adding any of the locks failed, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ae7dd1b66ba94864009fcad24dccf2461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dd1b66ba94864009fcad24dccf2461">&#9670;&nbsp;</a></span>c_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::c_callback </td>
          <td>(</td>
          <td class="paramtype">PMEMobjpool *&#160;</td>
          <td class="paramname"><em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pobj_tx_stage&#160;</td>
          <td class="paramname"><em>obj_stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C-style function which is passed as callback to pmemobj_begin. </p>
<p>It executes previously registered callbacks for all stages. </p>

</div>
</div>
<a id="a16c0d86f943d6727e1caa7573cc83edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c0d86f943d6727e1caa7573cc83edb">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually commit a transaction. </p>
<p>It is the sole responsibility of the caller, that after the call to transaction::commit() no other operations are done within the transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>on any errors with ending the transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd22aa1c4862fc4e1974e39fca7f3dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd22aa1c4862fc4e1974e39fca7f3dfa">&#9670;&nbsp;</a></span>register_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1transaction__base.html#a1e4345317108f070b1917aeb58d4c51d">stage</a>&#160;</td>
          <td class="paramname"><em>stg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers callback to be called on specified stage for the transaction. </p>
<p>In case of nested transactions those callbacks are called when the outer most transaction enters a specified stage.</p>
<dl class="section pre"><dt>Precondition</dt><dd>this function must be called during a transaction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>when called outside of a transaction scope</td></tr>
  </table>
  </dd>
</dl>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_callback_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> count;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> cb_called = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">auto</span> internal_tx_function = [&amp;] {</div>
<div class="line">        <span class="comment">/* callbacks can be registered even in inner transaction but</span></div>
<div class="line"><span class="comment">         * will be called when outer transaction ends */</span></div>
<div class="line">        transaction::run(pop, [&amp;] {</div>
<div class="line">            transaction::register_callback(</div>
<div class="line">                transaction::stage::oncommit,</div>
<div class="line">                [&amp;] { cb_called = <span class="keyword">true</span>; });</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* cb_called is false here if internal_tx_function is called</span></div>
<div class="line"><span class="comment">         * inside another transaction */</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        transaction::run(pop, [&amp;] { internal_tx_function(); });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* cb_called == true if transaction ended successfully */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* an internal transaction error occurred, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* some other exception thrown, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ada1950241b0a503c2ce0628ec03e99f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1950241b0a503c2ce0628ec03e99f0">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<div class="memtemplate">
template&lt;typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">obj::pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a closure-like transaction and lock <code>locks</code>. </p>
<p>The locks have to be persistent memory resident locks. An attempt to lock the locks will be made. If any of the specified locks is already locked, the method will block. The locks are held until the end of the transaction. The transaction does not have to be committed manually. Manual aborts will end the transaction with an active exception.</p>
<p>If an exception is thrown within the transaction, it gets aborted and the exception is rethrown. Therefore extra care has to be taken with proper error handling.</p>
<p>The locks are held for the entire duration of the transaction. They are released at the end of the scope, so within the <code>catch</code> block, they are already unlocked. If the cleanup action requires access to data within a critical section, the locks have to be manually acquired once again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool in which the transaction will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx</td><td>an std::function&lt;void ()&gt; which will perform operations within this transaction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>locks to be taken for the duration of the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>on any error pertaining the execution of the transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class.">manual_tx_abort</a></td><td>on manual transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63dffc5d7316f67f900e4cf8de8b6422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dffc5d7316f67f900e4cf8de8b6422">&#9670;&nbsp;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool is_flat&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::can_do_snapshot&lt; T &gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classpmem_1_1detail_1_1transaction__base.html">pmem::detail::transaction_base</a>&lt; is_flat &gt;::snapshot </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a “snapshot” of given elements of type T number (1 by default), located at the given address ptr in the virtual memory space and saves it to the undo log. </p>
<p>The application is then free to directly modify the object in that memory range. In case of a failure or abort, all the changes within this range will be rolled back. The supplied block of memory has to be within the pool registered in the transaction. This function must be called during transaction. This overload only participates in overload resolution of function template if T is either a trivially copyable type or some PMDK provided type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>pointer to the first object to be snapshotted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of elements to be snapshotted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must be called during transaction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when snapshotting failed or if function wasn't called during transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/<a class="el" href="transaction_8hpp_source.html">transaction.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1transaction__error_html"><div class="ttname"><a href="classpmem_1_1transaction__error.html">pmem::transaction_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:63</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1p_html"><div class="ttname"><a href="classpmem_1_1obj_1_1p.html">pmem::obj::p</a></div><div class="ttdoc">Resides on pmem class.</div><div class="ttdef"><b>Definition:</b> p.hpp:35</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">Persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a></div><div class="ttdoc">PMEMobj pool class.</div><div class="ttdef"><b>Definition:</b> pool.hpp:465</div></div>
<div class="ttc" id="apext_8hpp_html"><div class="ttname"><a href="pext_8hpp.html">pext.hpp</a></div><div class="ttdoc">Convenience extensions for the resides on pmem property template.</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
