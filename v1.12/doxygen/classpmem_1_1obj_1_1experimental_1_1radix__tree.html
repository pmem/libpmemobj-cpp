<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::radix_tree&lt; Key, Value, BytesView &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.12-git53.g67ba2be4</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1radix__tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::radix_tree&lt; Key, Value, BytesView &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Radix tree is an associative, ordered container.  
 <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="radix__tree_8hpp_source.html">libpmemobj++/experimental/radix_tree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1leaf.html">leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the structure which 'holds' key/value pair.  <a href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is internal node.  <a href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">radix_tree_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix tree iterator supports multipass and bidirectional iteration.  <a href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa84c847e4cb5099cf290a16768032219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa84c847e4cb5099cf290a16768032219">radix_tree</a> ()</td></tr>
<tr class="memdesc:aa84c847e4cb5099cf290a16768032219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default radix tree constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa84c847e4cb5099cf290a16768032219">More...</a><br /></td></tr>
<tr class="separator:aa84c847e4cb5099cf290a16768032219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674e72524d9ce939a316b6a884c716bf"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a674e72524d9ce939a316b6a884c716bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a674e72524d9ce939a316b6a884c716bf">radix_tree</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a674e72524d9ce939a316b6a884c716bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a674e72524d9ce939a316b6a884c716bf">More...</a><br /></td></tr>
<tr class="separator:a674e72524d9ce939a316b6a884c716bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc90bfeb1ff86b6e6d3bf2e424613f9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#afc90bfeb1ff86b6e6d3bf2e424613f9a">radix_tree</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;m)</td></tr>
<tr class="memdesc:afc90bfeb1ff86b6e6d3bf2e424613f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#afc90bfeb1ff86b6e6d3bf2e424613f9a">More...</a><br /></td></tr>
<tr class="separator:afc90bfeb1ff86b6e6d3bf2e424613f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34fc0eeb0b600e2583cf19f5e5dafde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab34fc0eeb0b600e2583cf19f5e5dafde">radix_tree</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:ab34fc0eeb0b600e2583cf19f5e5dafde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab34fc0eeb0b600e2583cf19f5e5dafde">More...</a><br /></td></tr>
<tr class="separator:ab34fc0eeb0b600e2583cf19f5e5dafde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c277216333ef5fd2a465982e60f293"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a93c277216333ef5fd2a465982e60f293">radix_tree</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a93c277216333ef5fd2a465982e60f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a93c277216333ef5fd2a465982e60f293">More...</a><br /></td></tr>
<tr class="separator:a93c277216333ef5fd2a465982e60f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41f35c1ca9da94aabecea54517437e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab41f35c1ca9da94aabecea54517437e3">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;m)</td></tr>
<tr class="memdesc:ab41f35c1ca9da94aabecea54517437e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab41f35c1ca9da94aabecea54517437e3">More...</a><br /></td></tr>
<tr class="separator:ab41f35c1ca9da94aabecea54517437e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7170673d1cafb1bb8cd2023294b9b848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a7170673d1cafb1bb8cd2023294b9b848">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:a7170673d1cafb1bb8cd2023294b9b848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a7170673d1cafb1bb8cd2023294b9b848">More...</a><br /></td></tr>
<tr class="separator:a7170673d1cafb1bb8cd2023294b9b848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f3b0590be38387ccda40c197a7a623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a08f3b0590be38387ccda40c197a7a623">operator=</a> (std::initializer_list&lt; value_type &gt; ilist)</td></tr>
<tr class="memdesc:a08f3b0590be38387ccda40c197a7a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a08f3b0590be38387ccda40c197a7a623">More...</a><br /></td></tr>
<tr class="separator:a08f3b0590be38387ccda40c197a7a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26397f14dc5bc26f5a287ae695db236"><td class="memItemLeft" align="right" valign="top"><a id="ab26397f14dc5bc26f5a287ae695db236"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab26397f14dc5bc26f5a287ae695db236">~radix_tree</a> ()</td></tr>
<tr class="memdesc:ab26397f14dc5bc26f5a287ae695db236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab26397f14dc5bc26f5a287ae695db236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1830a0fb058aa4cadaff71b9974308f7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1830a0fb058aa4cadaff71b9974308f7">insert</a> (const value_type &amp;<a class="el" href="classpmem_1_1obj_1_1experimental_1_1v.html">v</a>)</td></tr>
<tr class="memdesc:a1830a0fb058aa4cadaff71b9974308f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element if the tree doesn't already contain an element with an equivalent key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1830a0fb058aa4cadaff71b9974308f7">More...</a><br /></td></tr>
<tr class="separator:a1830a0fb058aa4cadaff71b9974308f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38ef81a5f9275091cdb7bce8a915d37"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa38ef81a5f9275091cdb7bce8a915d37">insert</a> (value_type &amp;&amp;<a class="el" href="classpmem_1_1obj_1_1experimental_1_1v.html">v</a>)</td></tr>
<tr class="memdesc:aa38ef81a5f9275091cdb7bce8a915d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element using move semantic if the tree doesn't already contain an element with an equivalent key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa38ef81a5f9275091cdb7bce8a915d37">More...</a><br /></td></tr>
<tr class="separator:aa38ef81a5f9275091cdb7bce8a915d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4193653098e1dd8cee03629a29135439"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a4193653098e1dd8cee03629a29135439"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4193653098e1dd8cee03629a29135439">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a4193653098e1dd8cee03629a29135439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last).  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4193653098e1dd8cee03629a29135439">More...</a><br /></td></tr>
<tr class="separator:a4193653098e1dd8cee03629a29135439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d127331fe82d643f02e5e41b7d0c607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2d127331fe82d643f02e5e41b7d0c607">insert</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a2d127331fe82d643f02e5e41b7d0c607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list il.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2d127331fe82d643f02e5e41b7d0c607">More...</a><br /></td></tr>
<tr class="separator:a2d127331fe82d643f02e5e41b7d0c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2f783b8ef49e75e6cdc8551a1fe32d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename BV  = BytesView, class... Args&gt; </td></tr>
<tr class="memitem:a7d2f783b8ef49e75e6cdc8551a1fe32d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a7d2f783b8ef49e75e6cdc8551a1fe32d">try_emplace</a> (K &amp;&amp;k, Args &amp;&amp;... args) -&gt; typename std::enable_if&lt; detail::has_is_transparent&lt; BV &gt;::value &amp;&amp;!std::is_same&lt; typename std::remove_const&lt; typename std::remove_reference&lt; K &gt;::type &gt;::type, key_type &gt;::value, std::pair&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&gt;::type</td></tr>
<tr class="memdesc:a7d2f783b8ef49e75e6cdc8551a1fe32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a7d2f783b8ef49e75e6cdc8551a1fe32d">More...</a><br /></td></tr>
<tr class="separator:a7d2f783b8ef49e75e6cdc8551a1fe32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea267a836da82a07fee930ff94f582b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acea267a836da82a07fee930ff94f582b">erase</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:acea267a836da82a07fee930ff94f582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos from the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acea267a836da82a07fee930ff94f582b">More...</a><br /></td></tr>
<tr class="separator:acea267a836da82a07fee930ff94f582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7264d3d4ad274fa781e903b6f3d3d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acc7264d3d4ad274fa781e903b6f3d3d7">erase</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> first, <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:acc7264d3d4ad274fa781e903b6f3d3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acc7264d3d4ad274fa781e903b6f3d3d7">More...</a><br /></td></tr>
<tr class="separator:acc7264d3d4ad274fa781e903b6f3d3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9434590ce9311b2b3399d4693ad682eb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9434590ce9311b2b3399d4693ad682eb">erase</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:a9434590ce9311b2b3399d4693ad682eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9434590ce9311b2b3399d4693ad682eb">More...</a><br /></td></tr>
<tr class="separator:a9434590ce9311b2b3399d4693ad682eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de5fe22140a6c880577427faf904fdd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  detail::has_is_transparent&lt;BytesView&gt;::value &amp;&amp;				  !std::is_same&lt;K, iterator&gt;::value &amp;&amp;				  !std::is_same&lt;K, const_iterator&gt;::value,			  K&gt;::type&gt; </td></tr>
<tr class="memitem:a1de5fe22140a6c880577427faf904fdd"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1de5fe22140a6c880577427faf904fdd">erase</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a1de5fe22140a6c880577427faf904fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1de5fe22140a6c880577427faf904fdd">More...</a><br /></td></tr>
<tr class="separator:a1de5fe22140a6c880577427faf904fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32845b930099664a1480674ec33c5c6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a32845b930099664a1480674ec33c5c6e">clear</a> ()</td></tr>
<tr class="memdesc:a32845b930099664a1480674ec33c5c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a32845b930099664a1480674ec33c5c6e">More...</a><br /></td></tr>
<tr class="separator:a32845b930099664a1480674ec33c5c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d4100d2c377e1fb8669644c01772a0"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae8d4100d2c377e1fb8669644c01772a0">count</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:ae8d4100d2c377e1fb8669644c01772a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae8d4100d2c377e1fb8669644c01772a0">More...</a><br /></td></tr>
<tr class="separator:ae8d4100d2c377e1fb8669644c01772a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c9a678b42e590f19a84f594b934f8f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a95c9a678b42e590f19a84f594b934f8f"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a95c9a678b42e590f19a84f594b934f8f">count</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a95c9a678b42e590f19a84f594b934f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a95c9a678b42e590f19a84f594b934f8f">More...</a><br /></td></tr>
<tr class="separator:a95c9a678b42e590f19a84f594b934f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ebb3a335bda5157fd0a99938239905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac2ebb3a335bda5157fd0a99938239905">find</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:ac2ebb3a335bda5157fd0a99938239905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac2ebb3a335bda5157fd0a99938239905">More...</a><br /></td></tr>
<tr class="separator:ac2ebb3a335bda5157fd0a99938239905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405ec65a02b7eb2cd7bc836ab1a0f34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a405ec65a02b7eb2cd7bc836ab1a0f34f">find</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a405ec65a02b7eb2cd7bc836ab1a0f34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a405ec65a02b7eb2cd7bc836ab1a0f34f">More...</a><br /></td></tr>
<tr class="separator:a405ec65a02b7eb2cd7bc836ab1a0f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27d8ec5c5bfc4cd03938e02864ad05d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:ac27d8ec5c5bfc4cd03938e02864ad05d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac27d8ec5c5bfc4cd03938e02864ad05d">find</a> (const K &amp;k)</td></tr>
<tr class="memdesc:ac27d8ec5c5bfc4cd03938e02864ad05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac27d8ec5c5bfc4cd03938e02864ad05d">More...</a><br /></td></tr>
<tr class="separator:ac27d8ec5c5bfc4cd03938e02864ad05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92b9121b0fdfcc9812eed38ea49d5b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:aeb92b9121b0fdfcc9812eed38ea49d5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aeb92b9121b0fdfcc9812eed38ea49d5b">find</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:aeb92b9121b0fdfcc9812eed38ea49d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aeb92b9121b0fdfcc9812eed38ea49d5b">More...</a><br /></td></tr>
<tr class="separator:aeb92b9121b0fdfcc9812eed38ea49d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211fc9a4f541438333de6e464bcfe3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac211fc9a4f541438333de6e464bcfe3b">lower_bound</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:ac211fc9a4f541438333de6e464bcfe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac211fc9a4f541438333de6e464bcfe3b">More...</a><br /></td></tr>
<tr class="separator:ac211fc9a4f541438333de6e464bcfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28c8b7280f57e5e7ac4e661ba2d6d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab28c8b7280f57e5e7ac4e661ba2d6d79">lower_bound</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:ab28c8b7280f57e5e7ac4e661ba2d6d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab28c8b7280f57e5e7ac4e661ba2d6d79">More...</a><br /></td></tr>
<tr class="separator:ab28c8b7280f57e5e7ac4e661ba2d6d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244df991c0a54c47cb871558aed6c64b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a244df991c0a54c47cb871558aed6c64b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a244df991c0a54c47cb871558aed6c64b">lower_bound</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a244df991c0a54c47cb871558aed6c64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a244df991c0a54c47cb871558aed6c64b">More...</a><br /></td></tr>
<tr class="separator:a244df991c0a54c47cb871558aed6c64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d6c114ce6ca6a0036bcf94a68ec6c5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a55d6c114ce6ca6a0036bcf94a68ec6c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a55d6c114ce6ca6a0036bcf94a68ec6c5">lower_bound</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a55d6c114ce6ca6a0036bcf94a68ec6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a55d6c114ce6ca6a0036bcf94a68ec6c5">More...</a><br /></td></tr>
<tr class="separator:a55d6c114ce6ca6a0036bcf94a68ec6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ecf681056632b25ed72c16e8cf27ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a70ecf681056632b25ed72c16e8cf27ad">upper_bound</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:a70ecf681056632b25ed72c16e8cf27ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a70ecf681056632b25ed72c16e8cf27ad">More...</a><br /></td></tr>
<tr class="separator:a70ecf681056632b25ed72c16e8cf27ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0c2f159bfddf5a1c5457dcff8a8c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4b0c2f159bfddf5a1c5457dcff8a8c16">upper_bound</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a4b0c2f159bfddf5a1c5457dcff8a8c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4b0c2f159bfddf5a1c5457dcff8a8c16">More...</a><br /></td></tr>
<tr class="separator:a4b0c2f159bfddf5a1c5457dcff8a8c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda60149a731dc0eaf1b7ebd5a75136c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:acda60149a731dc0eaf1b7ebd5a75136c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acda60149a731dc0eaf1b7ebd5a75136c">upper_bound</a> (const K &amp;k)</td></tr>
<tr class="memdesc:acda60149a731dc0eaf1b7ebd5a75136c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acda60149a731dc0eaf1b7ebd5a75136c">More...</a><br /></td></tr>
<tr class="separator:acda60149a731dc0eaf1b7ebd5a75136c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1425becb01b06c5d246125422603a1"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:aeb1425becb01b06c5d246125422603a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aeb1425becb01b06c5d246125422603a1">upper_bound</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:aeb1425becb01b06c5d246125422603a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aeb1425becb01b06c5d246125422603a1">More...</a><br /></td></tr>
<tr class="separator:aeb1425becb01b06c5d246125422603a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8b39b729c48c8dad5e1319a3fcf100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acb8b39b729c48c8dad5e1319a3fcf100">begin</a> ()</td></tr>
<tr class="memdesc:acb8b39b729c48c8dad5e1319a3fcf100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acb8b39b729c48c8dad5e1319a3fcf100">More...</a><br /></td></tr>
<tr class="separator:acb8b39b729c48c8dad5e1319a3fcf100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cfc386788cfc901e34f31c29a83002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a38cfc386788cfc901e34f31c29a83002">end</a> ()</td></tr>
<tr class="memdesc:a38cfc386788cfc901e34f31c29a83002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a38cfc386788cfc901e34f31c29a83002">More...</a><br /></td></tr>
<tr class="separator:a38cfc386788cfc901e34f31c29a83002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d77d6d9c024a1f3be1d582bf96744d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2d77d6d9c024a1f3be1d582bf96744d7">cbegin</a> () const</td></tr>
<tr class="memdesc:a2d77d6d9c024a1f3be1d582bf96744d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element of the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2d77d6d9c024a1f3be1d582bf96744d7">More...</a><br /></td></tr>
<tr class="separator:a2d77d6d9c024a1f3be1d582bf96744d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b19c4aeb8abc44b62ffefdd5f340e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a12b19c4aeb8abc44b62ffefdd5f340e9">cend</a> () const</td></tr>
<tr class="memdesc:a12b19c4aeb8abc44b62ffefdd5f340e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the map.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a12b19c4aeb8abc44b62ffefdd5f340e9">More...</a><br /></td></tr>
<tr class="separator:a12b19c4aeb8abc44b62ffefdd5f340e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ff288758a7ee780cd5e612365e2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa60ff288758a7ee780cd5e612365e2b1">begin</a> () const</td></tr>
<tr class="memdesc:aa60ff288758a7ee780cd5e612365e2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element of the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa60ff288758a7ee780cd5e612365e2b1">More...</a><br /></td></tr>
<tr class="separator:aa60ff288758a7ee780cd5e612365e2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c5f1ee9f9c5e29ed39ce4942db55a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a64c5f1ee9f9c5e29ed39ce4942db55a5">end</a> () const</td></tr>
<tr class="memdesc:a64c5f1ee9f9c5e29ed39ce4942db55a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the map.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a64c5f1ee9f9c5e29ed39ce4942db55a5">More...</a><br /></td></tr>
<tr class="separator:a64c5f1ee9f9c5e29ed39ce4942db55a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faf4315e1ab9d9e7e0d1e3ccb8e86a5"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9faf4315e1ab9d9e7e0d1e3ccb8e86a5">rbegin</a> ()</td></tr>
<tr class="memdesc:a9faf4315e1ab9d9e7e0d1e3ccb8e86a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9faf4315e1ab9d9e7e0d1e3ccb8e86a5">More...</a><br /></td></tr>
<tr class="separator:a9faf4315e1ab9d9e7e0d1e3ccb8e86a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3443d0cba350a025ca61b9c259767e"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2e3443d0cba350a025ca61b9c259767e">rend</a> ()</td></tr>
<tr class="memdesc:a2e3443d0cba350a025ca61b9c259767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2e3443d0cba350a025ca61b9c259767e">More...</a><br /></td></tr>
<tr class="separator:a2e3443d0cba350a025ca61b9c259767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66927212eea8bce6a28bea219488a954"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a66927212eea8bce6a28bea219488a954">crbegin</a> () const</td></tr>
<tr class="memdesc:a66927212eea8bce6a28bea219488a954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const, reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a66927212eea8bce6a28bea219488a954">More...</a><br /></td></tr>
<tr class="separator:a66927212eea8bce6a28bea219488a954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cbd74033c675057cd4ce316e7db5bc"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af5cbd74033c675057cd4ce316e7db5bc">crend</a> () const</td></tr>
<tr class="memdesc:af5cbd74033c675057cd4ce316e7db5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const, reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af5cbd74033c675057cd4ce316e7db5bc">More...</a><br /></td></tr>
<tr class="separator:af5cbd74033c675057cd4ce316e7db5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2508eb038f80e63b6030421281e768a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa2508eb038f80e63b6030421281e768a">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aa2508eb038f80e63b6030421281e768a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa2508eb038f80e63b6030421281e768a">More...</a><br /></td></tr>
<tr class="separator:aa2508eb038f80e63b6030421281e768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2731f5f6adbf8bd77ae08796e6c41c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aaf2731f5f6adbf8bd77ae08796e6c41c">max_size</a> () const noexcept</td></tr>
<tr class="separator:aaf2731f5f6adbf8bd77ae08796e6c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8121b6328437beca5713fa3ba39758dc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8121b6328437beca5713fa3ba39758dc">size</a> () const noexcept</td></tr>
<tr class="separator:a8121b6328437beca5713fa3ba39758dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2290f1ae7fe23a55e58a333e9b5cedad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2290f1ae7fe23a55e58a333e9b5cedad">swap</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2290f1ae7fe23a55e58a333e9b5cedad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member swap.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2290f1ae7fe23a55e58a333e9b5cedad">More...</a><br /></td></tr>
<tr class="separator:a2290f1ae7fe23a55e58a333e9b5cedad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3fc5e59af32f560692ba7486aa6991"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4e3fc5e59af32f560692ba7486aa6991"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4e3fc5e59af32f560692ba7486aa6991">try_emplace</a> (const key_type &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4e3fc5e59af32f560692ba7486aa6991"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4e3fc5e59af32f560692ba7486aa6991">More...</a><br /></td></tr>
<tr class="separator:a4e3fc5e59af32f560692ba7486aa6991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364a07614f97c660b2bd730eee7f0a0f"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a364a07614f97c660b2bd730eee7f0a0f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a364a07614f97c660b2bd730eee7f0a0f">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a364a07614f97c660b2bd730eee7f0a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a364a07614f97c660b2bd730eee7f0a0f">More...</a><br /></td></tr>
<tr class="separator:a364a07614f97c660b2bd730eee7f0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ffa739b9314e0982dee504632ae22d"><td class="memTemplParams" colspan="2">template&lt;typename P , typename &gt; </td></tr>
<tr class="memitem:a76ffa739b9314e0982dee504632ae22d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a76ffa739b9314e0982dee504632ae22d">insert</a> (P &amp;&amp;<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>)</td></tr>
<tr class="memdesc:a76ffa739b9314e0982dee504632ae22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element if the tree doesn't already contain an element with an equivalent key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a76ffa739b9314e0982dee504632ae22d">More...</a><br /></td></tr>
<tr class="separator:a76ffa739b9314e0982dee504632ae22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f3c92d1bbd2a3246b36400884adaa"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aad4f3c92d1bbd2a3246b36400884adaa"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aad4f3c92d1bbd2a3246b36400884adaa">try_emplace</a> (key_type &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aad4f3c92d1bbd2a3246b36400884adaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aad4f3c92d1bbd2a3246b36400884adaa">More...</a><br /></td></tr>
<tr class="separator:aad4f3c92d1bbd2a3246b36400884adaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36973314dc8016972dd5b88bbc980899"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a36973314dc8016972dd5b88bbc980899"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a36973314dc8016972dd5b88bbc980899">insert_or_assign</a> (const key_type &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a36973314dc8016972dd5b88bbc980899"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a36973314dc8016972dd5b88bbc980899">More...</a><br /></td></tr>
<tr class="separator:a36973314dc8016972dd5b88bbc980899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131e7cadc9a3b97c5ebf1f8587d8cd1f"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a131e7cadc9a3b97c5ebf1f8587d8cd1f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a131e7cadc9a3b97c5ebf1f8587d8cd1f">insert_or_assign</a> (key_type &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a131e7cadc9a3b97c5ebf1f8587d8cd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a131e7cadc9a3b97c5ebf1f8587d8cd1f">More...</a><br /></td></tr>
<tr class="separator:a131e7cadc9a3b97c5ebf1f8587d8cd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad6f0918b93c3a2d51ff561c4f68e7"><td class="memTemplParams" colspan="2">template&lt;typename M , typename K , typename &gt; </td></tr>
<tr class="memitem:aacad6f0918b93c3a2d51ff561c4f68e7"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aacad6f0918b93c3a2d51ff561c4f68e7">insert_or_assign</a> (K &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aacad6f0918b93c3a2d51ff561c4f68e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aacad6f0918b93c3a2d51ff561c4f68e7">More...</a><br /></td></tr>
<tr class="separator:aacad6f0918b93c3a2d51ff561c4f68e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a59c426250aea51c6b793fa53d7cc8789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a59c426250aea51c6b793fa53d7cc8789">check_pmem</a> ()</td></tr>
<tr class="memdesc:a59c426250aea51c6b793fa53d7cc8789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a59c426250aea51c6b793fa53d7cc8789">More...</a><br /></td></tr>
<tr class="separator:a59c426250aea51c6b793fa53d7cc8789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6df0f0a3b37a7aba2aeb2909ea3224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1b6df0f0a3b37a7aba2aeb2909ea3224">check_tx_stage_work</a> ()</td></tr>
<tr class="memdesc:a1b6df0f0a3b37a7aba2aeb2909ea3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1b6df0f0a3b37a7aba2aeb2909ea3224">More...</a><br /></td></tr>
<tr class="separator:a1b6df0f0a3b37a7aba2aeb2909ea3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a218f43b0f76f21ea377651c5be84847a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename BV &gt; </td></tr>
<tr class="memitem:a218f43b0f76f21ea377651c5be84847a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a218f43b0f76f21ea377651c5be84847a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; K, V, BV &gt; &amp;tree)</td></tr>
<tr class="memdesc:a218f43b0f76f21ea377651c5be84847a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints tree in DOT format.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a218f43b0f76f21ea377651c5be84847a">More...</a><br /></td></tr>
<tr class="separator:a218f43b0f76f21ea377651c5be84847a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, typename BytesView = detail::bytes_view&lt;Key&gt;&gt;<br />
class pmem::obj::experimental::radix_tree&lt; Key, Value, BytesView &gt;</h3>

<p>Radix tree is an associative, ordered container. </p>
<p>Its API is similar to the API of std::map.</p>
<p>Unlike std::map radix tree does not use comparison (std::less or equivalent) to locate elements. Instead, keys are mapped to a sequence of bytes using user-provided BytesView type. The key's bytes uniquely define the position of an element. In some way, it is similar to a hash table (BytesView can be treated as a hash function) but with sorted elements.</p>
<p>The elements' ordering is defined based on the BytesView mapping. The byte sequences are compared using a function equivalent to std::string::compare.</p>
<p>BytesView should accept a pointer to the key type in a constructor and provide operator[] (should return a byte at the specified position in the byte representation of value) and size (should return size of value in bytes) method. The declaration should be as following:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BytesView {</div>
<div class="line"> BytesView(<span class="keyword">const</span> Type* t);</div>
<div class="line"> <span class="keywordtype">char</span> operator[](<span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>; <span class="comment">// Must be const!</span></div>
<div class="line"> <span class="keywordtype">size_t</span> <a class="code" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8121b6328437beca5713fa3ba39758dc">size</a>() <span class="keyword">const</span>; <span class="comment">// Must be const!</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>By default, implementation for pmem::obj::basic_inline_string&lt;CharT, Traits&gt; and unsigned integral types is provided. Note that integral types are assumed to be in little-endian.</p>
<p>Iterators and references are stable (are not invalidated by inserts or erases of other elements nor by assigning to the value) for all value types except basic_inline_string&lt;CharT, Traits&gt;.</p>
<p>In case of basic_inline_string&lt;CharT, Traits&gt;, iterators and references are not invalidated by other inserts or erases, but might be invalidated by assigning new value to the element. Using find(K).assign_val("new_value") may invalidate other iterators and references to the element with key K.</p>
<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2290f1ae7fe23a55e58a333e9b5cedad" title="Member swap.">swap()</a> invalidates all references and iterators.</p>
<p>An example of custom BytesView implementation: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>custom_key {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>custom_bytes_view {</div>
<div class="line">    custom_bytes_view(<span class="keyword">const</span> custom_key *k)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> *x = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(&amp;k-&gt;x);</div>
<div class="line">        <span class="keyword">auto</span> *y = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(&amp;k-&gt;y);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)</div>
<div class="line">            bytes[i] = x[<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) - i - 1];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)</div>
<div class="line">            bytes[i + 4] = y[<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) - i - 1];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Note that this function MUST be marked as const */</span></div>
<div class="line">    <span class="keywordtype">char</span> operator[](<span class="keywordtype">size_t</span> pos)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> bytes[pos];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Note that this function MUST be marked as const */</span></div>
<div class="line">    <span class="keywordtype">size_t</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8121b6328437beca5713fa3ba39758dc">size</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(custom_key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span> bytes[<span class="keyword">sizeof</span>(custom_key)];</div>
<div class="line">};</div>
</div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa84c847e4cb5099cf290a16768032219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84c847e4cb5099cf290a16768032219">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default radix tree constructor. </p>
<p>Constructs an empty container. </p><dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674e72524d9ce939a316b6a884c716bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674e72524d9ce939a316b6a884c716bf">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>If multiple elements in the range have keys that compare equivalent, the first element is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator of inserted range.</td></tr>
  </table>
  </dd>
</dl>
<p>InputIt must meet the requirements of LegacyInputIterator.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for inserted elements in transaction failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc90bfeb1ff86b6e6d3bf2e424613f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc90bfeb1ff86b6e6d3bf2e424613f9a">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>reference to the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html" title="Radix tree is an associative, ordered container.">radix_tree</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34fc0eeb0b600e2583cf19f5e5dafde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34fc0eeb0b600e2583cf19f5e5dafde">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa2508eb038f80e63b6030421281e768a" title="Checks whether the container is empty.">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>rvalue reference to the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html" title="Radix tree is an associative, ordered container.">radix_tree</a> to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c277216333ef5fd2a465982e60f293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c277216333ef5fd2a465982e60f293">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acb8b39b729c48c8dad5e1319a3fcf100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8b39b729c48c8dad5e1319a3fcf100">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a38cfc386788cfc901e34f31c29a83002" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="aa60ff288758a7ee780cd5e612365e2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60ff288758a7ee780cd5e612365e2b1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a38cfc386788cfc901e34f31c29a83002" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the first element. </dd></dl>

</div>
</div>
<a id="a2d77d6d9c024a1f3be1d582bf96744d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d77d6d9c024a1f3be1d582bf96744d7">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a38cfc386788cfc901e34f31c29a83002" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the first element. </dd></dl>

</div>
</div>
<a id="a12b19c4aeb8abc44b62ffefdd5f340e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b19c4aeb8abc44b62ffefdd5f340e9">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a59c426250aea51c6b793fa53d7cc8789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c426250aea51c6b793fa53d7cc8789">&#9670;&nbsp;</a></span>check_pmem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::check_pmem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if radix tree resides on pmem and throws an exception if not.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>if radix tree doesn't reside on pmem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6df0f0a3b37a7aba2aeb2909ea3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6df0f0a3b37a7aba2aeb2909ea3224">&#9670;&nbsp;</a></span>check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::check_tx_stage_work</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if current transaction stage is equal to TX_STAGE_WORK and throws an exception otherwise.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if current transaction stage is not equal to TX_STAGE_WORK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32845b930099664a1480674ec33c5c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32845b930099664a1480674ec33c5c6e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements from the container transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8121b6328437beca5713fa3ba39758dc">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95c9a678b42e590f19a84f594b934f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c9a678b42e590f19a84f594b934f8f">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to the specified argument. </dd></dl>

</div>
</div>
<a id="ae8d4100d2c377e1fb8669644c01772a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d4100d2c377e1fb8669644c01772a0">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to the specified argument. </dd></dl>

</div>
</div>
<a id="a66927212eea8bce6a28bea219488a954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66927212eea8bce6a28bea219488a954">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const, reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="af5cbd74033c675057cd4ce316e7db5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cbd74033c675057cd4ce316e7db5bc">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const, reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a364a07614f97c660b2bd730eee7f0a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364a07614f97c660b2bd730eee7f0a0f">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. </p>
<p>Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair&lt;const Key, T&gt;) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2508eb038f80e63b6030421281e768a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2508eb038f80e63b6030421281e768a">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a38cfc386788cfc901e34f31c29a83002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cfc386788cfc901e34f31c29a83002">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a64c5f1ee9f9c5e29ed39ce4942db55a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c5f1ee9f9c5e29ed39ce4942db55a5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a1de5fe22140a6c880577427faf904fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de5fe22140a6c880577427faf904fdd">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9434590ce9311b2b3399d4693ad682eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9434590ce9311b2b3399d4693ad682eb">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc7264d3d4ad274fa781e903b6f3d3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7264d3d4ad274fa781e903b6f3d3d7">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the elements in the range [first; last), which must be a valid range in *this. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator in the range of elements to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator in the range of elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acea267a836da82a07fee930ff94f582b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea267a836da82a07fee930ff94f582b">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element at pos from the container. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a38cfc386788cfc901e34f31c29a83002" title="Returns an iterator to the element following the last element of the map.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the element to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac27d8ec5c5bfc4cd03938e02864ad05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27d8ec5c5bfc4cd03938e02864ad05d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="aeb92b9121b0fdfcc9812eed38ea49d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb92b9121b0fdfcc9812eed38ea49d5b">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ac2ebb3a335bda5157fd0a99938239905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ebb3a335bda5157fd0a99938239905">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a405ec65a02b7eb2cd7bc836ab1a0f34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405ec65a02b7eb2cd7bc836ab1a0f34f">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a1830a0fb058aa4cadaff71b9974308f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1830a0fb058aa4cadaff71b9974308f7">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts element if the tree doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4193653098e1dd8cee03629a29135439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4193653098e1dd8cee03629a29135439">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator of inserted range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76ffa739b9314e0982dee504632ae22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ffa739b9314e0982dee504632ae22d">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts element if the tree doesn't already contain an element with an equivalent key. </p>
<p>This overload is equivalent to emplace(std::forward&lt;P&gt;(value)) and only participates in overload resolution if std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d127331fe82d643f02e5e41b7d0c607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d127331fe82d643f02e5e41b7d0c607">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from initializer list il. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer list to insert the values from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa38ef81a5f9275091cdb7bce8a915d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38ef81a5f9275091cdb7bce8a915d37">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts element using move semantic if the tree doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36973314dc8016972dd5b88bbc980899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36973314dc8016972dd5b88bbc980899">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. </p>
<p>If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, std::forward&lt;M&gt;(obj)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the value to insert or assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator,bool&gt; The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacad6f0918b93c3a2d51ff561c4f68e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacad6f0918b93c3a2d51ff561c4f68e7">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M , typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. </p>
<p>If the key does not exist, inserts the new value as if by insert, constructing it from value_type(std::forward&lt;K&gt;(k), std::forward&lt;M&gt;(obj)).</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the value to insert or assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator,bool&gt; The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a131e7cadc9a3b97c5ebf1f8587d8cd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131e7cadc9a3b97c5ebf1f8587d8cd1f">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. </p>
<p>If the key does not exist, inserts the new value as if by insert, constructing it from value_type(std::move(k), std::forward&lt;M&gt;(obj))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the value to insert or assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator,bool&gt; The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a244df991c0a54c47cb871558aed6c64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244df991c0a54c47cb871558aed6c64b">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a55d6c114ce6ca6a0036bcf94a68ec6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d6c114ce6ca6a0036bcf94a68ec6c5">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ac211fc9a4f541438333de6e464bcfe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211fc9a4f541438333de6e464bcfe3b">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ab28c8b7280f57e5e7ac4e661ba2d6d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28c8b7280f57e5e7ac4e661ba2d6d79">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="aaf2731f5f6adbf8bd77ae08796e6c41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2731f5f6adbf8bd77ae08796e6c41c">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold </dd></dl>

</div>
</div>
<a id="ab41f35c1ca9da94aabecea54517437e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41f35c1ca9da94aabecea54517437e3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of other transactionally.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor's exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7170673d1cafb1bb8cd2023294b9b848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7170673d1cafb1bb8cd2023294b9b848">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container) transactionally. Other is in a valid but empty state afterwards.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08f3b0590be38387ccda40c197a7a623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f3b0590be38387ccda40c197a7a623">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list to use as data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9faf4315e1ab9d9e7e0d1e3ccb8e86a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faf4315e1ab9d9e7e0d1e3ccb8e86a5">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a2e3443d0cba350a025ca61b9c259767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3443d0cba350a025ca61b9c259767e">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a8121b6328437beca5713fa3ba39758dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8121b6328437beca5713fa3ba39758dc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<a id="a2290f1ae7fe23a55e58a333e9b5cedad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2290f1ae7fe23a55e58a333e9b5cedad">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Member swap. </p>
<p>Exchanges *this with</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e3fc5e59af32f560692ba7486aa6991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3fc5e59af32f560692ba7486aa6991">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</p>
<p>Unlike insert or emplace, this method do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types. In addition, try_emplace treats the key and the arguments to the mapped_type separately, unlike emplace, which requires the arguments to construct a value_type (that is, a std::pair).</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d2f783b8ef49e75e6cdc8551a1fe32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2f783b8ef49e75e6cdc8551a1fe32d">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename BV , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;
		detail::has_is_transparent&lt;BV&gt;::value &amp;&amp;
			!std::is_same&lt;typename std::remove_const&lt;
					      typename std::remove_reference&lt;
						      K&gt;::type&gt;::type,
				      key_type&gt;::value,
		std::pair&lt;<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(std::forward&lt;K&gt;(k)), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)).</p>
<p>Unlike insert or emplace, this method do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types. In addition, try_emplace treats the key and the arguments to the mapped_type separately, unlike emplace, which requires the arguments to construct a value_type (that is, a std::pair).</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad4f3c92d1bbd2a3246b36400884adaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f3c92d1bbd2a3246b36400884adaa">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)).</p>
<p>Unlike insert or emplace, this method do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types. In addition, try_emplace treats the key and the arguments to the mapped_type separately, unlike emplace, which requires the arguments to construct a value_type (that is, a std::pair).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acda60149a731dc0eaf1b7ebd5a75136c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda60149a731dc0eaf1b7ebd5a75136c">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="aeb1425becb01b06c5d246125422603a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1425becb01b06c5d246125422603a1">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a70ecf681056632b25ed72c16e8cf27ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ecf681056632b25ed72c16e8cf27ad">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a4b0c2f159bfddf5a1c5457dcff8a8c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0c2f159bfddf5a1c5457dcff8a8c16">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a218f43b0f76f21ea377651c5be84847a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f43b0f76f21ea377651c5be84847a">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = detail::bytes_view&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V , typename BV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; K, V, BV &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints tree in DOT format. </p>
<p>Used for debugging. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="radix__tree_8hpp_source.html">radix_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1obj_1_1experimental_1_1radix__tree_html_a8121b6328437beca5713fa3ba39758dc"><div class="ttname"><a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8121b6328437beca5713fa3ba39758dc">pmem::obj::experimental::radix_tree::size</a></div><div class="ttdeci">uint64_t size() const noexcept</div><div class="ttdef"><b>Definition:</b> radix_tree.hpp:914</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
