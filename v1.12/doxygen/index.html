<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: libpmemobj-cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.12-git53.g67ba2be4</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libpmemobj-cpp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<p>This is the C++ API for libpmemobj extended with persistent containers.</p>
<p>If you want to read more about PMDK (and libpmemobj C API in specific) see: <a href="https://pmem.io/pmdk">https://pmem.io/pmdk</a></p>
<p>Main libpmemobj-cpp documentation website is: <a href="https://pmem.io/libpmemobj-cpp">https://pmem.io/libpmemobj-cpp</a> It also contains links to blog articles which you might find helpful.</p>
<p>If you find any issues or have suggestion about these bindings please file an issue in <a href="https://github.com/pmem/libpmemobj-cpp/issues">https://github.com/pmem/libpmemobj-cpp/issues</a>. The GitHub website is also the main code repository location and it contains full usage examples.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Introduction</h2>
<p>During the development of libpmemobj, many difficulties were encountered and compromises were made to make the C API as much user-friendly as possible. This is mostly due to the semantics of the C language. Since C++ is a more expressive language, it was natural to try and bridge the gap using native C++ features.</p>
<p>There are three main features of the C++ bindings:</p><ul>
<li>the <code>persistent_ptr&lt;&gt;</code> smart pointer,</li>
<li>the <code>transaction</code>, which comes in two flavours - scoped and closure,</li>
<li>the <code>p&lt;&gt;</code> property.</li>
</ul>
<p>The main issue with the C API is the generic PMEMoid and its typed counterpart, the TOID. For them to be conveniently used in transactions, a large set of macros has been defined. This made using the generic pointer easier, yet still unintuitive. In C++, the <code>persistent_ptr&lt;&gt;</code> template makes it a lot easier providing well known smart pointer semantics and built-in transactions support.</p>
<p>The other drawback of the C API is the transaction semantics. Manual usage of <code>setjmp</code> and <code>jmpbuf</code> is error prone, so they were once again wrapped in macros. They themselves have issues with undefined values of automatic variables (see the libpmemobj manpage for more details). The transactions defined in the C++ bindings try to fix the inadequacies of their C counterparts.</p>
<p>The <code>p&lt;&gt;</code>, which is called the <em>persistent property</em>, was designed with seamless persistent memory integration in mind. It is designed to be used with basic types within classes, to signify that these members in fact reside in persistent memory and need to be handled appropriately.</p>
<p>Please remember to take extra care when using <em>static class members</em>. They are not stored in persistent memory, therefore their value will <em>not</em> always be consistent across subsequent executions or compilations of user applications.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Compiler notice</h2>
<p>The C++ bindings require a C++11 compliant compiler, therefore the minimal versions of GCC and Clang are 4.8.1 and 3.3 respectively. However the <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html#a8ffae81b74ffe313eb2deb16573d70e1" title="C++ automatic scope transaction class.">pmem::obj::transaction::automatic</a> class requires C++17, so you need a more recent version for this to be available (GCC 6.1/Clang 3.7). It is recommended to use these or newer versions of GCC or Clang. A usage of the libpmemobj-cpp containers requires GCC &gt;= 4.9.0 (see explanation in the main README.md file).</p>
<h2><a class="anchor" id="autotoc_md2"></a>
C++ standard notice</h2>
<p>Please note that the C++11 standard, section 3.8, states that a valid non-trivially default constructible object (in other words, not plain old data) must be properly constructed in the lifetime of the application. Libpmemobj, or any shared memory solution for that matter, does not strictly adhere to that constraint.</p>
<p>We believe that in the future, languages that wish to support persistent memory will need to alter their semantics to establish a defined behavior for objects whose lifetimes exceed that of the application. In the meantime, the programs that wish to use persistent memory will need to rely on compiler-defined behavior.</p>
<p>Our library, and by extension these bindings, have been extensively tested in g++, clang++ and MSVC++ to make sure that our solution is safe to use and practically speaking implementation defined. The only exception to this rule is the use of polymorphic types, which are notably forbidden when using C++ bindings.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Compatibility notice</h2>
<p>In libpmemobj 1.12 we introduced a new transaction handler type: <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html" title="C++ flat transaction handler class.">pmem::obj::flat_transaction</a>. By defining LIBPMEMOBJ_CPP_USE_FLAT_TRANSACTION you can make <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43" title="By default, pmem::obj::transaction is an alias to pmem::obj::basic_transaction.">pmem::obj::transaction</a> to be an alias to <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html" title="C++ flat transaction handler class.">pmem::obj::flat_transaction</a>. In 1.12 we have also changed the default behavior of containers' transactional methods. Now, in case of any failure within such method, the outer transaction (if any) will not be immediately aborted. Instead, an exception will be thrown, which will lead to transaction abort only if it's not caught before the outer tx scope ends. To change the behavior to the old one, you can set LIBPMEMOBJ_CPP_FLAT_TX_USE_FAILURE_RETURN macro to 0. Be aware that the old behavior can lead to segfaults in some cases (see tx_nested_struct_example in this <a href="https://github.com/pmem/libpmemobj-cpp/blob/master/examples/transaction/transaction.cpp">example</a>).</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Important classes/functions</h2>
<ul>
<li>Transactional allocations - <a class="el" href="make__persistent_8hpp.html" title="Persistent_ptr transactional allocation functions for objects.">make_persistent.hpp</a></li>
<li>Transactional array allocations - <a class="el" href="make__persistent__array_8hpp.html" title="Persistent_ptr allocation functions for arrays.">make_persistent_array.hpp</a></li>
<li>Atomic allocations - <a class="el" href="make__persistent__atomic_8hpp.html" title="Persistent_ptr atomic allocation functions for objects.">make_persistent_atomic.hpp</a></li>
<li>Atomic array allocations - <a class="el" href="make__persistent__array__atomic_8hpp.html" title="Atomic persistent_ptr allocation functions for arrays.">make_persistent_array_atomic.hpp</a></li>
<li>Resides on persistent memory property - <a class="el" href="classpmem_1_1obj_1_1p.html">p</a></li>
<li>Persistent smart pointer - <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a></li>
<li>Persistent memory transactions - <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">transaction</a></li>
<li>Persistent memory resident mutex - <a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a></li>
<li>Persistent memory pool - <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a></li>
<li>Defrag class - <a class="el" href="classpmem_1_1obj_1_1defrag.html">defrag</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
Persistent containers</h1>
<p>The C++ standard library containers collection is something that persistent memory programmers may want to use. Containers manage the lifetime of held objects through allocation/creation and deallocation/destruction with the use of allocators. Implementing custom persistent allocator for C++ STL (Standard Template Library) containers has two main downsides:</p>
<p>Implementation details:</p><ul>
<li>STL containers do not use algorithms optimal from persistent memory programming point of view.</li>
<li>Persistent memory containers should have durability and consistency properties, while not every STL method guarantees strong exception safety.</li>
<li>Persistent memory containers should be designed with an awareness of fragmentation limitations.</li>
</ul>
<p>Memory layout:</p><ul>
<li>The STL does not guarantee that the container layout will remain unchanged in new library versions.</li>
</ul>
<p>Due to these obstacles, the libpmemobj-cpp contains the set of custom, implemented-from-scratch containers with optimized on-media layouts and algorithms to fully exploit the potential and features of persistent memory. These methods guarantee atomicity, consistency and durability. Besides specific internal implementation details, libpmemobj-cpp persistent memory containers have the well-known STL-like interface and they work with STL algorithms.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Available containers</h2>
<ul>
<li>array with STL-like interface - <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a></li>
<li>string with STL-like interface - <a class="el" href="classpmem_1_1obj_1_1basic__string.html">pmem::obj::string</a></li>
<li>vector with STL-like interface - <a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a></li>
<li>segment_vector with std::vector-like interface (no STL counterpart) - <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">pmem::obj::segment_vector</a></li>
<li>concurrent_hash_map (no STL counterpart) - <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">pmem::obj::concurrent_hash_map</a></li>
<li>radix_tree (partially compatible with std::map) - <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
