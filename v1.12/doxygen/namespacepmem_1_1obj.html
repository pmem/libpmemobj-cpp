<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.12-git53.g67ba2be4</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main libpmemobj namespace.  
<a href="namespacepmem_1_1obj.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepmem_1_1obj_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></td></tr>
<tr class="memdesc:namespacepmem_1_1obj_1_1experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepmem_1_1obj_1_1segment__vector__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj_1_1segment__vector__internal.html">segment_vector_internal</a></td></tr>
<tr class="memdesc:namespacepmem_1_1obj_1_1segment__vector__internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation of pmem's segment vector. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of flag which can be passed to make_persistent.  <a href="structpmem_1_1obj_1_1allocation__flag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of flag which can be passed to make_persistent_atomic.  <a href="structpmem_1_1obj_1_1allocation__flag__atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(EXPERIMENTAL) Encapsulates the information about the persistent memory allocation model using PMDK's libpmemobj.  <a href="classpmem_1_1obj_1_1allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a> - persistent container with std::array compatible interface.  <a href="structpmem_1_1obj_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">pmem::obj::string - persistent container with std::basic_string compatible interface.  <a href="classpmem_1_1obj_1_1basic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our partial std::string_view implementation.  <a href="classpmem_1_1obj_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1basic__transaction.html">basic_transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ transaction handler class.  <a href="classpmem_1_1obj_1_1basic__transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html">concurrent_hash_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory aware implementation of Intel TBB <a class="el" href="classpmem_1_1obj_1_1concurrent__hash__map.html" title="Persistent memory aware implementation of Intel TBB concurrent_hash_map.">concurrent_hash_map</a>.  <a href="classpmem_1_1obj_1_1concurrent__hash__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1condition__variable.html">condition_variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident condition variable.  <a href="classpmem_1_1obj_1_1condition__variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1defrag.html">defrag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defrag class.  <a href="classpmem_1_1obj_1_1defrag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1flat__transaction.html">flat_transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ flat transaction handler class.  <a href="classpmem_1_1obj_1_1flat__transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1mutex.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident mutex implementation.  <a href="classpmem_1_1obj_1_1mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits.html">object_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates object specific allocator functionality.  <a href="classpmem_1_1obj_1_1object__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1object__traits_3_01void_01_4.html">object_traits&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object traits specialization for the void type.  <a href="classpmem_1_1obj_1_1object__traits_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resides on pmem class.  <a href="classpmem_1_1obj_1_1p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent pointer class.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr_3_01const_01void_01_4.html">persistent_ptr&lt; const void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> const void specialization.  <a href="classpmem_1_1obj_1_1persistent__ptr_3_01const_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr_3_01void_01_4.html">persistent_ptr&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> void specialization.  <a href="classpmem_1_1obj_1_1persistent__ptr_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr__base.html">persistent_ptr_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent_ptr base (non-template) class.  <a href="classpmem_1_1obj_1_1persistent__ptr__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMEMobj pool class.  <a href="classpmem_1_1obj_1_1pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non-template pool base class.  <a href="classpmem_1_1obj_1_1pool__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A persistent version of segment vector implementation.  <a href="classpmem_1_1obj_1_1segment__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1shared__mutex.html">shared_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident <a class="el" href="classpmem_1_1obj_1_1shared__mutex.html" title="Persistent memory resident shared_mutex implementation.">shared_mutex</a> implementation.  <a href="classpmem_1_1obj_1_1shared__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1slice.html" title="pmem::obj::slice - provides interface to access sequence of objects.">pmem::obj::slice</a> - provides interface to access sequence of objects.  <a href="classpmem_1_1obj_1_1slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation policy template for a given type.  <a href="classpmem_1_1obj_1_1standard__alloc__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy_3_01void_01_4.html">standard_alloc_policy&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void specialization of the standard allocation policy.  <a href="classpmem_1_1obj_1_1standard__alloc__policy_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1timed__mutex.html">timed_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent memory resident <a class="el" href="classpmem_1_1obj_1_1timed__mutex.html" title="Persistent memory resident timed_mutex implementation.">timed_mutex</a> implementation.  <a href="classpmem_1_1obj_1_1timed__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpmem_1_1obj_1_1vector.html" title="pmem::obj::vector - persistent container with std::vector compatible interface.">pmem::obj::vector</a> - persistent container with std::vector compatible interface.  <a href="classpmem_1_1obj_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </td></tr>
<tr class="memitem:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">exponential_size_array_policy</a> = segment_vector_internal::exponential_size_policy&lt; <a class="el" href="structpmem_1_1obj_1_1array.html">segment_vector_internal::array_64</a>, SegmentType &gt;</td></tr>
<tr class="memdesc:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential size policy with pmemobj array of size 64 as a type of segment vector, so this is a static array of segments and each segment is of SegmentType.  <a href="namespacepmem_1_1obj.html#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">More...</a><br /></td></tr>
<tr class="separator:aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859b965166fda256885558839d7bb7ec"><td class="memTemplParams" colspan="2">template&lt;size_t SegmentSize = 1024, template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </td></tr>
<tr class="memitem:a859b965166fda256885558839d7bb7ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a859b965166fda256885558839d7bb7ec">fixed_size_vector_policy</a> = segment_vector_internal::fixed_size_policy&lt; <a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType, SegmentSize &gt;</td></tr>
<tr class="memdesc:a859b965166fda256885558839d7bb7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size policy with pmemobj vector of a given size as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType.  <a href="namespacepmem_1_1obj.html#a859b965166fda256885558839d7bb7ec">More...</a><br /></td></tr>
<tr class="separator:a859b965166fda256885558839d7bb7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e84dce66d8c59cdc9070321b8d0d7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </td></tr>
<tr class="memitem:a526e84dce66d8c59cdc9070321b8d0d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a526e84dce66d8c59cdc9070321b8d0d7">exponential_size_vector_policy</a> = segment_vector_internal::exponential_size_policy&lt; <a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType &gt;</td></tr>
<tr class="memdesc:a526e84dce66d8c59cdc9070321b8d0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential size policy with pmemobj vector as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType.  <a href="namespacepmem_1_1obj.html#a526e84dce66d8c59cdc9070321b8d0d7">More...</a><br /></td></tr>
<tr class="separator:a526e84dce66d8c59cdc9070321b8d0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584f6676f0d014e94253e19f2d18da43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">transaction</a> = <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html">basic_transaction</a></td></tr>
<tr class="memdesc:a584f6676f0d014e94253e19f2d18da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43" title="By default, pmem::obj::transaction is an alias to pmem::obj::basic_transaction.">pmem::obj::transaction</a> is an alias to <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html" title="C++ transaction handler class.">pmem::obj::basic_transaction</a>.  <a href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">More...</a><br /></td></tr>
<tr class="separator:a584f6676f0d014e94253e19f2d18da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad052dc252e327efbe5f17be6e840935d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ad052dc252e327efbe5f17be6e840935d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ad052dc252e327efbe5f17be6e840935d">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;, <a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T2 &gt; const &amp;)</td></tr>
<tr class="memdesc:ad052dc252e327efbe5f17be6e840935d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="namespacepmem_1_1obj.html#ad052dc252e327efbe5f17be6e840935d">More...</a><br /></td></tr>
<tr class="separator:ad052dc252e327efbe5f17be6e840935d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a59d3c5deb43649af9a78f8bd651b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OtherAllocator &gt; </td></tr>
<tr class="memitem:a87a59d3c5deb43649af9a78f8bd651b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a87a59d3c5deb43649af9a78f8bd651b9">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;, OtherAllocator const &amp;)</td></tr>
<tr class="memdesc:a87a59d3c5deb43649af9a78f8bd651b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="namespacepmem_1_1obj.html#a87a59d3c5deb43649af9a78f8bd651b9">More...</a><br /></td></tr>
<tr class="separator:a87a59d3c5deb43649af9a78f8bd651b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1f133c1308826fee0b3abf2f09c3b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename Tr , typename T2 , typename P2 , typename Tr2 &gt; </td></tr>
<tr class="memitem:adb1f133c1308826fee0b3abf2f09c3b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#adb1f133c1308826fee0b3abf2f09c3b5">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T2, P2, Tr2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adb1f133c1308826fee0b3abf2f09c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="namespacepmem_1_1obj.html#adb1f133c1308826fee0b3abf2f09c3b5">More...</a><br /></td></tr>
<tr class="separator:adb1f133c1308826fee0b3abf2f09c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641fa4c058284070e8b9c2c273b4ced3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename Tr , typename OtherAllocator &gt; </td></tr>
<tr class="memitem:a641fa4c058284070e8b9c2c273b4ced3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a641fa4c058284070e8b9c2c273b4ced3">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;lhs, const OtherAllocator &amp;rhs)</td></tr>
<tr class="memdesc:a641fa4c058284070e8b9c2c273b4ced3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if memory from another allocator can be deallocated from this one.  <a href="namespacepmem_1_1obj.html#a641fa4c058284070e8b9c2c273b4ced3">More...</a><br /></td></tr>
<tr class="separator:a641fa4c058284070e8b9c2c273b4ced3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac08cf50c8772b14d24d58987550ff44"><td class="memTemplParams" colspan="2"><a id="aac08cf50c8772b14d24d58987550ff44"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aac08cf50c8772b14d24d58987550ff44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aac08cf50c8772b14d24d58987550ff44">operator==</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aac08cf50c8772b14d24d58987550ff44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:aac08cf50c8772b14d24d58987550ff44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8fe61f5f4e399c0643640d9de2608d"><td class="memTemplParams" colspan="2"><a id="a7a8fe61f5f4e399c0643640d9de2608d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a7a8fe61f5f4e399c0643640d9de2608d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7a8fe61f5f4e399c0643640d9de2608d">operator!=</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7a8fe61f5f4e399c0643640d9de2608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not-equal operator. <br /></td></tr>
<tr class="separator:a7a8fe61f5f4e399c0643640d9de2608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32224cd97024c3031b0751af854ddd9c"><td class="memTemplParams" colspan="2"><a id="a32224cd97024c3031b0751af854ddd9c"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a32224cd97024c3031b0751af854ddd9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a32224cd97024c3031b0751af854ddd9c">operator&lt;</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a32224cd97024c3031b0751af854ddd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:a32224cd97024c3031b0751af854ddd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad501de98b6764d3ff1e877c5d9291ad8"><td class="memTemplParams" colspan="2"><a id="ad501de98b6764d3ff1e877c5d9291ad8"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad501de98b6764d3ff1e877c5d9291ad8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ad501de98b6764d3ff1e877c5d9291ad8">operator&gt;</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad501de98b6764d3ff1e877c5d9291ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:ad501de98b6764d3ff1e877c5d9291ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5034348e46ff8ebddb366634118bd6b5"><td class="memTemplParams" colspan="2"><a id="a5034348e46ff8ebddb366634118bd6b5"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5034348e46ff8ebddb366634118bd6b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5034348e46ff8ebddb366634118bd6b5">operator&gt;=</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5034348e46ff8ebddb366634118bd6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:a5034348e46ff8ebddb366634118bd6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2c5f33d7ca7366bc34eef6d4a22039"><td class="memTemplParams" colspan="2"><a id="a0d2c5f33d7ca7366bc34eef6d4a22039"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0d2c5f33d7ca7366bc34eef6d4a22039"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0d2c5f33d7ca7366bc34eef6d4a22039">operator&lt;=</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0d2c5f33d7ca7366bc34eef6d4a22039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:a0d2c5f33d7ca7366bc34eef6d4a22039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd06001cc9db20b93349064c3ef9062"><td class="memTemplParams" colspan="2"><a id="a5fd06001cc9db20b93349064c3ef9062"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5fd06001cc9db20b93349064c3ef9062"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5fd06001cc9db20b93349064c3ef9062">cbegin</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a5fd06001cc9db20b93349064c3ef9062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member cbegin. <br /></td></tr>
<tr class="separator:a5fd06001cc9db20b93349064c3ef9062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf7cd43eb534c9b5760f018d726a132"><td class="memTemplParams" colspan="2"><a id="aedf7cd43eb534c9b5760f018d726a132"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aedf7cd43eb534c9b5760f018d726a132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aedf7cd43eb534c9b5760f018d726a132">cend</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:aedf7cd43eb534c9b5760f018d726a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member cend. <br /></td></tr>
<tr class="separator:aedf7cd43eb534c9b5760f018d726a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd534d44eedaf5e8d85524dd65193e1"><td class="memTemplParams" colspan="2"><a id="a6fd534d44eedaf5e8d85524dd65193e1"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6fd534d44eedaf5e8d85524dd65193e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_reverse_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6fd534d44eedaf5e8d85524dd65193e1">crbegin</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a6fd534d44eedaf5e8d85524dd65193e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member crbegin. <br /></td></tr>
<tr class="separator:a6fd534d44eedaf5e8d85524dd65193e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ead02f7b910ae03948365676f92a02"><td class="memTemplParams" colspan="2"><a id="a67ead02f7b910ae03948365676f92a02"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a67ead02f7b910ae03948365676f92a02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_reverse_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a67ead02f7b910ae03948365676f92a02">crend</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a67ead02f7b910ae03948365676f92a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member crend. <br /></td></tr>
<tr class="separator:a67ead02f7b910ae03948365676f92a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b865184397a869c6c3961222774c35"><td class="memTemplParams" colspan="2"><a id="af7b865184397a869c6c3961222774c35"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af7b865184397a869c6c3961222774c35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af7b865184397a869c6c3961222774c35">begin</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:af7b865184397a869c6c3961222774c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member begin. <br /></td></tr>
<tr class="separator:af7b865184397a869c6c3961222774c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5567bc686fa11774603c27a816fccd8"><td class="memTemplParams" colspan="2"><a id="ab5567bc686fa11774603c27a816fccd8"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab5567bc686fa11774603c27a816fccd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ab5567bc686fa11774603c27a816fccd8">begin</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:ab5567bc686fa11774603c27a816fccd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member begin. <br /></td></tr>
<tr class="separator:ab5567bc686fa11774603c27a816fccd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9a19e08dff0b1cba582993afd16b83"><td class="memTemplParams" colspan="2"><a id="a8c9a19e08dff0b1cba582993afd16b83"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a8c9a19e08dff0b1cba582993afd16b83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a8c9a19e08dff0b1cba582993afd16b83">end</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a8c9a19e08dff0b1cba582993afd16b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member end. <br /></td></tr>
<tr class="separator:a8c9a19e08dff0b1cba582993afd16b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058a2cefe2a5b3488476d1180eea7e7c"><td class="memTemplParams" colspan="2"><a id="a058a2cefe2a5b3488476d1180eea7e7c"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a058a2cefe2a5b3488476d1180eea7e7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a058a2cefe2a5b3488476d1180eea7e7c">end</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a058a2cefe2a5b3488476d1180eea7e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member end. <br /></td></tr>
<tr class="separator:a058a2cefe2a5b3488476d1180eea7e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292785df0f9b6877dd20b9794c83b7e4"><td class="memTemplParams" colspan="2"><a id="a292785df0f9b6877dd20b9794c83b7e4"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a292785df0f9b6877dd20b9794c83b7e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::reverse_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a292785df0f9b6877dd20b9794c83b7e4">rbegin</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a292785df0f9b6877dd20b9794c83b7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member rbegin. <br /></td></tr>
<tr class="separator:a292785df0f9b6877dd20b9794c83b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c54b7cf593489018de3f219043c897"><td class="memTemplParams" colspan="2"><a id="a58c54b7cf593489018de3f219043c897"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a58c54b7cf593489018de3f219043c897"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_reverse_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a58c54b7cf593489018de3f219043c897">rbegin</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a58c54b7cf593489018de3f219043c897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member rbegin. <br /></td></tr>
<tr class="separator:a58c54b7cf593489018de3f219043c897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2a3a635eec0365bb9e007e178f77da"><td class="memTemplParams" colspan="2"><a id="aec2a3a635eec0365bb9e007e178f77da"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aec2a3a635eec0365bb9e007e178f77da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::reverse_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aec2a3a635eec0365bb9e007e178f77da">rend</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:aec2a3a635eec0365bb9e007e178f77da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member rend. <br /></td></tr>
<tr class="separator:aec2a3a635eec0365bb9e007e178f77da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625151123a73e7fbb8ed00defc20f0d2"><td class="memTemplParams" colspan="2"><a id="a625151123a73e7fbb8ed00defc20f0d2"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a625151123a73e7fbb8ed00defc20f0d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_reverse_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a625151123a73e7fbb8ed00defc20f0d2">rend</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a625151123a73e7fbb8ed00defc20f0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member rend. <br /></td></tr>
<tr class="separator:a625151123a73e7fbb8ed00defc20f0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36a1b526d5d5c81d35f02557c3b8e24"><td class="memTemplParams" colspan="2"><a id="af36a1b526d5d5c81d35f02557c3b8e24"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:af36a1b526d5d5c81d35f02557c3b8e24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af36a1b526d5d5c81d35f02557c3b8e24">swap</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af36a1b526d5d5c81d35f02557c3b8e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member swap function. <br /></td></tr>
<tr class="separator:af36a1b526d5d5c81d35f02557c3b8e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33ff9be3b0cc1bce22b7524b9252077"><td class="memTemplParams" colspan="2"><a id="aa33ff9be3b0cc1bce22b7524b9252077"></a>
template&lt;size_t I, typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa33ff9be3b0cc1bce22b7524b9252077"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa33ff9be3b0cc1bce22b7524b9252077">get</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:aa33ff9be3b0cc1bce22b7524b9252077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member get function. <br /></td></tr>
<tr class="separator:aa33ff9be3b0cc1bce22b7524b9252077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ebb82db8ea2b7b0a49473a7f1be1a9"><td class="memTemplParams" colspan="2"><a id="a42ebb82db8ea2b7b0a49473a7f1be1a9"></a>
template&lt;size_t I, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a42ebb82db8ea2b7b0a49473a7f1be1a9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a42ebb82db8ea2b7b0a49473a7f1be1a9">get</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;&amp;a)</td></tr>
<tr class="memdesc:a42ebb82db8ea2b7b0a49473a7f1be1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member get function. <br /></td></tr>
<tr class="separator:a42ebb82db8ea2b7b0a49473a7f1be1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1916fc624ea2edbab5b2371dd4b8e07"><td class="memTemplParams" colspan="2"><a id="ad1916fc624ea2edbab5b2371dd4b8e07"></a>
template&lt;size_t I, typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad1916fc624ea2edbab5b2371dd4b8e07"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ad1916fc624ea2edbab5b2371dd4b8e07">get</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ad1916fc624ea2edbab5b2371dd4b8e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member get function. <br /></td></tr>
<tr class="separator:ad1916fc624ea2edbab5b2371dd4b8e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610a8e6300edb2dae899a7b5c36aef6b"><td class="memTemplParams" colspan="2"><a id="a610a8e6300edb2dae899a7b5c36aef6b"></a>
template&lt;size_t I, typename T , size_t N&gt; </td></tr>
<tr class="memitem:a610a8e6300edb2dae899a7b5c36aef6b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a610a8e6300edb2dae899a7b5c36aef6b">get</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt; &amp;&amp;a) noexcept</td></tr>
<tr class="memdesc:a610a8e6300edb2dae899a7b5c36aef6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member get function. <br /></td></tr>
<tr class="separator:a610a8e6300edb2dae899a7b5c36aef6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e43fb15bab3cba6438a0cd3595a817"><td class="memTemplParams" colspan="2"><a id="ac6e43fb15bab3cba6438a0cd3595a817"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ac6e43fb15bab3cba6438a0cd3595a817"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ac6e43fb15bab3cba6438a0cd3595a817">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac6e43fb15bab3cba6438a0cd3595a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:ac6e43fb15bab3cba6438a0cd3595a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b19ef1a40e669c1766c4026bee6c8"><td class="memTemplParams" colspan="2"><a id="a788b19ef1a40e669c1766c4026bee6c8"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a788b19ef1a40e669c1766c4026bee6c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a788b19ef1a40e669c1766c4026bee6c8">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a788b19ef1a40e669c1766c4026bee6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a788b19ef1a40e669c1766c4026bee6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5ba3863c032e58b8c9ec9a42b4d31b"><td class="memTemplParams" colspan="2"><a id="acf5ba3863c032e58b8c9ec9a42b4d31b"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:acf5ba3863c032e58b8c9ec9a42b4d31b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#acf5ba3863c032e58b8c9ec9a42b4d31b">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acf5ba3863c032e58b8c9ec9a42b4d31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:acf5ba3863c032e58b8c9ec9a42b4d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae573d72e424893168ee8abd73f2db0d8"><td class="memTemplParams" colspan="2"><a id="ae573d72e424893168ee8abd73f2db0d8"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ae573d72e424893168ee8abd73f2db0d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae573d72e424893168ee8abd73f2db0d8">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae573d72e424893168ee8abd73f2db0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:ae573d72e424893168ee8abd73f2db0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3db54f0ec67da3714bbe86dd052921f"><td class="memTemplParams" colspan="2"><a id="aa3db54f0ec67da3714bbe86dd052921f"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:aa3db54f0ec67da3714bbe86dd052921f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa3db54f0ec67da3714bbe86dd052921f">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa3db54f0ec67da3714bbe86dd052921f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:aa3db54f0ec67da3714bbe86dd052921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233fbe47a6216bf2d2fe87b13b203194"><td class="memTemplParams" colspan="2"><a id="a233fbe47a6216bf2d2fe87b13b203194"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a233fbe47a6216bf2d2fe87b13b203194"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a233fbe47a6216bf2d2fe87b13b203194">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a233fbe47a6216bf2d2fe87b13b203194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:a233fbe47a6216bf2d2fe87b13b203194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67b9906991892884efe135f1d447b4e"><td class="memTemplParams" colspan="2"><a id="ab67b9906991892884efe135f1d447b4e"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ab67b9906991892884efe135f1d447b4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ab67b9906991892884efe135f1d447b4e">operator==</a> (const CharT *lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab67b9906991892884efe135f1d447b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:ab67b9906991892884efe135f1d447b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9a3046d2940c9c6c3c1a07f5901649"><td class="memTemplParams" colspan="2"><a id="a2c9a3046d2940c9c6c3c1a07f5901649"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a2c9a3046d2940c9c6c3c1a07f5901649"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2c9a3046d2940c9c6c3c1a07f5901649">operator!=</a> (const CharT *lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2c9a3046d2940c9c6c3c1a07f5901649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a2c9a3046d2940c9c6c3c1a07f5901649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f2456d0e8bfce1a0ddf11e4484fb36"><td class="memTemplParams" colspan="2"><a id="a41f2456d0e8bfce1a0ddf11e4484fb36"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a41f2456d0e8bfce1a0ddf11e4484fb36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a41f2456d0e8bfce1a0ddf11e4484fb36">operator&lt;</a> (const CharT *lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a41f2456d0e8bfce1a0ddf11e4484fb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:a41f2456d0e8bfce1a0ddf11e4484fb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd9feb3dbcd1ff16c6cf21b95de00d5"><td class="memTemplParams" colspan="2"><a id="a6cd9feb3dbcd1ff16c6cf21b95de00d5"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a6cd9feb3dbcd1ff16c6cf21b95de00d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6cd9feb3dbcd1ff16c6cf21b95de00d5">operator&lt;=</a> (const CharT *lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6cd9feb3dbcd1ff16c6cf21b95de00d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:a6cd9feb3dbcd1ff16c6cf21b95de00d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98a20a136c1cf27ee3fd726ff993a5"><td class="memTemplParams" colspan="2"><a id="abf98a20a136c1cf27ee3fd726ff993a5"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:abf98a20a136c1cf27ee3fd726ff993a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#abf98a20a136c1cf27ee3fd726ff993a5">operator&gt;</a> (const CharT *lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abf98a20a136c1cf27ee3fd726ff993a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:abf98a20a136c1cf27ee3fd726ff993a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09fb8515eda84d2a01aeb1b777b80c3"><td class="memTemplParams" colspan="2"><a id="af09fb8515eda84d2a01aeb1b777b80c3"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:af09fb8515eda84d2a01aeb1b777b80c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af09fb8515eda84d2a01aeb1b777b80c3">operator&gt;=</a> (const CharT *lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af09fb8515eda84d2a01aeb1b777b80c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:af09fb8515eda84d2a01aeb1b777b80c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcf96d678bdb77b19c6148f97f16fc4"><td class="memTemplParams" colspan="2"><a id="aafcf96d678bdb77b19c6148f97f16fc4"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:aafcf96d678bdb77b19c6148f97f16fc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aafcf96d678bdb77b19c6148f97f16fc4">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs)</td></tr>
<tr class="memdesc:aafcf96d678bdb77b19c6148f97f16fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:aafcf96d678bdb77b19c6148f97f16fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c6417f3631c78d50f25d2d63046fec"><td class="memTemplParams" colspan="2"><a id="a72c6417f3631c78d50f25d2d63046fec"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a72c6417f3631c78d50f25d2d63046fec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a72c6417f3631c78d50f25d2d63046fec">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs)</td></tr>
<tr class="memdesc:a72c6417f3631c78d50f25d2d63046fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a72c6417f3631c78d50f25d2d63046fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3566f4c14cf3713bf3c8965a96bd82d"><td class="memTemplParams" colspan="2"><a id="aa3566f4c14cf3713bf3c8965a96bd82d"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:aa3566f4c14cf3713bf3c8965a96bd82d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa3566f4c14cf3713bf3c8965a96bd82d">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs)</td></tr>
<tr class="memdesc:aa3566f4c14cf3713bf3c8965a96bd82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:aa3566f4c14cf3713bf3c8965a96bd82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d274540fc63af0edaba1636b765079"><td class="memTemplParams" colspan="2"><a id="a92d274540fc63af0edaba1636b765079"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a92d274540fc63af0edaba1636b765079"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a92d274540fc63af0edaba1636b765079">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs)</td></tr>
<tr class="memdesc:a92d274540fc63af0edaba1636b765079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:a92d274540fc63af0edaba1636b765079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49187a75fed040c273f6291c7fb8395c"><td class="memTemplParams" colspan="2"><a id="a49187a75fed040c273f6291c7fb8395c"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a49187a75fed040c273f6291c7fb8395c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a49187a75fed040c273f6291c7fb8395c">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs)</td></tr>
<tr class="memdesc:a49187a75fed040c273f6291c7fb8395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:a49187a75fed040c273f6291c7fb8395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abfc5bd5419ac1188e680bc7f061ced"><td class="memTemplParams" colspan="2"><a id="a0abfc5bd5419ac1188e680bc7f061ced"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a0abfc5bd5419ac1188e680bc7f061ced"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0abfc5bd5419ac1188e680bc7f061ced">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs)</td></tr>
<tr class="memdesc:a0abfc5bd5419ac1188e680bc7f061ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:a0abfc5bd5419ac1188e680bc7f061ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f1341420df86c6f8da77b683f1d142"><td class="memTemplParams" colspan="2"><a id="ab7f1341420df86c6f8da77b683f1d142"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ab7f1341420df86c6f8da77b683f1d142"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ab7f1341420df86c6f8da77b683f1d142">operator==</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab7f1341420df86c6f8da77b683f1d142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:ab7f1341420df86c6f8da77b683f1d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bc5a2b4411833a1d5194a4b71e47a1"><td class="memTemplParams" colspan="2"><a id="a00bc5a2b4411833a1d5194a4b71e47a1"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a00bc5a2b4411833a1d5194a4b71e47a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a00bc5a2b4411833a1d5194a4b71e47a1">operator!=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a00bc5a2b4411833a1d5194a4b71e47a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a00bc5a2b4411833a1d5194a4b71e47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319d96ef6cd913b6119af477fee82050"><td class="memTemplParams" colspan="2"><a id="a319d96ef6cd913b6119af477fee82050"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a319d96ef6cd913b6119af477fee82050"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a319d96ef6cd913b6119af477fee82050">operator&lt;</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a319d96ef6cd913b6119af477fee82050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:a319d96ef6cd913b6119af477fee82050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad090e6512aa2fa77b4b9e2fd6f7bb648"><td class="memTemplParams" colspan="2"><a id="ad090e6512aa2fa77b4b9e2fd6f7bb648"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ad090e6512aa2fa77b4b9e2fd6f7bb648"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ad090e6512aa2fa77b4b9e2fd6f7bb648">operator&lt;=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad090e6512aa2fa77b4b9e2fd6f7bb648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:ad090e6512aa2fa77b4b9e2fd6f7bb648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6271a6f69c801e53a37155ae4917df97"><td class="memTemplParams" colspan="2"><a id="a6271a6f69c801e53a37155ae4917df97"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a6271a6f69c801e53a37155ae4917df97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6271a6f69c801e53a37155ae4917df97">operator&gt;</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6271a6f69c801e53a37155ae4917df97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:a6271a6f69c801e53a37155ae4917df97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade658a471dc5c46e32587a8768649a4a"><td class="memTemplParams" colspan="2"><a id="ade658a471dc5c46e32587a8768649a4a"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ade658a471dc5c46e32587a8768649a4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ade658a471dc5c46e32587a8768649a4a">operator&gt;=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ade658a471dc5c46e32587a8768649a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:ade658a471dc5c46e32587a8768649a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd8e0d8518f74ab21ec2bb9dd670abf"><td class="memTemplParams" colspan="2"><a id="a5dd8e0d8518f74ab21ec2bb9dd670abf"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a5dd8e0d8518f74ab21ec2bb9dd670abf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5dd8e0d8518f74ab21ec2bb9dd670abf">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5dd8e0d8518f74ab21ec2bb9dd670abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:a5dd8e0d8518f74ab21ec2bb9dd670abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96d050c246ff7d524cfbb7f1b5fd1f6"><td class="memTemplParams" colspan="2"><a id="ae96d050c246ff7d524cfbb7f1b5fd1f6"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ae96d050c246ff7d524cfbb7f1b5fd1f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae96d050c246ff7d524cfbb7f1b5fd1f6">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae96d050c246ff7d524cfbb7f1b5fd1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:ae96d050c246ff7d524cfbb7f1b5fd1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5bf9165eda29e065f6001d3427c00f"><td class="memTemplParams" colspan="2"><a id="a5e5bf9165eda29e065f6001d3427c00f"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a5e5bf9165eda29e065f6001d3427c00f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5e5bf9165eda29e065f6001d3427c00f">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5e5bf9165eda29e065f6001d3427c00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:a5e5bf9165eda29e065f6001d3427c00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3bd8b1d698933d71daecab48ef5fc1"><td class="memTemplParams" colspan="2"><a id="a7c3bd8b1d698933d71daecab48ef5fc1"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a7c3bd8b1d698933d71daecab48ef5fc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7c3bd8b1d698933d71daecab48ef5fc1">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7c3bd8b1d698933d71daecab48ef5fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:a7c3bd8b1d698933d71daecab48ef5fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e5ded10ff323f16976f3ee6d280046"><td class="memTemplParams" colspan="2"><a id="a25e5ded10ff323f16976f3ee6d280046"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a25e5ded10ff323f16976f3ee6d280046"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a25e5ded10ff323f16976f3ee6d280046">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a25e5ded10ff323f16976f3ee6d280046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:a25e5ded10ff323f16976f3ee6d280046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aeb2483da8ca1c8b3636d4b7d1c101f"><td class="memTemplParams" colspan="2"><a id="a9aeb2483da8ca1c8b3636d4b7d1c101f"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a9aeb2483da8ca1c8b3636d4b7d1c101f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a9aeb2483da8ca1c8b3636d4b7d1c101f">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9aeb2483da8ca1c8b3636d4b7d1c101f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:a9aeb2483da8ca1c8b3636d4b7d1c101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac417956be147954d7ac992ad8b6bd311"><td class="memTemplParams" colspan="2"><a id="ac417956be147954d7ac992ad8b6bd311"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ac417956be147954d7ac992ad8b6bd311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ac417956be147954d7ac992ad8b6bd311">swap</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac417956be147954d7ac992ad8b6bd311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the content of persistent strings. <br /></td></tr>
<tr class="separator:ac417956be147954d7ac992ad8b6bd311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2eaf529f99d9ee39c30b32ea8a82a965">swap</a> (<a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of lhs and rhs.  <a href="namespacepmem_1_1obj.html#a2eaf529f99d9ee39c30b32ea8a82a965">More...</a><br /></td></tr>
<tr class="separator:a2eaf529f99d9ee39c30b32ea8a82a965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4500f832c5be4483fb0664c870b7127b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a4500f832c5be4483fb0664c870b7127b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4500f832c5be4483fb0664c870b7127b">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4500f832c5be4483fb0664c870b7127b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a4500f832c5be4483fb0664c870b7127b">More...</a><br /></td></tr>
<tr class="separator:a4500f832c5be4483fb0664c870b7127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521f60b2723b9d069c4cc5af13bda399"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a521f60b2723b9d069c4cc5af13bda399"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a521f60b2723b9d069c4cc5af13bda399">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a521f60b2723b9d069c4cc5af13bda399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a521f60b2723b9d069c4cc5af13bda399">More...</a><br /></td></tr>
<tr class="separator:a521f60b2723b9d069c4cc5af13bda399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175622e13aec283fb56ca7ccedacf9b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a5175622e13aec283fb56ca7ccedacf9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5175622e13aec283fb56ca7ccedacf9b">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5175622e13aec283fb56ca7ccedacf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a5175622e13aec283fb56ca7ccedacf9b">More...</a><br /></td></tr>
<tr class="separator:a5175622e13aec283fb56ca7ccedacf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba953ad63f462d920bc79de271f39a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a1ba953ad63f462d920bc79de271f39a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1ba953ad63f462d920bc79de271f39a9">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1ba953ad63f462d920bc79de271f39a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a1ba953ad63f462d920bc79de271f39a9">More...</a><br /></td></tr>
<tr class="separator:a1ba953ad63f462d920bc79de271f39a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a16b8bf77fa26fc0afcc40b6a3aed7e79">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a16b8bf77fa26fc0afcc40b6a3aed7e79">More...</a><br /></td></tr>
<tr class="separator:a16b8bf77fa26fc0afcc40b6a3aed7e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a840c5a7d0056269dbaef5a43af74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a463a840c5a7d0056269dbaef5a43af74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a463a840c5a7d0056269dbaef5a43af74">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a463a840c5a7d0056269dbaef5a43af74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a463a840c5a7d0056269dbaef5a43af74">More...</a><br /></td></tr>
<tr class="separator:a463a840c5a7d0056269dbaef5a43af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae5d793d76be641b82a1ffa96bbf4c06c">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#ae5d793d76be641b82a1ffa96bbf4c06c">More...</a><br /></td></tr>
<tr class="separator:ae5d793d76be641b82a1ffa96bbf4c06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#adb72e4a3d5ebcdf650ca64a14b89eeec">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#adb72e4a3d5ebcdf650ca64a14b89eeec">More...</a><br /></td></tr>
<tr class="separator:adb72e4a3d5ebcdf650ca64a14b89eeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a26c3d5b212ac54fbc0d5ad9e9ce5685b">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a26c3d5b212ac54fbc0d5ad9e9ce5685b">More...</a><br /></td></tr>
<tr class="separator:a26c3d5b212ac54fbc0d5ad9e9ce5685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433769b18c43b2b1ca9fcb25c62b203f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a433769b18c43b2b1ca9fcb25c62b203f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a433769b18c43b2b1ca9fcb25c62b203f">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a433769b18c43b2b1ca9fcb25c62b203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a433769b18c43b2b1ca9fcb25c62b203f">More...</a><br /></td></tr>
<tr class="separator:a433769b18c43b2b1ca9fcb25c62b203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9305236fa00130f6d27bacd5fb93c4ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a9305236fa00130f6d27bacd5fb93c4ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a9305236fa00130f6d27bacd5fb93c4ee">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9305236fa00130f6d27bacd5fb93c4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a9305236fa00130f6d27bacd5fb93c4ee">More...</a><br /></td></tr>
<tr class="separator:a9305236fa00130f6d27bacd5fb93c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eb19512a32487e9294c25219e3c234"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:ab7eb19512a32487e9294c25219e3c234"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ab7eb19512a32487e9294c25219e3c234">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab7eb19512a32487e9294c25219e3c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#ab7eb19512a32487e9294c25219e3c234">More...</a><br /></td></tr>
<tr class="separator:ab7eb19512a32487e9294c25219e3c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2b6f5b69d0d397ba27c0035cafce8bec">operator==</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a2b6f5b69d0d397ba27c0035cafce8bec">More...</a><br /></td></tr>
<tr class="separator:a2b6f5b69d0d397ba27c0035cafce8bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613a93583aec0a95ffb9145fd21fa1c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a613a93583aec0a95ffb9145fd21fa1c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a613a93583aec0a95ffb9145fd21fa1c3">operator!=</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a613a93583aec0a95ffb9145fd21fa1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a613a93583aec0a95ffb9145fd21fa1c3">More...</a><br /></td></tr>
<tr class="separator:a613a93583aec0a95ffb9145fd21fa1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e6aab454db03fee92e3b417ea94bd0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a89e6aab454db03fee92e3b417ea94bd0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a89e6aab454db03fee92e3b417ea94bd0">operator&lt;</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a89e6aab454db03fee92e3b417ea94bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a89e6aab454db03fee92e3b417ea94bd0">More...</a><br /></td></tr>
<tr class="separator:a89e6aab454db03fee92e3b417ea94bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f62693161b852a8a897973f0ea67cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a84f62693161b852a8a897973f0ea67cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a84f62693161b852a8a897973f0ea67cb">operator&lt;=</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a84f62693161b852a8a897973f0ea67cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a84f62693161b852a8a897973f0ea67cb">More...</a><br /></td></tr>
<tr class="separator:a84f62693161b852a8a897973f0ea67cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#acfe18f4fe61e0fbe10034f84a4b3a691">operator&gt;</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#acfe18f4fe61e0fbe10034f84a4b3a691">More...</a><br /></td></tr>
<tr class="separator:acfe18f4fe61e0fbe10034f84a4b3a691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed237e8ec30fc8cd3efbf780eb476125"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:aed237e8ec30fc8cd3efbf780eb476125"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aed237e8ec30fc8cd3efbf780eb476125">operator&gt;=</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aed237e8ec30fc8cd3efbf780eb476125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#aed237e8ec30fc8cd3efbf780eb476125">More...</a><br /></td></tr>
<tr class="separator:aed237e8ec30fc8cd3efbf780eb476125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a46a6c5333f2e9859d6f152f1dc8f1832">swap</a> (<a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of lhs and rhs.  <a href="namespacepmem_1_1obj.html#a46a6c5333f2e9859d6f152f1dc8f1832">More...</a><br /></td></tr>
<tr class="separator:a46a6c5333f2e9859d6f152f1dc8f1832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7ea0da2be2d117a026e3fa58a3369d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae7ea0da2be2d117a026e3fa58a3369d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aae7ea0da2be2d117a026e3fa58a3369d">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aae7ea0da2be2d117a026e3fa58a3369d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#aae7ea0da2be2d117a026e3fa58a3369d">More...</a><br /></td></tr>
<tr class="separator:aae7ea0da2be2d117a026e3fa58a3369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399b4199506661eccff459a7a878f3d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a399b4199506661eccff459a7a878f3d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a399b4199506661eccff459a7a878f3d9">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a399b4199506661eccff459a7a878f3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a399b4199506661eccff459a7a878f3d9">More...</a><br /></td></tr>
<tr class="separator:a399b4199506661eccff459a7a878f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4bbcff4664436e0341275606b24314"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec4bbcff4664436e0341275606b24314"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aec4bbcff4664436e0341275606b24314">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aec4bbcff4664436e0341275606b24314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#aec4bbcff4664436e0341275606b24314">More...</a><br /></td></tr>
<tr class="separator:aec4bbcff4664436e0341275606b24314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6442bae353bd3aab4417d4db85995b07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6442bae353bd3aab4417d4db85995b07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6442bae353bd3aab4417d4db85995b07">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6442bae353bd3aab4417d4db85995b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a6442bae353bd3aab4417d4db85995b07">More...</a><br /></td></tr>
<tr class="separator:a6442bae353bd3aab4417d4db85995b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e824a963007146618891278f455c6df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e824a963007146618891278f455c6df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2e824a963007146618891278f455c6df">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2e824a963007146618891278f455c6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a2e824a963007146618891278f455c6df">More...</a><br /></td></tr>
<tr class="separator:a2e824a963007146618891278f455c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0311022343df6a9d6630d0025e99c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d0311022343df6a9d6630d0025e99c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4d0311022343df6a9d6630d0025e99c1">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4d0311022343df6a9d6630d0025e99c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a4d0311022343df6a9d6630d0025e99c1">More...</a><br /></td></tr>
<tr class="separator:a4d0311022343df6a9d6630d0025e99c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8f8bc8ee773cf3ba486df604a98504"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef8f8bc8ee773cf3ba486df604a98504"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aef8f8bc8ee773cf3ba486df604a98504">operator==</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aef8f8bc8ee773cf3ba486df604a98504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#aef8f8bc8ee773cf3ba486df604a98504">More...</a><br /></td></tr>
<tr class="separator:aef8f8bc8ee773cf3ba486df604a98504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1fcbd0d2822d3f235950b044d0da6ac2">operator!=</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a1fcbd0d2822d3f235950b044d0da6ac2">More...</a><br /></td></tr>
<tr class="separator:a1fcbd0d2822d3f235950b044d0da6ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6bc8b97b7a1b71404a4da7907cc0a695">operator&lt;</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a6bc8b97b7a1b71404a4da7907cc0a695">More...</a><br /></td></tr>
<tr class="separator:a6bc8b97b7a1b71404a4da7907cc0a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403e4fdd376acf1404d225856a6109f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4403e4fdd376acf1404d225856a6109f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4403e4fdd376acf1404d225856a6109f">operator&lt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4403e4fdd376acf1404d225856a6109f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a4403e4fdd376acf1404d225856a6109f">More...</a><br /></td></tr>
<tr class="separator:a4403e4fdd376acf1404d225856a6109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5bfc1cf4bc0871a89bc16487bd6a8484">operator&gt;</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a5bfc1cf4bc0871a89bc16487bd6a8484">More...</a><br /></td></tr>
<tr class="separator:a5bfc1cf4bc0871a89bc16487bd6a8484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cc30f96742b912f5c70bffcd87fe5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29cc30f96742b912f5c70bffcd87fe5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a29cc30f96742b912f5c70bffcd87fe5a">operator&gt;=</a> (const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a29cc30f96742b912f5c70bffcd87fe5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a29cc30f96742b912f5c70bffcd87fe5a">More...</a><br /></td></tr>
<tr class="separator:a29cc30f96742b912f5c70bffcd87fe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa7985535467845be5c2e4605bab72e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fa7985535467845be5c2e4605bab72e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5fa7985535467845be5c2e4605bab72e">operator==</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5fa7985535467845be5c2e4605bab72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a5fa7985535467845be5c2e4605bab72e">More...</a><br /></td></tr>
<tr class="separator:a5fa7985535467845be5c2e4605bab72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659d49015c82ef1dc044e2142224269d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a659d49015c82ef1dc044e2142224269d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a659d49015c82ef1dc044e2142224269d">operator!=</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a659d49015c82ef1dc044e2142224269d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a659d49015c82ef1dc044e2142224269d">More...</a><br /></td></tr>
<tr class="separator:a659d49015c82ef1dc044e2142224269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0dcb348e953ea0a5b1ed1a3f5c29d2dd">operator&lt;</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a0dcb348e953ea0a5b1ed1a3f5c29d2dd">More...</a><br /></td></tr>
<tr class="separator:a0dcb348e953ea0a5b1ed1a3f5c29d2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6137a8d89c6046241b600ab14a63b6de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6137a8d89c6046241b600ab14a63b6de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6137a8d89c6046241b600ab14a63b6de">operator&lt;=</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6137a8d89c6046241b600ab14a63b6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a6137a8d89c6046241b600ab14a63b6de">More...</a><br /></td></tr>
<tr class="separator:a6137a8d89c6046241b600ab14a63b6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ea4849c06b3f401ac3673ded5a3227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6ea4849c06b3f401ac3673ded5a3227"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ad6ea4849c06b3f401ac3673ded5a3227">operator&gt;</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad6ea4849c06b3f401ac3673ded5a3227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#ad6ea4849c06b3f401ac3673ded5a3227">More...</a><br /></td></tr>
<tr class="separator:ad6ea4849c06b3f401ac3673ded5a3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963062a2970d5133a82fa906f0b7eddd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a963062a2970d5133a82fa906f0b7eddd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a963062a2970d5133a82fa906f0b7eddd">operator&gt;=</a> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a963062a2970d5133a82fa906f0b7eddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespacepmem_1_1obj.html#a963062a2970d5133a82fa906f0b7eddd">More...</a><br /></td></tr>
<tr class="separator:a963062a2970d5133a82fa906f0b7eddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e090bf5d2b950fba759c7560c16e08e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9e090bf5d2b950fba759c7560c16e08e"><td class="memTemplItemLeft" align="right" valign="top">detail::pp_if_not_array&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a9e090bf5d2b950fba759c7560c16e08e">make_persistent</a> (<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a> flag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9e090bf5d2b950fba759c7560c16e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an object of type T.  <a href="namespacepmem_1_1obj.html#a9e090bf5d2b950fba759c7560c16e08e">More...</a><br /></td></tr>
<tr class="separator:a9e090bf5d2b950fba759c7560c16e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77252820ae5e37021b008009c2ec17ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a77252820ae5e37021b008009c2ec17ed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !detail::is_first_arg_same&lt; <a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a>, Args... &gt;::value, typename detail::pp_if_not_array&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a77252820ae5e37021b008009c2ec17ed">make_persistent</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a77252820ae5e37021b008009c2ec17ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an object of type T.  <a href="namespacepmem_1_1obj.html#a77252820ae5e37021b008009c2ec17ed">More...</a><br /></td></tr>
<tr class="separator:a77252820ae5e37021b008009c2ec17ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714693f9ebbc9db6cd47ee40e10ccbaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a714693f9ebbc9db6cd47ee40e10ccbaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a714693f9ebbc9db6cd47ee40e10ccbaf">delete_persistent</a> (typename detail::pp_if_not_array&lt; T &gt;::type ptr)</td></tr>
<tr class="memdesc:a714693f9ebbc9db6cd47ee40e10ccbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally free an object of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a714693f9ebbc9db6cd47ee40e10ccbaf">More...</a><br /></td></tr>
<tr class="separator:a714693f9ebbc9db6cd47ee40e10ccbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3504b5f576c05b190770ae0e4b528"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fe3504b5f576c05b190770ae0e4b528"><td class="memTemplItemLeft" align="right" valign="top">detail::pp_if_array&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a8fe3504b5f576c05b190770ae0e4b528">make_persistent</a> (std::size_t N, <a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html#ae89f1ed6c125d3bd67fd33c0cff27c76">allocation_flag::none</a>())</td></tr>
<tr class="memdesc:a8fe3504b5f576c05b190770ae0e4b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an array of objects of type T.  <a href="namespacepmem_1_1obj.html#a8fe3504b5f576c05b190770ae0e4b528">More...</a><br /></td></tr>
<tr class="separator:a8fe3504b5f576c05b190770ae0e4b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0799ef351bd641499230292365d427a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0799ef351bd641499230292365d427a7"><td class="memTemplItemLeft" align="right" valign="top">detail::pp_if_size_array&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0799ef351bd641499230292365d427a7">make_persistent</a> (<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html#ae89f1ed6c125d3bd67fd33c0cff27c76">allocation_flag::none</a>())</td></tr>
<tr class="memdesc:a0799ef351bd641499230292365d427a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally allocate and construct an array of objects of type T.  <a href="namespacepmem_1_1obj.html#a0799ef351bd641499230292365d427a7">More...</a><br /></td></tr>
<tr class="separator:a0799ef351bd641499230292365d427a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4222feb628a4d6f8ac2b3a5dbe42c5e6">delete_persistent</a> (typename detail::pp_if_array&lt; T &gt;::type ptr, std::size_t N)</td></tr>
<tr class="memdesc:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a4222feb628a4d6f8ac2b3a5dbe42c5e6">More...</a><br /></td></tr>
<tr class="separator:a4222feb628a4d6f8ac2b3a5dbe42c5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5582033bf768fea635b40b3ba766fbef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5582033bf768fea635b40b3ba766fbef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5582033bf768fea635b40b3ba766fbef">delete_persistent</a> (typename detail::pp_if_size_array&lt; T &gt;::type ptr)</td></tr>
<tr class="memdesc:a5582033bf768fea635b40b3ba766fbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a5582033bf768fea635b40b3ba766fbef">More...</a><br /></td></tr>
<tr class="separator:a5582033bf768fea635b40b3ba766fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b14ac5b07d58902df4c24deb7096d12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b14ac5b07d58902df4c24deb7096d12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7b14ac5b07d58902df4c24deb7096d12">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_array&lt; T &gt;::type &amp;ptr, std::size_t N, <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>())</td></tr>
<tr class="memdesc:a7b14ac5b07d58902df4c24deb7096d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate an array of objects.  <a href="namespacepmem_1_1obj.html#a7b14ac5b07d58902df4c24deb7096d12">More...</a><br /></td></tr>
<tr class="separator:a7b14ac5b07d58902df4c24deb7096d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d456157a9ddd13772036944fab68b01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d456157a9ddd13772036944fab68b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1d456157a9ddd13772036944fab68b01">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_size_array&lt; T &gt;::type &amp;ptr, <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a> flag=<a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>())</td></tr>
<tr class="memdesc:a1d456157a9ddd13772036944fab68b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate an array of objects.  <a href="namespacepmem_1_1obj.html#a1d456157a9ddd13772036944fab68b01">More...</a><br /></td></tr>
<tr class="separator:a1d456157a9ddd13772036944fab68b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2009e20a7365ba802a5f1acbff2f2336"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2009e20a7365ba802a5f1acbff2f2336"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2009e20a7365ba802a5f1acbff2f2336">delete_persistent_atomic</a> (typename detail::pp_if_array&lt; T &gt;::type &amp;ptr, std::size_t)</td></tr>
<tr class="memdesc:a2009e20a7365ba802a5f1acbff2f2336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deallocate an array of objects.  <a href="namespacepmem_1_1obj.html#a2009e20a7365ba802a5f1acbff2f2336">More...</a><br /></td></tr>
<tr class="separator:a2009e20a7365ba802a5f1acbff2f2336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774f709132747433efe83cf8060186a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a774f709132747433efe83cf8060186a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a774f709132747433efe83cf8060186a3">delete_persistent_atomic</a> (typename detail::pp_if_size_array&lt; T &gt;::type &amp;ptr)</td></tr>
<tr class="memdesc:a774f709132747433efe83cf8060186a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deallocate an array of objects.  <a href="namespacepmem_1_1obj.html#a774f709132747433efe83cf8060186a3">More...</a><br /></td></tr>
<tr class="separator:a774f709132747433efe83cf8060186a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b463d8cf7358dda467d0f63e130d410"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a6b463d8cf7358dda467d0f63e130d410"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6b463d8cf7358dda467d0f63e130d410">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_not_array&lt; T &gt;::type &amp;ptr, <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a> flag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6b463d8cf7358dda467d0f63e130d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate and construct an object.  <a href="namespacepmem_1_1obj.html#a6b463d8cf7358dda467d0f63e130d410">More...</a><br /></td></tr>
<tr class="separator:a6b463d8cf7358dda467d0f63e130d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b6596bf5b91ebcc5fbaeb899d59599"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa2b6596bf5b91ebcc5fbaeb899d59599"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!detail::is_first_arg_same&lt; <a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>, Args... &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa2b6596bf5b91ebcc5fbaeb899d59599">make_persistent_atomic</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, typename detail::pp_if_not_array&lt; T &gt;::type &amp;ptr, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa2b6596bf5b91ebcc5fbaeb899d59599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically allocate and construct an object.  <a href="namespacepmem_1_1obj.html#aa2b6596bf5b91ebcc5fbaeb899d59599">More...</a><br /></td></tr>
<tr class="separator:aa2b6596bf5b91ebcc5fbaeb899d59599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa55bbcf44c93a0ca9a8965cded6e40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2aa55bbcf44c93a0ca9a8965cded6e40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2aa55bbcf44c93a0ca9a8965cded6e40">delete_persistent_atomic</a> (typename detail::pp_if_not_array&lt; T &gt;::type &amp;ptr) noexcept</td></tr>
<tr class="memdesc:a2aa55bbcf44c93a0ca9a8965cded6e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deallocate an object.  <a href="namespacepmem_1_1obj.html#a2aa55bbcf44c93a0ca9a8965cded6e40">More...</a><br /></td></tr>
<tr class="separator:a2aa55bbcf44c93a0ca9a8965cded6e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1f540f252cd5ae5601c691f53ecbb7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e1f540f252cd5ae5601c691f53ecbb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5e1f540f252cd5ae5601c691f53ecbb7">swap</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;a, <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a5e1f540f252cd5ae5601c691f53ecbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two p objects of the same type.  <a href="namespacepmem_1_1obj.html#a5e1f540f252cd5ae5601c691f53ecbb7">More...</a><br /></td></tr>
<tr class="separator:a5e1f540f252cd5ae5601c691f53ecbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d6e952280db13f57d69be1b816d21c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a28d6e952280db13f57d69be1b816d21c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a28d6e952280db13f57d69be1b816d21c">swap</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;a, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a28d6e952280db13f57d69be1b816d21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> objects of the same type.  <a href="namespacepmem_1_1obj.html#a28d6e952280db13f57d69be1b816d21c">More...</a><br /></td></tr>
<tr class="separator:a28d6e952280db13f57d69be1b816d21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c125ea043799ff6da2d44199cae94fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a3c125ea043799ff6da2d44199cae94fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a3c125ea043799ff6da2d44199cae94fc">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3c125ea043799ff6da2d44199cae94fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="namespacepmem_1_1obj.html#a3c125ea043799ff6da2d44199cae94fc">More...</a><br /></td></tr>
<tr class="separator:a3c125ea043799ff6da2d44199cae94fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f75da0b0c0f33e70bf063d076ca795"><td class="memTemplParams" colspan="2"><a id="a13f75da0b0c0f33e70bf063d076ca795"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a13f75da0b0c0f33e70bf063d076ca795"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a13f75da0b0c0f33e70bf063d076ca795">operator!=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a13f75da0b0c0f33e70bf063d076ca795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a13f75da0b0c0f33e70bf063d076ca795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d3883f8baf1ad981545d1fec7583f8"><td class="memTemplParams" colspan="2"><a id="a21d3883f8baf1ad981545d1fec7583f8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21d3883f8baf1ad981545d1fec7583f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a21d3883f8baf1ad981545d1fec7583f8">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a21d3883f8baf1ad981545d1fec7583f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator with nullptr. <br /></td></tr>
<tr class="separator:a21d3883f8baf1ad981545d1fec7583f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bde8e9553ad80ff4dc0c4d57895f7eb"><td class="memTemplParams" colspan="2"><a id="a4bde8e9553ad80ff4dc0c4d57895f7eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bde8e9553ad80ff4dc0c4d57895f7eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4bde8e9553ad80ff4dc0c4d57895f7eb">operator==</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs) noexcept</td></tr>
<tr class="memdesc:a4bde8e9553ad80ff4dc0c4d57895f7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator with nullptr. <br /></td></tr>
<tr class="separator:a4bde8e9553ad80ff4dc0c4d57895f7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1159c38406f6f82f34f7f5368e0c75eb"><td class="memTemplParams" colspan="2"><a id="a1159c38406f6f82f34f7f5368e0c75eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1159c38406f6f82f34f7f5368e0c75eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1159c38406f6f82f34f7f5368e0c75eb">operator!=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a1159c38406f6f82f34f7f5368e0c75eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator with nullptr. <br /></td></tr>
<tr class="separator:a1159c38406f6f82f34f7f5368e0c75eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a84b043623659a1a5d2b141613cdc6"><td class="memTemplParams" colspan="2"><a id="a22a84b043623659a1a5d2b141613cdc6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22a84b043623659a1a5d2b141613cdc6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a22a84b043623659a1a5d2b141613cdc6">operator!=</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs) noexcept</td></tr>
<tr class="memdesc:a22a84b043623659a1a5d2b141613cdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator with nullptr. <br /></td></tr>
<tr class="separator:a22a84b043623659a1a5d2b141613cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fd05c4944d079ea05dd0cb5b203b75"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a49fd05c4944d079ea05dd0cb5b203b75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a49fd05c4944d079ea05dd0cb5b203b75">operator&lt;</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a49fd05c4944d079ea05dd0cb5b203b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator.  <a href="namespacepmem_1_1obj.html#a49fd05c4944d079ea05dd0cb5b203b75">More...</a><br /></td></tr>
<tr class="separator:a49fd05c4944d079ea05dd0cb5b203b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48591ec64f0a18f0f81c9c7c79b265a3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a48591ec64f0a18f0f81c9c7c79b265a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a48591ec64f0a18f0f81c9c7c79b265a3">operator&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a48591ec64f0a18f0f81c9c7c79b265a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less or equal than operator.  <a href="namespacepmem_1_1obj.html#a48591ec64f0a18f0f81c9c7c79b265a3">More...</a><br /></td></tr>
<tr class="separator:a48591ec64f0a18f0f81c9c7c79b265a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2a880e3da360c959414e7ea9268456"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a4b2a880e3da360c959414e7ea9268456"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a4b2a880e3da360c959414e7ea9268456">operator&gt;</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4b2a880e3da360c959414e7ea9268456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator.  <a href="namespacepmem_1_1obj.html#a4b2a880e3da360c959414e7ea9268456">More...</a><br /></td></tr>
<tr class="separator:a4b2a880e3da360c959414e7ea9268456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696298dbdd381bae03541da80cbe485d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a696298dbdd381bae03541da80cbe485d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a696298dbdd381bae03541da80cbe485d">operator&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a696298dbdd381bae03541da80cbe485d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater or equal than operator.  <a href="namespacepmem_1_1obj.html#a696298dbdd381bae03541da80cbe485d">More...</a><br /></td></tr>
<tr class="separator:a696298dbdd381bae03541da80cbe485d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27abfc79d802449de289cfe2e88361c1"><td class="memTemplParams" colspan="2"><a id="a27abfc79d802449de289cfe2e88361c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27abfc79d802449de289cfe2e88361c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a27abfc79d802449de289cfe2e88361c1">operator&lt;</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a27abfc79d802449de289cfe2e88361c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a27abfc79d802449de289cfe2e88361c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b647ea69db1328f31e62154ce1d6fd"><td class="memTemplParams" colspan="2"><a id="a56b647ea69db1328f31e62154ce1d6fd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56b647ea69db1328f31e62154ce1d6fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a56b647ea69db1328f31e62154ce1d6fd">operator&lt;</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a56b647ea69db1328f31e62154ce1d6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a56b647ea69db1328f31e62154ce1d6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64861e21a6605629695f095bbe5c7410"><td class="memTemplParams" colspan="2"><a id="a64861e21a6605629695f095bbe5c7410"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64861e21a6605629695f095bbe5c7410"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a64861e21a6605629695f095bbe5c7410">operator&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a64861e21a6605629695f095bbe5c7410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a64861e21a6605629695f095bbe5c7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9acbe58254818adf7020954bef2b68"><td class="memTemplParams" colspan="2"><a id="a0f9acbe58254818adf7020954bef2b68"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f9acbe58254818adf7020954bef2b68"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0f9acbe58254818adf7020954bef2b68">operator&lt;=</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0f9acbe58254818adf7020954bef2b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a0f9acbe58254818adf7020954bef2b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b3e9171cdf63a8b4079ed074ae5c8c"><td class="memTemplParams" colspan="2"><a id="af8b3e9171cdf63a8b4079ed074ae5c8c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8b3e9171cdf63a8b4079ed074ae5c8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af8b3e9171cdf63a8b4079ed074ae5c8c">operator&gt;</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:af8b3e9171cdf63a8b4079ed074ae5c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:af8b3e9171cdf63a8b4079ed074ae5c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e4d4e7e1e419c60fd059942ac6920b"><td class="memTemplParams" colspan="2"><a id="a65e4d4e7e1e419c60fd059942ac6920b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65e4d4e7e1e419c60fd059942ac6920b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a65e4d4e7e1e419c60fd059942ac6920b">operator&gt;</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a65e4d4e7e1e419c60fd059942ac6920b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:a65e4d4e7e1e419c60fd059942ac6920b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48fe28bf817a7128c869d7562d66b53"><td class="memTemplParams" colspan="2"><a id="ae48fe28bf817a7128c869d7562d66b53"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae48fe28bf817a7128c869d7562d66b53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae48fe28bf817a7128c869d7562d66b53">operator&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:ae48fe28bf817a7128c869d7562d66b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:ae48fe28bf817a7128c869d7562d66b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1a2388280266f43940d6d16a4a38ca"><td class="memTemplParams" colspan="2"><a id="aaa1a2388280266f43940d6d16a4a38ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa1a2388280266f43940d6d16a4a38ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aaa1a2388280266f43940d6d16a4a38ca">operator&gt;=</a> (std::nullptr_t, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aaa1a2388280266f43940d6d16a4a38ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> with a null pointer. <br /></td></tr>
<tr class="separator:aaa1a2388280266f43940d6d16a4a38ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d20c2164aec5110f85555477b01e3b"><td class="memTemplParams" colspan="2"><a id="a42d20c2164aec5110f85555477b01e3b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42d20c2164aec5110f85555477b01e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a42d20c2164aec5110f85555477b01e3b">operator+</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a42d20c2164aec5110f85555477b01e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for persistent pointers. <br /></td></tr>
<tr class="separator:a42d20c2164aec5110f85555477b01e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bace565133c41301ae02de3276920ef"><td class="memTemplParams" colspan="2"><a id="a1bace565133c41301ae02de3276920ef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1bace565133c41301ae02de3276920ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1bace565133c41301ae02de3276920ef">operator-</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a1bace565133c41301ae02de3276920ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for persistent pointers. <br /></td></tr>
<tr class="separator:a1bace565133c41301ae02de3276920ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4f2831cd0b0a9b8906f8413b282551"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y , typename  = typename std::enable_if&lt;		  std::is_same&lt;typename std::remove_cv&lt;T&gt;::type,			       typename std::remove_cv&lt;Y&gt;::type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a9e4f2831cd0b0a9b8906f8413b282551"><td class="memTemplItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a9e4f2831cd0b0a9b8906f8413b282551">operator-</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a9e4f2831cd0b0a9b8906f8413b282551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for persistent pointers of identical type.  <a href="namespacepmem_1_1obj.html#a9e4f2831cd0b0a9b8906f8413b282551">More...</a><br /></td></tr>
<tr class="separator:a9e4f2831cd0b0a9b8906f8413b282551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f38d4fb7dcf9ddf765fa9cef5aa10ce"><td class="memTemplParams" colspan="2"><a id="a3f38d4fb7dcf9ddf765fa9cef5aa10ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f38d4fb7dcf9ddf765fa9cef5aa10ce"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a3f38d4fb7dcf9ddf765fa9cef5aa10ce">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;pptr)</td></tr>
<tr class="memdesc:a3f38d4fb7dcf9ddf765fa9cef5aa10ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ostream operator for the persistent pointer. <br /></td></tr>
<tr class="separator:a3f38d4fb7dcf9ddf765fa9cef5aa10ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8ed9ad1d46e5a9dea1602bd525e5ff"><td class="memTemplParams" colspan="2"><a id="add8ed9ad1d46e5a9dea1602bd525e5ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add8ed9ad1d46e5a9dea1602bd525e5ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#add8ed9ad1d46e5a9dea1602bd525e5ff">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;pp)</td></tr>
<tr class="memdesc:add8ed9ad1d46e5a9dea1602bd525e5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ostream operator overload. <br /></td></tr>
<tr class="separator:add8ed9ad1d46e5a9dea1602bd525e5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0415ef08132d251744ac2c94eddf8b9"><td class="memTemplParams" colspan="2"><a id="af0415ef08132d251744ac2c94eddf8b9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0415ef08132d251744ac2c94eddf8b9"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af0415ef08132d251744ac2c94eddf8b9">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;pp)</td></tr>
<tr class="memdesc:af0415ef08132d251744ac2c94eddf8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Istream operator overload. <br /></td></tr>
<tr class="separator:af0415ef08132d251744ac2c94eddf8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f59f7775441952b264b2297a8e0ead0"><td class="memTemplParams" colspan="2"><a id="a5f59f7775441952b264b2297a8e0ead0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f59f7775441952b264b2297a8e0ead0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5f59f7775441952b264b2297a8e0ead0">operator++</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;pp)</td></tr>
<tr class="memdesc:a5f59f7775441952b264b2297a8e0ead0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator overload. <br /></td></tr>
<tr class="separator:a5f59f7775441952b264b2297a8e0ead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72906abaf063550b2ac46c9929b8a1be"><td class="memTemplParams" colspan="2"><a id="a72906abaf063550b2ac46c9929b8a1be"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72906abaf063550b2ac46c9929b8a1be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a72906abaf063550b2ac46c9929b8a1be">operator--</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;pp)</td></tr>
<tr class="memdesc:a72906abaf063550b2ac46c9929b8a1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator overload. <br /></td></tr>
<tr class="separator:a72906abaf063550b2ac46c9929b8a1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5af14c3eb19fb0fe5ab33c46e7f879"><td class="memTemplParams" colspan="2"><a id="afb5af14c3eb19fb0fe5ab33c46e7f879"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb5af14c3eb19fb0fe5ab33c46e7f879"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#afb5af14c3eb19fb0fe5ab33c46e7f879">operator++</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;pp, int)</td></tr>
<tr class="memdesc:afb5af14c3eb19fb0fe5ab33c46e7f879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator overload. <br /></td></tr>
<tr class="separator:afb5af14c3eb19fb0fe5ab33c46e7f879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446c2ce926803f76ccc05cc949c473da"><td class="memTemplParams" colspan="2"><a id="a446c2ce926803f76ccc05cc949c473da"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a446c2ce926803f76ccc05cc949c473da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a446c2ce926803f76ccc05cc949c473da">operator--</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;pp, int)</td></tr>
<tr class="memdesc:a446c2ce926803f76ccc05cc949c473da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator overload. <br /></td></tr>
<tr class="separator:a446c2ce926803f76ccc05cc949c473da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be0a1cb9e0c8e82a9871f00718b6db2"><td class="memTemplParams" colspan="2"><a id="a1be0a1cb9e0c8e82a9871f00718b6db2"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a1be0a1cb9e0c8e82a9871f00718b6db2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1be0a1cb9e0c8e82a9871f00718b6db2">operator+=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1be0a1cb9e0c8e82a9871f00718b6db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator overload. <br /></td></tr>
<tr class="separator:a1be0a1cb9e0c8e82a9871f00718b6db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b9e7a1e1aabf01366665d6237f6d6"><td class="memTemplParams" colspan="2"><a id="a192b9e7a1e1aabf01366665d6237f6d6"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a192b9e7a1e1aabf01366665d6237f6d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a192b9e7a1e1aabf01366665d6237f6d6">operator+=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:a192b9e7a1e1aabf01366665d6237f6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator overload. <br /></td></tr>
<tr class="separator:a192b9e7a1e1aabf01366665d6237f6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15073e7f91143b78c638cc69c1f740f"><td class="memTemplParams" colspan="2"><a id="ae15073e7f91143b78c638cc69c1f740f"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:ae15073e7f91143b78c638cc69c1f740f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae15073e7f91143b78c638cc69c1f740f">operator-=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae15073e7f91143b78c638cc69c1f740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator overload. <br /></td></tr>
<tr class="separator:ae15073e7f91143b78c638cc69c1f740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4cf940aff5286eb636a018e72cff96"><td class="memTemplParams" colspan="2"><a id="afb4cf940aff5286eb636a018e72cff96"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:afb4cf940aff5286eb636a018e72cff96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#afb4cf940aff5286eb636a018e72cff96">operator-=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:afb4cf940aff5286eb636a018e72cff96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator overload. <br /></td></tr>
<tr class="separator:afb4cf940aff5286eb636a018e72cff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbf080c7e2403d918ad71af02c50a8d"><td class="memTemplParams" colspan="2"><a id="a8bbf080c7e2403d918ad71af02c50a8d"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a8bbf080c7e2403d918ad71af02c50a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a8bbf080c7e2403d918ad71af02c50a8d">operator*=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8bbf080c7e2403d918ad71af02c50a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator overload. <br /></td></tr>
<tr class="separator:a8bbf080c7e2403d918ad71af02c50a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8913cf041190860a6f4fcfe83d313f"><td class="memTemplParams" colspan="2"><a id="a0d8913cf041190860a6f4fcfe83d313f"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a0d8913cf041190860a6f4fcfe83d313f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0d8913cf041190860a6f4fcfe83d313f">operator*=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:a0d8913cf041190860a6f4fcfe83d313f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator overload. <br /></td></tr>
<tr class="separator:a0d8913cf041190860a6f4fcfe83d313f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c62d6c77b09e6946dbffee550071ad2"><td class="memTemplParams" colspan="2"><a id="a8c62d6c77b09e6946dbffee550071ad2"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a8c62d6c77b09e6946dbffee550071ad2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a8c62d6c77b09e6946dbffee550071ad2">operator/=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8c62d6c77b09e6946dbffee550071ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator overload. <br /></td></tr>
<tr class="separator:a8c62d6c77b09e6946dbffee550071ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abefd6502d616f5c6a4286b568c9a37"><td class="memTemplParams" colspan="2"><a id="a5abefd6502d616f5c6a4286b568c9a37"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a5abefd6502d616f5c6a4286b568c9a37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a5abefd6502d616f5c6a4286b568c9a37">operator/=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:a5abefd6502d616f5c6a4286b568c9a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator overload. <br /></td></tr>
<tr class="separator:a5abefd6502d616f5c6a4286b568c9a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc23d8228ba0f7fd6cf9d5cae4b1c315"><td class="memTemplParams" colspan="2"><a id="adc23d8228ba0f7fd6cf9d5cae4b1c315"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:adc23d8228ba0f7fd6cf9d5cae4b1c315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#adc23d8228ba0f7fd6cf9d5cae4b1c315">operator%=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adc23d8228ba0f7fd6cf9d5cae4b1c315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo assignment operator overload. <br /></td></tr>
<tr class="separator:adc23d8228ba0f7fd6cf9d5cae4b1c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7287dd51a96df006e6776297f5355b5f"><td class="memTemplParams" colspan="2"><a id="a7287dd51a96df006e6776297f5355b5f"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a7287dd51a96df006e6776297f5355b5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7287dd51a96df006e6776297f5355b5f">operator%=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:a7287dd51a96df006e6776297f5355b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo assignment operator overload. <br /></td></tr>
<tr class="separator:a7287dd51a96df006e6776297f5355b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da47fded32635dbb9bd610a38d5598f"><td class="memTemplParams" colspan="2"><a id="a2da47fded32635dbb9bd610a38d5598f"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a2da47fded32635dbb9bd610a38d5598f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a2da47fded32635dbb9bd610a38d5598f">operator&amp;=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2da47fded32635dbb9bd610a38d5598f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND assignment operator overload. <br /></td></tr>
<tr class="separator:a2da47fded32635dbb9bd610a38d5598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2609d0a9e27912abb182ecad0d706f8"><td class="memTemplParams" colspan="2"><a id="af2609d0a9e27912abb182ecad0d706f8"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:af2609d0a9e27912abb182ecad0d706f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af2609d0a9e27912abb182ecad0d706f8">operator&amp;=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:af2609d0a9e27912abb182ecad0d706f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND assignment operator overload. <br /></td></tr>
<tr class="separator:af2609d0a9e27912abb182ecad0d706f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db9d1ab33cb1d76a88a54e0987e7607"><td class="memTemplParams" colspan="2"><a id="a8db9d1ab33cb1d76a88a54e0987e7607"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a8db9d1ab33cb1d76a88a54e0987e7607"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a8db9d1ab33cb1d76a88a54e0987e7607">operator|=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8db9d1ab33cb1d76a88a54e0987e7607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR assignment operator overload. <br /></td></tr>
<tr class="separator:a8db9d1ab33cb1d76a88a54e0987e7607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeceac6dd4af294c4f0d4b7b3cef3a8e"><td class="memTemplParams" colspan="2"><a id="aaeceac6dd4af294c4f0d4b7b3cef3a8e"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:aaeceac6dd4af294c4f0d4b7b3cef3a8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aaeceac6dd4af294c4f0d4b7b3cef3a8e">operator|=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:aaeceac6dd4af294c4f0d4b7b3cef3a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR assignment operator overload. <br /></td></tr>
<tr class="separator:aaeceac6dd4af294c4f0d4b7b3cef3a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ee348adf5de65691bf69f0112b589f"><td class="memTemplParams" colspan="2"><a id="ac3ee348adf5de65691bf69f0112b589f"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:ac3ee348adf5de65691bf69f0112b589f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ac3ee348adf5de65691bf69f0112b589f">operator^=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac3ee348adf5de65691bf69f0112b589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR assignment operator overload. <br /></td></tr>
<tr class="separator:ac3ee348adf5de65691bf69f0112b589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d623bc814c8f148e846ff1778e975e"><td class="memTemplParams" colspan="2"><a id="af6d623bc814c8f148e846ff1778e975e"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:af6d623bc814c8f148e846ff1778e975e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#af6d623bc814c8f148e846ff1778e975e">operator^=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:af6d623bc814c8f148e846ff1778e975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR assignment operator overload. <br /></td></tr>
<tr class="separator:af6d623bc814c8f148e846ff1778e975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62aa934e39396d3c5cee0df1b0e6ef7"><td class="memTemplParams" colspan="2"><a id="ab62aa934e39396d3c5cee0df1b0e6ef7"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:ab62aa934e39396d3c5cee0df1b0e6ef7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ab62aa934e39396d3c5cee0df1b0e6ef7">operator&lt;&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab62aa934e39396d3c5cee0df1b0e6ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift assignment operator overload. <br /></td></tr>
<tr class="separator:ab62aa934e39396d3c5cee0df1b0e6ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286ce9a5c064d72b2fa4b943e06a9624"><td class="memTemplParams" colspan="2"><a id="a286ce9a5c064d72b2fa4b943e06a9624"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a286ce9a5c064d72b2fa4b943e06a9624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a286ce9a5c064d72b2fa4b943e06a9624">operator&lt;&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:a286ce9a5c064d72b2fa4b943e06a9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift assignment operator overload. <br /></td></tr>
<tr class="separator:a286ce9a5c064d72b2fa4b943e06a9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2b94bbdf4762d9cfc040b0a064ec0"><td class="memTemplParams" colspan="2"><a id="a81e2b94bbdf4762d9cfc040b0a064ec0"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:a81e2b94bbdf4762d9cfc040b0a064ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a81e2b94bbdf4762d9cfc040b0a064ec0">operator&gt;&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; Y &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a81e2b94bbdf4762d9cfc040b0a064ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift assignment operator overload. <br /></td></tr>
<tr class="separator:a81e2b94bbdf4762d9cfc040b0a064ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed94935b505eecdecba31a6a538dddcc"><td class="memTemplParams" colspan="2"><a id="aed94935b505eecdecba31a6a538dddcc"></a>
template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:aed94935b505eecdecba31a6a538dddcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aed94935b505eecdecba31a6a538dddcc">operator&gt;&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;lhs, const Y &amp;rhs)</td></tr>
<tr class="memdesc:aed94935b505eecdecba31a6a538dddcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift assignment operator overload. <br /></td></tr>
<tr class="separator:aed94935b505eecdecba31a6a538dddcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89f45b433f00601332cc8b026c8094b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa89f45b433f00601332cc8b026c8094b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa89f45b433f00601332cc8b026c8094b">ctl_get</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa89f45b433f00601332cc8b026c8094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#aa89f45b433f00601332cc8b026c8094b">More...</a><br /></td></tr>
<tr class="separator:aa89f45b433f00601332cc8b026c8094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a35c4923f7973d6d9eeefdc6eeb16a4f1">ctl_set</a> (const std::string &amp;name, T arg)</td></tr>
<tr class="memdesc:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#a35c4923f7973d6d9eeefdc6eeb16a4f1">More...</a><br /></td></tr>
<tr class="separator:a35c4923f7973d6d9eeefdc6eeb16a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5828e2ef9f44c67de727e4498c89f1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5828e2ef9f44c67de727e4498c89f1f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ae5828e2ef9f44c67de727e4498c89f1f">ctl_exec</a> (const std::string &amp;name, T arg)</td></tr>
<tr class="memdesc:ae5828e2ef9f44c67de727e4498c89f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at global scope.  <a href="namespacepmem_1_1obj.html#ae5828e2ef9f44c67de727e4498c89f1f">More...</a><br /></td></tr>
<tr class="separator:ae5828e2ef9f44c67de727e4498c89f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64434e59ff1de9be9e73a9eb8d364b45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64434e59ff1de9be9e73a9eb8d364b45"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a64434e59ff1de9be9e73a9eb8d364b45">ctl_get</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:a64434e59ff1de9be9e73a9eb8d364b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#a64434e59ff1de9be9e73a9eb8d364b45">More...</a><br /></td></tr>
<tr class="separator:a64434e59ff1de9be9e73a9eb8d364b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3269602e36bbce39e864116f35aa7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb3269602e36bbce39e864116f35aa7e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#adb3269602e36bbce39e864116f35aa7e">ctl_set</a> (const std::wstring &amp;name, T arg)</td></tr>
<tr class="memdesc:adb3269602e36bbce39e864116f35aa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at global scope.  <a href="namespacepmem_1_1obj.html#adb3269602e36bbce39e864116f35aa7e">More...</a><br /></td></tr>
<tr class="separator:adb3269602e36bbce39e864116f35aa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c488369b0b5864774ebe7ab4e33d78a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c488369b0b5864774ebe7ab4e33d78a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a6c488369b0b5864774ebe7ab4e33d78a">ctl_exec</a> (const std::wstring &amp;name, T arg)</td></tr>
<tr class="memdesc:a6c488369b0b5864774ebe7ab4e33d78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at global scope.  <a href="namespacepmem_1_1obj.html#a6c488369b0b5864774ebe7ab4e33d78a">More...</a><br /></td></tr>
<tr class="separator:a6c488369b0b5864774ebe7ab4e33d78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1b7edbfeabbe536df052167870f6d"><td class="memTemplParams" colspan="2"><a id="afcf1b7edbfeabbe536df052167870f6d"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:afcf1b7edbfeabbe536df052167870f6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#afcf1b7edbfeabbe536df052167870f6d">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:afcf1b7edbfeabbe536df052167870f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:afcf1b7edbfeabbe536df052167870f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70ca7c5f7d7e7b77edade590954900"><td class="memTemplParams" colspan="2"><a id="aaf70ca7c5f7d7e7b77edade590954900"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:aaf70ca7c5f7d7e7b77edade590954900"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aaf70ca7c5f7d7e7b77edade590954900">operator==</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type rhs)</td></tr>
<tr class="memdesc:aaf70ca7c5f7d7e7b77edade590954900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:aaf70ca7c5f7d7e7b77edade590954900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f973d92d6544e57724755373e8f62ab"><td class="memTemplParams" colspan="2"><a id="a9f973d92d6544e57724755373e8f62ab"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a9f973d92d6544e57724755373e8f62ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a9f973d92d6544e57724755373e8f62ab">operator==</a> (typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a9f973d92d6544e57724755373e8f62ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member equal operator. <br /></td></tr>
<tr class="separator:a9f973d92d6544e57724755373e8f62ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309e8ccead457c2b5c3a9c44926a3b44"><td class="memTemplParams" colspan="2"><a id="a309e8ccead457c2b5c3a9c44926a3b44"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a309e8ccead457c2b5c3a9c44926a3b44"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a309e8ccead457c2b5c3a9c44926a3b44">operator!=</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a309e8ccead457c2b5c3a9c44926a3b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a309e8ccead457c2b5c3a9c44926a3b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0060079224224da5df2c9e07cbc06f01"><td class="memTemplParams" colspan="2"><a id="a0060079224224da5df2c9e07cbc06f01"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a0060079224224da5df2c9e07cbc06f01"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a0060079224224da5df2c9e07cbc06f01">operator!=</a> (typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a0060079224224da5df2c9e07cbc06f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a0060079224224da5df2c9e07cbc06f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a2fbb6caf5a7669387f6ff6a27b91b"><td class="memTemplParams" colspan="2"><a id="a70a2fbb6caf5a7669387f6ff6a27b91b"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a70a2fbb6caf5a7669387f6ff6a27b91b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a70a2fbb6caf5a7669387f6ff6a27b91b">operator!=</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type rhs)</td></tr>
<tr class="memdesc:a70a2fbb6caf5a7669387f6ff6a27b91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member not equal operator. <br /></td></tr>
<tr class="separator:a70a2fbb6caf5a7669387f6ff6a27b91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66bf1489bd8d761a13abb7b8fa7f933"><td class="memTemplParams" colspan="2"><a id="aa66bf1489bd8d761a13abb7b8fa7f933"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:aa66bf1489bd8d761a13abb7b8fa7f933"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#aa66bf1489bd8d761a13abb7b8fa7f933">operator&lt;</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:aa66bf1489bd8d761a13abb7b8fa7f933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:aa66bf1489bd8d761a13abb7b8fa7f933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bce86547891631d531e5e9bb87a67c9"><td class="memTemplParams" colspan="2"><a id="a1bce86547891631d531e5e9bb87a67c9"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a1bce86547891631d531e5e9bb87a67c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a1bce86547891631d531e5e9bb87a67c9">operator&lt;</a> (typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a1bce86547891631d531e5e9bb87a67c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:a1bce86547891631d531e5e9bb87a67c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c04272ec87dbf5603ded3d19553abd"><td class="memTemplParams" colspan="2"><a id="ad5c04272ec87dbf5603ded3d19553abd"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ad5c04272ec87dbf5603ded3d19553abd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ad5c04272ec87dbf5603ded3d19553abd">operator&lt;</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type rhs)</td></tr>
<tr class="memdesc:ad5c04272ec87dbf5603ded3d19553abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less than operator. <br /></td></tr>
<tr class="separator:ad5c04272ec87dbf5603ded3d19553abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd590b94f84fbd9fff902de4549a21d"><td class="memTemplParams" colspan="2"><a id="adcd590b94f84fbd9fff902de4549a21d"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:adcd590b94f84fbd9fff902de4549a21d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#adcd590b94f84fbd9fff902de4549a21d">operator&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:adcd590b94f84fbd9fff902de4549a21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:adcd590b94f84fbd9fff902de4549a21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b0b527b8174dd4bd17f62c6eb2d392"><td class="memTemplParams" colspan="2"><a id="a20b0b527b8174dd4bd17f62c6eb2d392"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a20b0b527b8174dd4bd17f62c6eb2d392"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a20b0b527b8174dd4bd17f62c6eb2d392">operator&lt;=</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type rhs)</td></tr>
<tr class="memdesc:a20b0b527b8174dd4bd17f62c6eb2d392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:a20b0b527b8174dd4bd17f62c6eb2d392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb184a021e3b9c279268c4d00bcfbb4"><td class="memTemplParams" colspan="2"><a id="a7bb184a021e3b9c279268c4d00bcfbb4"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a7bb184a021e3b9c279268c4d00bcfbb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7bb184a021e3b9c279268c4d00bcfbb4">operator&lt;=</a> (typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a7bb184a021e3b9c279268c4d00bcfbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member less or equal operator. <br /></td></tr>
<tr class="separator:a7bb184a021e3b9c279268c4d00bcfbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdbbadc15635c8f78914799841ff9b1"><td class="memTemplParams" colspan="2"><a id="a3fdbbadc15635c8f78914799841ff9b1"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a3fdbbadc15635c8f78914799841ff9b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a3fdbbadc15635c8f78914799841ff9b1">operator&gt;</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a3fdbbadc15635c8f78914799841ff9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:a3fdbbadc15635c8f78914799841ff9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d220290b8831497b34cbd289c2449e"><td class="memTemplParams" colspan="2"><a id="a71d220290b8831497b34cbd289c2449e"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a71d220290b8831497b34cbd289c2449e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a71d220290b8831497b34cbd289c2449e">operator&gt;</a> (typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a71d220290b8831497b34cbd289c2449e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:a71d220290b8831497b34cbd289c2449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b1569c77d7592e96bdf19d479fb647"><td class="memTemplParams" colspan="2"><a id="a72b1569c77d7592e96bdf19d479fb647"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a72b1569c77d7592e96bdf19d479fb647"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a72b1569c77d7592e96bdf19d479fb647">operator&gt;</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type rhs)</td></tr>
<tr class="memdesc:a72b1569c77d7592e96bdf19d479fb647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater than operator. <br /></td></tr>
<tr class="separator:a72b1569c77d7592e96bdf19d479fb647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634177ba95b1668c00438a03bb836593"><td class="memTemplParams" colspan="2"><a id="a634177ba95b1668c00438a03bb836593"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a634177ba95b1668c00438a03bb836593"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a634177ba95b1668c00438a03bb836593">operator&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a634177ba95b1668c00438a03bb836593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:a634177ba95b1668c00438a03bb836593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7836e66a2f25ca149f9d3062917acb6a"><td class="memTemplParams" colspan="2"><a id="a7836e66a2f25ca149f9d3062917acb6a"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a7836e66a2f25ca149f9d3062917acb6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a7836e66a2f25ca149f9d3062917acb6a">operator&gt;=</a> (typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type lhs, <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs)</td></tr>
<tr class="memdesc:a7836e66a2f25ca149f9d3062917acb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:a7836e66a2f25ca149f9d3062917acb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c40d3be9943d4545ee2690e1b9956f"><td class="memTemplParams" colspan="2"><a id="ab2c40d3be9943d4545ee2690e1b9956f"></a>
template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:ab2c40d3be9943d4545ee2690e1b9956f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ab2c40d3be9943d4545ee2690e1b9956f">operator&gt;=</a> (<a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, typename std::common_type&lt; <a class="el" href="classpmem_1_1obj_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;::type rhs)</td></tr>
<tr class="memdesc:ab2c40d3be9943d4545ee2690e1b9956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-member greater or equal operator. <br /></td></tr>
<tr class="separator:ab2c40d3be9943d4545ee2690e1b9956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#ac392b8f634101ffeebb3c6838ebe3f8a">pool_by_vptr</a> (const T *that)</td></tr>
<tr class="memdesc:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve pool handle for the given pointer.  <a href="namespacepmem_1_1obj.html#ac392b8f634101ffeebb3c6838ebe3f8a">More...</a><br /></td></tr>
<tr class="separator:ac392b8f634101ffeebb3c6838ebe3f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepmem_1_1obj.html#a91c6d7a276ccbdfd1eee3f10431aa71f">pool_by_pptr</a> (const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve pool handle for the given <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>.  <a href="namespacepmem_1_1obj.html#a91c6d7a276ccbdfd1eee3f10431aa71f">More...</a><br /></td></tr>
<tr class="separator:a91c6d7a276ccbdfd1eee3f10431aa71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main libpmemobj namespace. </p>
<p>It contains all libpmemobj's public types, enums, classes with their functions and members. It is located within pmem namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aaf75bf0b2a2f4bf0f6cf7ae612e30f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">&#9670;&nbsp;</a></span>exponential_size_array_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#aaf75bf0b2a2f4bf0f6cf7ae612e30f8f">pmem::obj::exponential_size_array_policy</a> = typedef segment_vector_internal::exponential_size_policy&lt; <a class="el" href="structpmem_1_1obj_1_1array.html">segment_vector_internal::array_64</a>, SegmentType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential size policy with pmemobj array of size 64 as a type of segment vector, so this is a static array of segments and each segment is of SegmentType. </p>
<ul>
<li>requires more memory than exponential_size_vector_policy</li>
<li>is faster and more efficient than exponential_size_vector_policy </li>
</ul>

</div>
</div>
<a id="a526e84dce66d8c59cdc9070321b8d0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526e84dce66d8c59cdc9070321b8d0d7">&#9670;&nbsp;</a></span>exponential_size_vector_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#a526e84dce66d8c59cdc9070321b8d0d7">pmem::obj::exponential_size_vector_policy</a> = typedef segment_vector_internal::exponential_size_policy&lt;<a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential size policy with pmemobj vector as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType. </p>
<ul>
<li>requires less memory than exponential_size_array_policy</li>
<li>is slower and less efficient than exponential_size_array_policy </li>
</ul>

</div>
</div>
<a id="a859b965166fda256885558839d7bb7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859b965166fda256885558839d7bb7ec">&#9670;&nbsp;</a></span>fixed_size_vector_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SegmentSize = 1024, template&lt; typename &gt; class SegmentType = pmem::obj::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#a859b965166fda256885558839d7bb7ec">pmem::obj::fixed_size_vector_policy</a> = typedef segment_vector_internal::fixed_size_policy&lt;<a class="el" href="classpmem_1_1obj_1_1vector.html">pmem::obj::vector</a>, SegmentType, SegmentSize&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed size policy with pmemobj vector of a given size as a type of segment vector, so this is a dynamic vector of segments and each segment is of SegmentType. </p>
<ul>
<li>is slower than the exponential one (because it has more segments)</li>
<li>causes less fragmentation than the exponential one </li>
</ul>

</div>
</div>
<a id="a584f6676f0d014e94253e19f2d18da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584f6676f0d014e94253e19f2d18da43">&#9670;&nbsp;</a></span>transaction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43">pmem::obj::transaction</a> = typedef <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html">basic_transaction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, <a class="el" href="namespacepmem_1_1obj.html#a584f6676f0d014e94253e19f2d18da43" title="By default, pmem::obj::transaction is an alias to pmem::obj::basic_transaction.">pmem::obj::transaction</a> is an alias to <a class="el" href="classpmem_1_1obj_1_1basic__transaction.html" title="C++ transaction handler class.">pmem::obj::basic_transaction</a>. </p>
<p>To change it to <a class="el" href="classpmem_1_1obj_1_1flat__transaction.html" title="C++ flat transaction handler class.">pmem::obj::flat_transaction</a> define LIBPMEMOBJ_CPP_USE_FLAT_TRANSACTION macro.</p>
<p>To see what is the difference between the two please look at the examples for flat tx: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_flat_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> count;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, [&amp;] {</div>
<div class="line">            proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, [&amp;] {</div>
<div class="line">                    proot-&gt;count++;</div>
<div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;some error&quot;</span>);</div>
<div class="line">                });</div>
<div class="line">            } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">                <span class="comment">/* Transaction is not aborted yet (unlike for</span></div>
<div class="line"><span class="comment">                 * basic_transaction). */</span></div>
<div class="line">                assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line">                assert(proot-&gt;count == 2);</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* An internal transaction error occurred, outer tx aborted just</span></div>
<div class="line"><span class="comment">         * now. Reacquire locks if necessary. */</span></div>
<div class="line">        assert(proot-&gt;count == 0);</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* Some other exception thrown, outer tx aborted just now.</span></div>
<div class="line"><span class="comment">         * Reacquire locks if necessary. */</span></div>
<div class="line">        assert(proot-&gt;count == 0);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>simple_ptr {</div>
<div class="line">    simple_ptr()</div>
<div class="line">    {</div>
<div class="line">        assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line">        ptr = make_persistent&lt;T&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~simple_ptr()</div>
<div class="line">    {</div>
<div class="line">        assert(pmemobj_tx_stage() == TX_STAGE_WORK);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            delete_persistent&lt;T&gt;(ptr);</div>
<div class="line">        } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a> &amp;e) {</div>
<div class="line">            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            std::terminate();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;T&gt;</a> ptr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>A {</div>
<div class="line">    A() : ptr1(), ptr2()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    simple_ptr&lt;int&gt; ptr1;</div>
<div class="line">    simple_ptr&lt;<span class="keywordtype">char</span>[(1ULL &lt;&lt; 30)]&gt; ptr2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>B {</div>
<div class="line">    B() : ptr1(), ptr2()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>(pmemobj_pool_by_ptr(<span class="keyword">this</span>));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// It would result in a crash!</span></div>
<div class="line">        <span class="comment">// basic_transaction::run(pop, [&amp;]{ throw</span></div>
<div class="line">        <span class="comment">// std::runtime_error(&quot;Error&quot;); });</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(</div>
<div class="line">            pop, [&amp;] { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Error&quot;</span>); });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    simple_ptr&lt;int&gt; ptr1;</div>
<div class="line">    simple_ptr&lt;int&gt; ptr2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">tx_nested_struct_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;A&gt;</a> ptrA;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;B&gt;</a> ptrB;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> create_a = [&amp;] { proot-&gt;ptrA = make_persistent&lt;A&gt;(); };</div>
<div class="line">    <span class="keyword">auto</span> create_b = [&amp;] { proot-&gt;ptrB = make_persistent&lt;B&gt;(); };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// It would result in a crash!</span></div>
<div class="line">        <span class="comment">// basic_transaction::run(pop, create_a);</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, create_a);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* To see why flat_transaction is necessary let&#39;s</span></div>
<div class="line"><span class="comment">         * consider what happens when calling A ctor. The call stack</span></div>
<div class="line"><span class="comment">         * will look like this:</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         *  | ptr2 ctor |</span></div>
<div class="line"><span class="comment">         *  |-----------|</span></div>
<div class="line"><span class="comment">         *  | ptr1 ctor |</span></div>
<div class="line"><span class="comment">         *  |-----------|</span></div>
<div class="line"><span class="comment">         *  |  A ctor   |</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Since ptr2 is a pointer to some huge array of elements,</span></div>
<div class="line"><span class="comment">         * calling ptr2 ctor will most likely result in make_persistent</span></div>
<div class="line"><span class="comment">         * throwing an exception (due to out of memory). This exception</span></div>
<div class="line"><span class="comment">         * will, in turn, cause stack unwinding - already constructed</span></div>
<div class="line"><span class="comment">         * elements must be destroyed (in this example ptr1 destructor</span></div>
<div class="line"><span class="comment">         * will be called).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * If we&#39;d use basic_transaction the allocation failure, apart</span></div>
<div class="line"><span class="comment">         * from throwing an exception, would also cause the transaction</span></div>
<div class="line"><span class="comment">         * to abort (by default, in basic_transaction, all transactional</span></div>
<div class="line"><span class="comment">         * functions failures cause tx abort). This is problematic since</span></div>
<div class="line"><span class="comment">         * the ptr1 destructor, which is called during stack unwinding,</span></div>
<div class="line"><span class="comment">         * expects the transaction to be in WORK stage (and the actual</span></div>
<div class="line"><span class="comment">         * stage is ABORTED). As a result the application will fail on</span></div>
<div class="line"><span class="comment">         * assert (and probably crash in NDEBUG mode).</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * Now, consider what will happen if we&#39;d use flat_transaction</span></div>
<div class="line"><span class="comment">         * instead. In this case, make_persistent failure will not abort</span></div>
<div class="line"><span class="comment">         * the transaction, it will only result in an exception. This</span></div>
<div class="line"><span class="comment">         * means that the transaction is still in WORK stage during</span></div>
<div class="line"><span class="comment">         * stack unwinding. Only after it completes, the transaction is</span></div>
<div class="line"><span class="comment">         * aborted (it&#39;s happening at the outermost level, when exiting</span></div>
<div class="line"><span class="comment">         * create_a lambda).</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">basic_transaction::run</a>(pop, create_b);</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">flat_transaction::run</a>(pop, create_b);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Running create_b can be done both within basic and flat</span></div>
<div class="line"><span class="comment">         * transaction. However, note that the transaction used in the B</span></div>
<div class="line"><span class="comment">         * constructor MUST be a flat_transaction. This is because</span></div>
<div class="line"><span class="comment">         * flat_transaction does not abort immediately when catching an</span></div>
<div class="line"><span class="comment">         * exception. Instead it passes it to the outermost transaction</span></div>
<div class="line"><span class="comment">         * - the abort is performed at that outermost level. In case of</span></div>
<div class="line"><span class="comment">         * a basic_transaction the abort would be done within the B ctor</span></div>
<div class="line"><span class="comment">         * and it would result in the same problems as with the previous</span></div>
<div class="line"><span class="comment">         * example.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (std::runtime_error &amp;) {</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> and basic tx: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__mutex_8hpp.html">libpmemobj++/shared_mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepmem_1_1obj.html">pmem::obj</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">manual_tx_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* pool root structure */</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1mutex.html">mutex</a> pmutex;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1shared__mutex.html">shared_mutex</a> shared_pmutex;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> count;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;root&gt;</a> another_root;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* create a pmemobj pool */</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1basic__transaction.html#ad86b8b9def7073307927ba6e41d0fbf5">transaction::manual</a> tx(pop, proot-&gt;pmutex,</div>
<div class="line">                       proot-&gt;shared_pmutex);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically allocate objects */</span></div>
<div class="line">        proot-&gt;another_root = make_persistent&lt;root&gt;();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* atomically modify objects */</span></div>
<div class="line">        proot-&gt;count++;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* It&#39;s necessary to commit the transaction manually and</span></div>
<div class="line"><span class="comment">         * it has to be the last operation in the transaction. */</span></div>
<div class="line">        <a class="code" href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">transaction::commit</a>();</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">/* an internal transaction error occurred, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">/* some other exception thrown, tx aborted</span></div>
<div class="line"><span class="comment">         * reacquire locks if necessary */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* In complex cases with library calls, remember to check the status of</span></div>
<div class="line"><span class="comment">     * the previous transaction. */</span></div>
<div class="line">    <span class="keywordflow">return</span> transaction::error();</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae5828e2ef9f44c67de727e4498c89f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5828e2ef9f44c67de727e4498c89f1f">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute function at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a6c488369b0b5864774ebe7ab4e33d78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c488369b0b5864774ebe7ab4e33d78a">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute function at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="aa89f45b433f00601332cc8b026c8094b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89f45b433f00601332cc8b026c8094b">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a64434e59ff1de9be9e73a9eb8d364b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64434e59ff1de9be9e73a9eb8d364b45">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a35c4923f7973d6d9eeefdc6eeb16a4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c4923f7973d6d9eeefdc6eeb16a4f1">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="adb3269602e36bbce39e864116f35aa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3269602e36bbce39e864116f35aa7e">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pmem::obj::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify libpmemobj state at global scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">https://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a4222feb628a4d6f8ac2b3a5dbe42c5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4222feb628a4d6f8ac2b3a5dbe42c5e6">&#9670;&nbsp;</a></span>delete_persistent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_array&lt; T &gt;::type&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<p>This function can be used to <em>transactionally</em> free an array of objects. Calls the objects' destructors before freeing memory. This overload only participates in overload resolution if T is an array.</p>
<p>To ensure that proper recovery is possible, ptr should be set to null after delete_persistent call and within the same transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>persistent pointer to an array of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>the size of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a></td><td>on transactional free failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a714693f9ebbc9db6cd47ee40e10ccbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714693f9ebbc9db6cd47ee40e10ccbaf">&#9670;&nbsp;</a></span>delete_persistent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_not_array&lt; T &gt;::type&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally free an object of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<p>This function can be used to <em>transactionally</em> free an object. Calls the object's destructor before freeing memory. Cannot be used for array types.</p>
<p>To ensure that proper recovery is possible, ptr should be set to null after delete_persistent call and within the same transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>persistent pointer to an object that is not an array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a></td><td>on transactional free failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5582033bf768fea635b40b3ba766fbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5582033bf768fea635b40b3ba766fbef">&#9670;&nbsp;</a></span>delete_persistent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_size_array&lt; T &gt;::type&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally free an array of objects of type T held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<p>This function can be used to <em>transactionally</em> free an array of objects. Calls the objects' destructors before freeing memory. This overload only participates in overload resolution if T is an array.</p>
<p>To ensure that proper recovery is possible, ptr should be set to null after delete_persistent call and within the same transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>persistent pointer to an array of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">transaction_free_error</a></td><td>on transactional free failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2009e20a7365ba802a5f1acbff2f2336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2009e20a7365ba802a5f1acbff2f2336">&#9670;&nbsp;</a></span>delete_persistent_atomic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically deallocate an array of objects. </p>
<p>There is no way to atomically destroy an object. Any object specific cleanup must be performed elsewhere. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<p>param[in,out] ptr the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> whose pointee is to be deallocated. </p>

</div>
</div>
<a id="a2aa55bbcf44c93a0ca9a8965cded6e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa55bbcf44c93a0ca9a8965cded6e40">&#9670;&nbsp;</a></span>delete_persistent_atomic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_not_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically deallocate an object. </p>
<p>There is no way to atomically destroy an object. Any object specific cleanup must be performed elsewhere. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<p>param[in,out] ptr the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> whose pointee is to be deallocated. </p>

</div>
</div>
<a id="a774f709132747433efe83cf8060186a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774f709132747433efe83cf8060186a3">&#9670;&nbsp;</a></span>delete_persistent_atomic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::delete_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype">typename detail::pp_if_size_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically deallocate an array of objects. </p>
<p>There is no way to atomically destroy an object. Any object specific cleanup must be performed elsewhere. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<p>param[in,out] ptr the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> whose pointee is to be deallocated. </p>

</div>
</div>
<a id="a9e090bf5d2b950fba759c7560c16e08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e090bf5d2b950fba759c7560c16e08e">&#9670;&nbsp;</a></span>make_persistent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::pp_if_not_array&lt;T&gt;::type pmem::obj::make_persistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally allocate and construct an object of type T. </p>
<p>This function can be used to <em>transactionally</em> allocate an object. Cannot be used for array types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">args</td><td>a list of parameters passed to the constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent_ptr&lt;T&gt; on success</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">transaction_alloc_error</a></td><td>on transactional allocation failure. </td></tr>
    <tr><td class="paramname">rethrow</td><td>exception from T constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0799ef351bd641499230292365d427a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0799ef351bd641499230292365d427a7">&#9670;&nbsp;</a></span>make_persistent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::pp_if_size_array&lt;T&gt;::type pmem::obj::make_persistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html#ae89f1ed6c125d3bd67fd33c0cff27c76">allocation_flag::none</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally allocate and construct an array of objects of type T. </p>
<p>This function can be used to <em>transactionally</em> allocate an array. This overload only participates in overload resolution if T is an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent_ptr&lt;T[N]&gt; on success</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">transaction_alloc_error</a></td><td>on transactional allocation failure. </td></tr>
    <tr><td class="paramname">rethrow</td><td>exception from T constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77252820ae5e37021b008009c2ec17ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77252820ae5e37021b008009c2ec17ed">&#9670;&nbsp;</a></span>make_persistent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !detail::is_first_arg_same&lt;<a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a>, Args...&gt;::value, typename detail::pp_if_not_array&lt;T&gt;::type&gt;::type pmem::obj::make_persistent </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally allocate and construct an object of type T. </p>
<p>This function can be used to <em>transactionally</em> allocate an object. Cannot be used for array types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">args</td><td>a list of parameters passed to the constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent_ptr&lt;T&gt; on success</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">transaction_alloc_error</a></td><td>on transactional allocation failure. </td></tr>
    <tr><td class="paramname">rethrow</td><td>exception from T constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fe3504b5f576c05b190770ae0e4b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe3504b5f576c05b190770ae0e4b528">&#9670;&nbsp;</a></span>make_persistent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::pp_if_array&lt;T&gt;::type pmem::obj::make_persistent </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html">allocation_flag</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="structpmem_1_1obj_1_1allocation__flag.html#ae89f1ed6c125d3bd67fd33c0cff27c76">allocation_flag::none</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactionally allocate and construct an array of objects of type T. </p>
<p>This function can be used to <em>transactionally</em> allocate an array. This overload only participates in overload resolution if T is an array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>the number of array elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;T[]&gt;</a> on success</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">transaction_scope_error</a></td><td>if called outside of an active transaction </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">transaction_alloc_error</a></td><td>on transactional allocation failure. </td></tr>
    <tr><td class="paramname">rethrow</td><td>exception from T constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b14ac5b07d58902df4c24deb7096d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b14ac5b07d58902df4c24deb7096d12">&#9670;&nbsp;</a></span>make_persistent_atomic() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::make_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::pp_if_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically allocate an array of objects. </p>
<p>This function can be used to atomically allocate an array of objects. Cannot be used for simple objects. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool from which the object will be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>the persistent pointer to which the allocation will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>the number of array elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b463d8cf7358dda467d0f63e130d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b463d8cf7358dda467d0f63e130d410">&#9670;&nbsp;</a></span>make_persistent_atomic() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::make_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::pp_if_not_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically allocate and construct an object. </p>
<p>Constructor parameters are passed through variadic parameters. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool from which the object will be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>the persistent pointer to which the allocation will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>variadic function parameter containing all parameters passed to the objects constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2b6596bf5b91ebcc5fbaeb899d59599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b6596bf5b91ebcc5fbaeb899d59599">&#9670;&nbsp;</a></span>make_persistent_atomic() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!detail::is_first_arg_same&lt;<a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>, Args...&gt;::value&gt;::type pmem::obj::make_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::pp_if_not_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically allocate and construct an object. </p>
<p>Constructor parameters are passed through variadic parameters. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool from which the object will be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>the persistent pointer to which the allocation will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>variadic function parameter containing all parameters passed to the objects constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d456157a9ddd13772036944fab68b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d456157a9ddd13772036944fab68b01">&#9670;&nbsp;</a></span>make_persistent_atomic() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::make_persistent_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::pp_if_size_array&lt; T &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html">allocation_flag_atomic</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="structpmem_1_1obj_1_1allocation__flag__atomic.html#a0f5b05f867e70150598eb890f0f8a350">allocation_flag_atomic::none</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically allocate an array of objects. </p>
<p>This function can be used to atomically allocate an array of objects. Cannot be used for simple objects. Do <em>NOT</em> use this inside transactions, as it might lead to undefined behavior in the presence of transaction aborts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool from which the object will be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>the persistent pointer to which the allocation will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>affects behaviour of allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a641fa4c058284070e8b9c2c273b4ced3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641fa4c058284070e8b9c2c273b4ced3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename Tr , typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherAllocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if allocators are equivalent in terms of deallocation, true otherwise. </dd></dl>

</div>
</div>
<a id="a521f60b2723b9d069c4cc5af13bda399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521f60b2723b9d069c4cc5af13bda399">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the different number of elements or at least one element in lhs is not equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are not equal, false otherwise. </dd></dl>

</div>
</div>
<a id="adb72e4a3d5ebcdf650ca64a14b89eeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb72e4a3d5ebcdf650ca64a14b89eeec">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, SegmentPolicy, StoragePolicy&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is std::vector&lt;T&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are not equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a613a93583aec0a95ffb9145fd21fa1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613a93583aec0a95ffb9145fd21fa1c3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is std::vector&lt;T&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are not equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a659d49015c82ef1dc044e2142224269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659d49015c82ef1dc044e2142224269d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type std::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are not equal, false otherwise </dd></dl>

</div>
</div>
<a id="a1fcbd0d2822d3f235950b044d0da6ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcbd0d2822d3f235950b044d0da6ac2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type std::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are not equal, false otherwise </dd></dl>

</div>
</div>
<a id="a399b4199506661eccff459a7a878f3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399b4199506661eccff459a7a878f3d9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are not equal, false otherwise </dd></dl>

</div>
</div>
<a id="a9e4f2831cd0b0a9b8906f8413b282551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4f2831cd0b0a9b8906f8413b282551">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y , typename  = typename std::enable_if&lt;		  std::is_same&lt;typename std::remove_cv&lt;T&gt;::type,			       typename std::remove_cv&lt;Y&gt;::type&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t pmem::obj::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for persistent pointers of identical type. </p>
<p>Calculates the offset difference of PMEMoids in terms of represented objects. Calculating the difference of pointers from objects of different pools is not allowed. </p>

</div>
</div>
<a id="a5175622e13aec283fb56ca7ccedacf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175622e13aec283fb56ca7ccedacf9b">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically less than contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a26c3d5b212ac54fbc0d5ad9e9ce5685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c3d5b212ac54fbc0d5ad9e9ce5685b">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, SegmentPolicy, StoragePolicy&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is std::vector&lt;T&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically less than contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a89e6aab454db03fee92e3b417ea94bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e6aab454db03fee92e3b417ea94bd0">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is std::vector&lt;T&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically less than contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a0dcb348e953ea0a5b1ed1a3f5c29d2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcb348e953ea0a5b1ed1a3f5c29d2dd">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type std::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically less than contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a6bc8b97b7a1b71404a4da7907cc0a695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc8b97b7a1b71404a4da7907cc0a695">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type std::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically less than contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="aec4bbcff4664436e0341275606b24314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4bbcff4664436e0341275606b24314">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically less than contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a49fd05c4944d079ea05dd0cb5b203b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fd05c4944d079ea05dd0cb5b203b75">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the uuid_lo of lhs is less than the uuid_lo of rhs, should they be equal, the offsets are compared. Returns false otherwise. </dd></dl>

</div>
</div>
<a id="a1ba953ad63f462d920bc79de271f39a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba953ad63f462d920bc79de271f39a9">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically lesser than or equal to contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a433769b18c43b2b1ca9fcb25c62b203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433769b18c43b2b1ca9fcb25c62b203f">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, SegmentPolicy, StoragePolicy&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is std::vector&lt;T&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically lesser than or equal to contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a84f62693161b852a8a897973f0ea67cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f62693161b852a8a897973f0ea67cb">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is std::vector&lt;T&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically lesser than or equal to contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a6137a8d89c6046241b600ab14a63b6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6137a8d89c6046241b600ab14a63b6de">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of ype std::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically lesser than or equal to contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a4403e4fdd376acf1404d225856a6109f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4403e4fdd376acf1404d225856a6109f">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of ype std::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically lesser than or equal to contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a6442bae353bd3aab4417d4db85995b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6442bae353bd3aab4417d4db85995b07">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically lesser than or equal to contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a48591ec64f0a18f0f81c9c7c79b265a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48591ec64f0a18f0f81c9c7c79b265a3">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less or equal than operator. </p>
<p>See less than operator for comparison rules. </p>

</div>
</div>
<a id="adb1f133c1308826fee0b3abf2f09c3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1f133c1308826fee0b3abf2f09c3b5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename Tr , typename T2 , typename P2 , typename Tr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T, P, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1allocator.html">allocator</a>&lt; T2, P2, Tr2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left hand side allocator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right hand side allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allocators are equivalent in terms of deallocation, false otherwise. </dd></dl>

</div>
</div>
<a id="a4500f832c5be4483fb0664c870b7127b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4500f832c5be4483fb0664c870b7127b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="ae5d793d76be641b82a1ffa96bbf4c06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d793d76be641b82a1ffa96bbf4c06c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, SegmentPolicy, StoragePolicy&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is std::vector&lt;T&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a2b6f5b69d0d397ba27c0035cafce8bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6f5b69d0d397ba27c0035cafce8bec">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is std::vector&lt;T&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a5fa7985535467845be5c2e4605bab72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa7985535467845be5c2e4605bab72e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type std::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are equal, false otherwise </dd></dl>

</div>
</div>
<a id="aef8f8bc8ee773cf3ba486df604a98504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8f8bc8ee773cf3ba486df604a98504">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type std::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are equal, false otherwise </dd></dl>

</div>
</div>
<a id="aae7ea0da2be2d117a026e3fa58a3369d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7ea0da2be2d117a026e3fa58a3369d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers.</p>
<p>Checks if containers have the same number of elements and each element in lhs is equal to element in rhs at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of the containers are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a3c125ea043799ff6da2d44199cae94fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c125ea043799ff6da2d44199cae94fc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>This checks if underlying PMEMoids are equal. </p>

</div>
</div>
<a id="a87a59d3c5deb43649af9a78f8bd651b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a59d3c5deb43649af9a78f8bd651b9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherAllocator const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="section return"><dt>Returns</dt><dd>false. </dd></dl>

</div>
</div>
<a id="ad052dc252e327efbe5f17be6e840935d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad052dc252e327efbe5f17be6e840935d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1standard__alloc__policy.html">standard_alloc_policy</a>&lt; T2 &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if memory from another allocator can be deallocated from this one. </p>
<dl class="section return"><dt>Returns</dt><dd>true. </dd></dl>

</div>
</div>
<a id="a16b8bf77fa26fc0afcc40b6a3aed7e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b8bf77fa26fc0afcc40b6a3aed7e79">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a9305236fa00130f6d27bacd5fb93c4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9305236fa00130f6d27bacd5fb93c4ee">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, SegmentPolicy, StoragePolicy&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is std::vector&lt;T&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="acfe18f4fe61e0fbe10034f84a4b3a691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe18f4fe61e0fbe10034f84a4b3a691">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is std::vector&lt;T&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="ad6ea4849c06b3f401ac3673ded5a3227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ea4849c06b3f401ac3673ded5a3227">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type std::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a5bfc1cf4bc0871a89bc16487bd6a8484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfc1cf4bc0871a89bc16487bd6a8484">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type std::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a2e824a963007146618891278f455c6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e824a963007146618891278f455c6df">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a4b2a880e3da360c959414e7ea9268456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2a880e3da360c959414e7ea9268456">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than operator. </p>
<p>See less than operator for comparison rules. </p>

</div>
</div>
<a id="a463a840c5a7d0056269dbaef5a43af74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a840c5a7d0056269dbaef5a43af74">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than or equal to contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="ab7eb19512a32487e9294c25219e3c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7eb19512a32487e9294c25219e3c234">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, SegmentPolicy, StoragePolicy&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is std::vector&lt;T&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than or equal to contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="aed237e8ec30fc8cd3efbf780eb476125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed237e8ec30fc8cd3efbf780eb476125">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>is std::vector&lt;T&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>is pmem::obj::experimental::segment_vector&lt;T, Policy, SPolicy&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than or equal to contents of rhs, false otherwise. </dd></dl>

</div>
</div>
<a id="a963062a2970d5133a82fa906f0b7eddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963062a2970d5133a82fa906f0b7eddd">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type std::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than or equal to contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a29cc30f96742b912f5c70bffcd87fe5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29cc30f96742b912f5c70bffcd87fe5a">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type std::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than or equal to contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a4d0311022343df6a9d6630d0025e99c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0311022343df6a9d6630d0025e99c1">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Compares the contents of two containers lexicographically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector of type pmem::obj::vector&lt;T&gt; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector of type pmem::obj::vector&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contents of lhs are lexicographically greater than or equal to contents of rhs, false otherwise </dd></dl>

</div>
</div>
<a id="a696298dbdd381bae03541da80cbe485d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696298dbdd381bae03541da80cbe485d">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pmem::obj::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater or equal than operator. </p>
<p>See less than operator for comparison rules. </p>

</div>
</div>
<a id="a91c6d7a276ccbdfd1eee3f10431aa71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c6d7a276ccbdfd1eee3f10431aa71f">&#9670;&nbsp;</a></span>pool_by_pptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> pmem::obj::pool_by_pptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve pool handle for the given <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to an object from a persistent memory pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the pool containing the object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>if the given pointer does not belong to an open pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac392b8f634101ffeebb3c6838ebe3f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac392b8f634101ffeebb3c6838ebe3f8a">&#9670;&nbsp;</a></span>pool_by_vptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> pmem::obj::pool_by_vptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve pool handle for the given pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">that</td><td>pointer to an object from a persistent memory pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the pool containing the object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>if the given pointer does not belong to an open pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1f540f252cd5ae5601c691f53ecbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1f540f252cd5ae5601c691f53ecbb7">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two p objects of the same type. </p>
<p>Non-member swap function as required by Swappable concept. en.cppreference.com/w/cpp/concept/Swappable </p>

</div>
</div>
<a id="a28d6e952280db13f57d69be1b816d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d6e952280db13f57d69be1b816d21c">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> objects of the same type. </p>
<p>Non-member swap function as required by Swappable concept. en.cppreference.com/w/cpp/concept/Swappable </p>

</div>
</div>
<a id="a2eaf529f99d9ee39c30b32ea8a82a965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaf529f99d9ee39c30b32ea8a82a965">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1segment__vector.html">segment_vector</a>&lt; T, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of lhs and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="A persistent version of segment vector implementation.">segment_vector</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second <a class="el" href="classpmem_1_1obj_1_1segment__vector.html" title="A persistent version of segment vector implementation.">segment_vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46a6c5333f2e9859d6f152f1dc8f1832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a6c5333f2e9859d6f152f1dc8f1832">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pmem::obj::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of lhs and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>first vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1obj_1_1mutex_html"><div class="ttname"><a href="classpmem_1_1obj_1_1mutex.html">pmem::obj::mutex</a></div><div class="ttdoc">Persistent memory resident mutex implementation.</div><div class="ttdef"><b>Definition:</b> mutex.hpp:31</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__free__error_html"><div class="ttname"><a href="classpmem_1_1transaction__free__error.html">pmem::transaction_free_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:140</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:677</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__error_html"><div class="ttname"><a href="classpmem_1_1transaction__error.html">pmem::transaction_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:63</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_a9564707de1779ca1bce7041fb7c9855c"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#a9564707de1779ca1bce7041fb7c9855c">pmem::obj::basic_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:688</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1p_html"><div class="ttname"><a href="classpmem_1_1obj_1_1p.html">pmem::obj::p</a></div><div class="ttdoc">Resides on pmem class.</div><div class="ttdef"><b>Definition:</b> p.hpp:35</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">Persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="anamespacepmem_1_1obj_html"><div class="ttname"><a href="namespacepmem_1_1obj.html">pmem::obj</a></div><div class="ttdoc">Main libpmemobj namespace.</div><div class="ttdef"><b>Definition:</b> allocation_flag.hpp:18</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr_html"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a></div><div class="ttdoc">Persistent pointer class.</div><div class="ttdef"><b>Definition:</b> persistent_ptr.hpp:152</div></div>
<div class="ttc" id="ashared__mutex_8hpp_html"><div class="ttname"><a href="shared__mutex_8hpp.html">shared_mutex.hpp</a></div><div class="ttdoc">Pmem-resident shared mutex.</div></div>
<div class="ttc" id="aclasspmem_1_1detail_1_1transaction__base_html_a16c0d86f943d6727e1caa7573cc83edb"><div class="ttname"><a href="classpmem_1_1detail_1_1transaction__base.html#a16c0d86f943d6727e1caa7573cc83edb">pmem::detail::transaction_base&lt; false &gt;::commit</a></div><div class="ttdeci">static void commit()</div><div class="ttdoc">Manually commit a transaction.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:325</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1basic__transaction_html_ad86b8b9def7073307927ba6e41d0fbf5"><div class="ttname"><a href="classpmem_1_1obj_1_1basic__transaction.html#ad86b8b9def7073307927ba6e41d0fbf5">pmem::obj::basic_transaction::manual</a></div><div class="ttdeci">typename detail::transaction_base&lt; false &gt;::manual manual</div><div class="ttdoc">C++ manual scope transaction class.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:627</div></div>
<div class="ttc" id="apext_8hpp_html"><div class="ttname"><a href="pext_8hpp.html">pext.hpp</a></div><div class="ttdoc">Convenience extensions for the resides on pmem property template.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool__base_html"><div class="ttname"><a href="classpmem_1_1obj_1_1pool__base.html">pmem::obj::pool_base</a></div><div class="ttdoc">The non-template pool base class.</div><div class="ttdef"><b>Definition:</b> pool.hpp:46</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1shared__mutex_html"><div class="ttname"><a href="classpmem_1_1obj_1_1shared__mutex.html">pmem::obj::shared_mutex</a></div><div class="ttdoc">Persistent memory resident shared_mutex implementation.</div><div class="ttdef"><b>Definition:</b> shared_mutex.hpp:30</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1flat__transaction_html_a6162d1d30b3c679814498da961147c54"><div class="ttname"><a href="classpmem_1_1obj_1_1flat__transaction.html#a6162d1d30b3c679814498da961147c54">pmem::obj::flat_transaction::run</a></div><div class="ttdeci">static void run(obj::pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:817</div></div>
<div class="ttc" id="amutex_8hpp_html"><div class="ttname"><a href="mutex_8hpp.html">mutex.hpp</a></div><div class="ttdoc">Pmem-resident mutex.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
