<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::array&lt; T, N &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.12-git53.g67ba2be4</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structpmem_1_1obj_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::array&lt; T, N &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a> - persistent container with std::array compatible interface.  
 <a href="structpmem_1_1obj_1_1array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">libpmemobj++/container/array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae68e0913a1aaa4c3600d4779075d7e58"><td class="memItemLeft" align="right" valign="top"><a id="ae68e0913a1aaa4c3600d4779075d7e58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ae68e0913a1aaa4c3600d4779075d7e58">array</a> ()=default</td></tr>
<tr class="memdesc:ae68e0913a1aaa4c3600d4779075d7e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted constructor. <br /></td></tr>
<tr class="separator:ae68e0913a1aaa4c3600d4779075d7e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea6956f3f31833a4a2974668de7a2d8"><td class="memItemLeft" align="right" valign="top"><a id="a6ea6956f3f31833a4a2974668de7a2d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a6ea6956f3f31833a4a2974668de7a2d8">array</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;)=default</td></tr>
<tr class="memdesc:a6ea6956f3f31833a4a2974668de7a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a6ea6956f3f31833a4a2974668de7a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb0cc0fb29cddf94ac9e335b2fd9ce2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a2eb0cc0fb29cddf94ac9e335b2fd9ce2">array</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a2eb0cc0fb29cddf94ac9e335b2fd9ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor.  <a href="structpmem_1_1obj_1_1array.html#a2eb0cc0fb29cddf94ac9e335b2fd9ce2">More...</a><br /></td></tr>
<tr class="separator:a2eb0cc0fb29cddf94ac9e335b2fd9ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc9a5a1a84cf1fe2b03fa5faed70365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a8fc9a5a1a84cf1fe2b03fa5faed70365">operator=</a> (const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:a8fc9a5a1a84cf1fe2b03fa5faed70365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator - perform assignment from other <a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a>.  <a href="structpmem_1_1obj_1_1array.html#a8fc9a5a1a84cf1fe2b03fa5faed70365">More...</a><br /></td></tr>
<tr class="separator:a8fc9a5a1a84cf1fe2b03fa5faed70365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b848717acf59ee40470444233e84a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a426b848717acf59ee40470444233e84a">operator=</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a426b848717acf59ee40470444233e84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator - perform move assignment from other <a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a>.  <a href="structpmem_1_1obj_1_1array.html#a426b848717acf59ee40470444233e84a">More...</a><br /></td></tr>
<tr class="separator:a426b848717acf59ee40470444233e84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091273c3ae45017f89fdcc663dab9672"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a091273c3ae45017f89fdcc663dab9672">at</a> (size_type n)</td></tr>
<tr class="memdesc:a091273c3ae45017f89fdcc663dab9672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="structpmem_1_1obj_1_1array.html#a091273c3ae45017f89fdcc663dab9672">More...</a><br /></td></tr>
<tr class="separator:a091273c3ae45017f89fdcc663dab9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280a5721b30e3aa58f1eee8c16121cca"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a280a5721b30e3aa58f1eee8c16121cca">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a280a5721b30e3aa58f1eee8c16121cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="structpmem_1_1obj_1_1array.html#a280a5721b30e3aa58f1eee8c16121cca">More...</a><br /></td></tr>
<tr class="separator:a280a5721b30e3aa58f1eee8c16121cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dda2ebf8db9e533241bed222d127c2"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ab9dda2ebf8db9e533241bed222d127c2">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:ab9dda2ebf8db9e533241bed222d127c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="structpmem_1_1obj_1_1array.html#ab9dda2ebf8db9e533241bed222d127c2">More...</a><br /></td></tr>
<tr class="separator:ab9dda2ebf8db9e533241bed222d127c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e4393bb517a71a115bd1443952e83"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a716e4393bb517a71a115bd1443952e83">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a716e4393bb517a71a115bd1443952e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="structpmem_1_1obj_1_1array.html#a716e4393bb517a71a115bd1443952e83">More...</a><br /></td></tr>
<tr class="separator:a716e4393bb517a71a115bd1443952e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd225328f3237f90131447698567d12"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#aedd225328f3237f90131447698567d12">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:aedd225328f3237f90131447698567d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="structpmem_1_1obj_1_1array.html#aedd225328f3237f90131447698567d12">More...</a><br /></td></tr>
<tr class="separator:aedd225328f3237f90131447698567d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fd99b97b691ea80224d7aff535003b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a86fd99b97b691ea80224d7aff535003b">data</a> ()</td></tr>
<tr class="memdesc:a86fd99b97b691ea80224d7aff535003b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw pointer to the underlying data and adds entire array to a transaction.  <a href="structpmem_1_1obj_1_1array.html#a86fd99b97b691ea80224d7aff535003b">More...</a><br /></td></tr>
<tr class="separator:a86fd99b97b691ea80224d7aff535003b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5661322c5c8cabb758b1dbe2c6a8825f"><td class="memItemLeft" align="right" valign="top"><a id="a5661322c5c8cabb758b1dbe2c6a8825f"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a5661322c5c8cabb758b1dbe2c6a8825f">data</a> () const noexcept</td></tr>
<tr class="memdesc:a5661322c5c8cabb758b1dbe2c6a8825f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data. <br /></td></tr>
<tr class="separator:a5661322c5c8cabb758b1dbe2c6a8825f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aecb064fd60523a48df60e0ead6e1b"><td class="memItemLeft" align="right" valign="top"><a id="ae4aecb064fd60523a48df60e0ead6e1b"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ae4aecb064fd60523a48df60e0ead6e1b">cdata</a> () const noexcept</td></tr>
<tr class="memdesc:ae4aecb064fd60523a48df60e0ead6e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data. <br /></td></tr>
<tr class="separator:ae4aecb064fd60523a48df60e0ead6e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25481b8f6dcda7d5570fe8b0d3c28191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1detail_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a25481b8f6dcda7d5570fe8b0d3c28191">begin</a> ()</td></tr>
<tr class="memdesc:a25481b8f6dcda7d5570fe8b0d3c28191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="structpmem_1_1obj_1_1array.html#a25481b8f6dcda7d5570fe8b0d3c28191">More...</a><br /></td></tr>
<tr class="separator:a25481b8f6dcda7d5570fe8b0d3c28191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dce51fb43ebc8d6a39d9f13c803f99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1detail_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a27dce51fb43ebc8d6a39d9f13c803f99">end</a> ()</td></tr>
<tr class="memdesc:a27dce51fb43ebc8d6a39d9f13c803f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="structpmem_1_1obj_1_1array.html#a27dce51fb43ebc8d6a39d9f13c803f99">More...</a><br /></td></tr>
<tr class="separator:a27dce51fb43ebc8d6a39d9f13c803f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad038fb9bf58aa8824da4135b89cf145e"><td class="memItemLeft" align="right" valign="top"><a id="ad038fb9bf58aa8824da4135b89cf145e"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ad038fb9bf58aa8824da4135b89cf145e">begin</a> () const noexcept</td></tr>
<tr class="memdesc:ad038fb9bf58aa8824da4135b89cf145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="separator:ad038fb9bf58aa8824da4135b89cf145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf04c0662f3650186fa5fdca513d66d"><td class="memItemLeft" align="right" valign="top"><a id="acaf04c0662f3650186fa5fdca513d66d"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#acaf04c0662f3650186fa5fdca513d66d">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:acaf04c0662f3650186fa5fdca513d66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="separator:acaf04c0662f3650186fa5fdca513d66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338c84c89d32745f3289a0249c0ffb51"><td class="memItemLeft" align="right" valign="top"><a id="a338c84c89d32745f3289a0249c0ffb51"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a338c84c89d32745f3289a0249c0ffb51">end</a> () const noexcept</td></tr>
<tr class="memdesc:a338c84c89d32745f3289a0249c0ffb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end. <br /></td></tr>
<tr class="separator:a338c84c89d32745f3289a0249c0ffb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87ec25db6ebc63fd3c0326d1a6716af"><td class="memItemLeft" align="right" valign="top"><a id="ac87ec25db6ebc63fd3c0326d1a6716af"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ac87ec25db6ebc63fd3c0326d1a6716af">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ac87ec25db6ebc63fd3c0326d1a6716af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end. <br /></td></tr>
<tr class="separator:ac87ec25db6ebc63fd3c0326d1a6716af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d6eaf7970468b686fce336d833a5c"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a055d6eaf7970468b686fce336d833a5c">rbegin</a> ()</td></tr>
<tr class="memdesc:a055d6eaf7970468b686fce336d833a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="structpmem_1_1obj_1_1array.html#a055d6eaf7970468b686fce336d833a5c">More...</a><br /></td></tr>
<tr class="separator:a055d6eaf7970468b686fce336d833a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb6e5f6089b57122988394e601647a0"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#affb6e5f6089b57122988394e601647a0">rend</a> ()</td></tr>
<tr class="memdesc:affb6e5f6089b57122988394e601647a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="structpmem_1_1obj_1_1array.html#affb6e5f6089b57122988394e601647a0">More...</a><br /></td></tr>
<tr class="separator:affb6e5f6089b57122988394e601647a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78181ae853b67bbd8436ecb74cd513b8"><td class="memItemLeft" align="right" valign="top"><a id="a78181ae853b67bbd8436ecb74cd513b8"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a78181ae853b67bbd8436ecb74cd513b8">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a78181ae853b67bbd8436ecb74cd513b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning. <br /></td></tr>
<tr class="separator:a78181ae853b67bbd8436ecb74cd513b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935f0fb3f623918c6888f6a0c9876b69"><td class="memItemLeft" align="right" valign="top"><a id="a935f0fb3f623918c6888f6a0c9876b69"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a935f0fb3f623918c6888f6a0c9876b69">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a935f0fb3f623918c6888f6a0c9876b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning. <br /></td></tr>
<tr class="separator:a935f0fb3f623918c6888f6a0c9876b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fdf805cfc3587aac23fb6d81332f41"><td class="memItemLeft" align="right" valign="top"><a id="a54fdf805cfc3587aac23fb6d81332f41"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a54fdf805cfc3587aac23fb6d81332f41">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a54fdf805cfc3587aac23fb6d81332f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end. <br /></td></tr>
<tr class="separator:a54fdf805cfc3587aac23fb6d81332f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a84cb93bc35f9a89bd944ed31ced0e"><td class="memItemLeft" align="right" valign="top"><a id="a32a84cb93bc35f9a89bd944ed31ced0e"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a32a84cb93bc35f9a89bd944ed31ced0e">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a32a84cb93bc35f9a89bd944ed31ced0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning. <br /></td></tr>
<tr class="separator:a32a84cb93bc35f9a89bd944ed31ced0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad173e1452d51044f06fa5401415c6d99"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ad173e1452d51044f06fa5401415c6d99">front</a> ()</td></tr>
<tr class="memdesc:ad173e1452d51044f06fa5401415c6d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element and add this element to a transaction.  <a href="structpmem_1_1obj_1_1array.html#ad173e1452d51044f06fa5401415c6d99">More...</a><br /></td></tr>
<tr class="separator:ad173e1452d51044f06fa5401415c6d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8322020fe280ee7f2d0740e01f3ff3f"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ac8322020fe280ee7f2d0740e01f3ff3f">back</a> ()</td></tr>
<tr class="memdesc:ac8322020fe280ee7f2d0740e01f3ff3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element and add this element to a transaction.  <a href="structpmem_1_1obj_1_1array.html#ac8322020fe280ee7f2d0740e01f3ff3f">More...</a><br /></td></tr>
<tr class="separator:ac8322020fe280ee7f2d0740e01f3ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24edebbab9f23040672bc77f54e0f7a8"><td class="memItemLeft" align="right" valign="top"><a id="a24edebbab9f23040672bc77f54e0f7a8"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a24edebbab9f23040672bc77f54e0f7a8">front</a> () const</td></tr>
<tr class="memdesc:a24edebbab9f23040672bc77f54e0f7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. <br /></td></tr>
<tr class="separator:a24edebbab9f23040672bc77f54e0f7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1f5fa3388f1ac5330ff60dc7b18b37"><td class="memItemLeft" align="right" valign="top"><a id="aca1f5fa3388f1ac5330ff60dc7b18b37"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#aca1f5fa3388f1ac5330ff60dc7b18b37">cfront</a> () const</td></tr>
<tr class="memdesc:aca1f5fa3388f1ac5330ff60dc7b18b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. <br /></td></tr>
<tr class="separator:aca1f5fa3388f1ac5330ff60dc7b18b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1956e5c2bfa1853a74fa096950c9b9c"><td class="memItemLeft" align="right" valign="top"><a id="ac1956e5c2bfa1853a74fa096950c9b9c"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ac1956e5c2bfa1853a74fa096950c9b9c">back</a> () const</td></tr>
<tr class="memdesc:ac1956e5c2bfa1853a74fa096950c9b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. <br /></td></tr>
<tr class="separator:ac1956e5c2bfa1853a74fa096950c9b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67bb83968cbc9695a089395e7fc9704"><td class="memItemLeft" align="right" valign="top"><a id="ac67bb83968cbc9695a089395e7fc9704"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ac67bb83968cbc9695a089395e7fc9704">cback</a> () const</td></tr>
<tr class="memdesc:ac67bb83968cbc9695a089395e7fc9704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. <br /></td></tr>
<tr class="separator:ac67bb83968cbc9695a089395e7fc9704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82172c2ff69aef8927b633af3e275f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; pointer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ab82172c2ff69aef8927b633af3e275f2">range</a> (size_type start, size_type n)</td></tr>
<tr class="memdesc:ab82172c2ff69aef8927b633af3e275f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice and snapshots requested range.  <a href="structpmem_1_1obj_1_1array.html#ab82172c2ff69aef8927b633af3e275f2">More...</a><br /></td></tr>
<tr class="separator:ab82172c2ff69aef8927b633af3e275f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110da3eea10dd1f29cfc162f227e7cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; <a class="el" href="structpmem_1_1detail_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a110da3eea10dd1f29cfc162f227e7cd0">range</a> (size_type start, size_type n, size_type snapshot_size)</td></tr>
<tr class="memdesc:a110da3eea10dd1f29cfc162f227e7cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice.  <a href="structpmem_1_1obj_1_1array.html#a110da3eea10dd1f29cfc162f227e7cd0">More...</a><br /></td></tr>
<tr class="separator:a110da3eea10dd1f29cfc162f227e7cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8956b8c3f016a309b5394f691a768fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#af8956b8c3f016a309b5394f691a768fb">range</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:af8956b8c3f016a309b5394f691a768fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="structpmem_1_1obj_1_1array.html#af8956b8c3f016a309b5394f691a768fb">More...</a><br /></td></tr>
<tr class="separator:af8956b8c3f016a309b5394f691a768fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18013082cf8f420cda84e42bd1606314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a18013082cf8f420cda84e42bd1606314">crange</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:a18013082cf8f420cda84e42bd1606314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="structpmem_1_1obj_1_1array.html#a18013082cf8f420cda84e42bd1606314">More...</a><br /></td></tr>
<tr class="separator:a18013082cf8f420cda84e42bd1606314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2d70d6f848b5e193c73ca8249bc849"><td class="memItemLeft" align="right" valign="top"><a id="aeb2d70d6f848b5e193c73ca8249bc849"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#aeb2d70d6f848b5e193c73ca8249bc849">size</a> () const noexcept</td></tr>
<tr class="memdesc:aeb2d70d6f848b5e193c73ca8249bc849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of the array. <br /></td></tr>
<tr class="separator:aeb2d70d6f848b5e193c73ca8249bc849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130cc73738078f0b54300f71e3660b87"><td class="memItemLeft" align="right" valign="top"><a id="a130cc73738078f0b54300f71e3660b87"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a130cc73738078f0b54300f71e3660b87">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a130cc73738078f0b54300f71e3660b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum size of the array. <br /></td></tr>
<tr class="separator:a130cc73738078f0b54300f71e3660b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79315fa20aa86352ac45920107ab0fe"><td class="memItemLeft" align="right" valign="top"><a id="ad79315fa20aa86352ac45920107ab0fe"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ad79315fa20aa86352ac45920107ab0fe">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ad79315fa20aa86352ac45920107ab0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether array is empty. <br /></td></tr>
<tr class="separator:ad79315fa20aa86352ac45920107ab0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1707720aa273a00f5565b088905bf3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a1707720aa273a00f5565b088905bf3a9">fill</a> (const_reference value)</td></tr>
<tr class="memdesc:a1707720aa273a00f5565b088905bf3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills array with specified value inside internal transaction.  <a href="structpmem_1_1obj_1_1array.html#a1707720aa273a00f5565b088905bf3a9">More...</a><br /></td></tr>
<tr class="separator:a1707720aa273a00f5565b088905bf3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541423b874157227808aa80afc9d56b"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:ac541423b874157227808aa80afc9d56b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size !=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ac541423b874157227808aa80afc9d56b">swap</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:ac541423b874157227808aa80afc9d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps content with other array's content inside internal transaction.  <a href="structpmem_1_1obj_1_1array.html#ac541423b874157227808aa80afc9d56b">More...</a><br /></td></tr>
<tr class="separator:ac541423b874157227808aa80afc9d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2226f3aa46f77947790082510e94cdc"><td class="memTemplParams" colspan="2"><a id="af2226f3aa46f77947790082510e94cdc"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:af2226f3aa46f77947790082510e94cdc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size==0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#af2226f3aa46f77947790082510e94cdc">swap</a> (<a class="el" href="structpmem_1_1obj_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:af2226f3aa46f77947790082510e94cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap for zero-sized array. <br /></td></tr>
<tr class="separator:af2226f3aa46f77947790082510e94cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac0ae0a3c1478a2efdb8de297c21bf65d"><td class="memTemplParams" colspan="2"><a id="ac0ae0a3c1478a2efdb8de297c21bf65d"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:ac0ae0a3c1478a2efdb8de297c21bf65d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size !=0, T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ac0ae0a3c1478a2efdb8de297c21bf65d">_get_data</a> ()</td></tr>
<tr class="memdesc:ac0ae0a3c1478a2efdb8de297c21bf65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for non-zero sized array. <br /></td></tr>
<tr class="separator:ac0ae0a3c1478a2efdb8de297c21bf65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f0ea4f6ad32b8ff9f398a1a024559d"><td class="memTemplParams" colspan="2"><a id="ae3f0ea4f6ad32b8ff9f398a1a024559d"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:ae3f0ea4f6ad32b8ff9f398a1a024559d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size !=0, const T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#ae3f0ea4f6ad32b8ff9f398a1a024559d">_get_data</a> () const</td></tr>
<tr class="memdesc:ae3f0ea4f6ad32b8ff9f398a1a024559d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for non-zero sized array. <br /></td></tr>
<tr class="separator:ae3f0ea4f6ad32b8ff9f398a1a024559d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e7780c3f208f0b75dc8940f9024817"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a00e7780c3f208f0b75dc8940f9024817"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size==0, T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a00e7780c3f208f0b75dc8940f9024817">_get_data</a> ()</td></tr>
<tr class="memdesc:a00e7780c3f208f0b75dc8940f9024817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for zero sized array.  <a href="structpmem_1_1obj_1_1array.html#a00e7780c3f208f0b75dc8940f9024817">More...</a><br /></td></tr>
<tr class="separator:a00e7780c3f208f0b75dc8940f9024817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430fbdd78f7d968cf1f204aca12d1950"><td class="memTemplParams" colspan="2"><a id="a430fbdd78f7d968cf1f204aca12d1950"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a430fbdd78f7d968cf1f204aca12d1950"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size==0, const T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a430fbdd78f7d968cf1f204aca12d1950">_get_data</a> () const</td></tr>
<tr class="memdesc:a430fbdd78f7d968cf1f204aca12d1950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for zero sized array. <br /></td></tr>
<tr class="separator:a430fbdd78f7d968cf1f204aca12d1950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600917986d56914a0038238dcb176522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1array.html#a600917986d56914a0038238dcb176522">_get_pool</a> () const</td></tr>
<tr class="memdesc:a600917986d56914a0038238dcb176522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether object is on pmem and return <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pool_base</a> instance.  <a href="structpmem_1_1obj_1_1array.html#a600917986d56914a0038238dcb176522">More...</a><br /></td></tr>
<tr class="separator:a600917986d56914a0038238dcb176522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t N&gt;<br />
struct pmem::obj::array&lt; T, N &gt;</h3>

<p><a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a> - persistent container with std::array compatible interface. </p>
<p><a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a> can only be stored on pmem. Creating array on stack will result with "pool_error" exception.</p>
<p>All methods which allow write access to specific element will add it to an active transaction.</p>
<p>All methods which return non-const pointer to raw data add entire array to a transaction.</p>
<p>When a non-const iterator is returned it adds part of the array to a transaction while traversing. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2eb0cc0fb29cddf94ac9e335b2fd9ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb0cc0fb29cddf94ac9e335b2fd9ce2">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::<a class="el" href="structpmem_1_1obj_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaulted move constructor. </p>
<p>Performs member-wise move but do NOT add moved-from array to the transaction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00e7780c3f208f0b75dc8940f9024817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e7780c3f208f0b75dc8940f9024817">&#9670;&nbsp;</a></span>_get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::size_t Size = N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;Size == 0, T *&gt;::type <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::_get_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Support for zero sized array. </p>
<p>Return value is a unique address (address of the array itself); </p>

</div>
</div>
<a id="a600917986d56914a0038238dcb176522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600917986d56914a0038238dcb176522">&#9670;&nbsp;</a></span>_get_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::_get_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether object is on pmem and return <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pool_base</a> instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a091273c3ae45017f89fdcc663dab9672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091273c3ae45017f89fdcc663dab9672">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of bound. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a280a5721b30e3aa58f1eee8c16121cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280a5721b30e3aa58f1eee8c16121cca">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8322020fe280ee7f2d0740e01f3ff3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8322020fe280ee7f2d0740e01f3ff3f">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element and add this element to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25481b8f6dcda7d5570fe8b0d3c28191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25481b8f6dcda7d5570fe8b0d3c28191">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1detail_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9dda2ebf8db9e533241bed222d127c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dda2ebf8db9e533241bed222d127c2">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18013082cf8f420cda84e42bd1606314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18013082cf8f420cda84e42bd1606314">&#9670;&nbsp;</a></span>crange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt;const_iterator&gt; <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::crange </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86fd99b97b691ea80224d7aff535003b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fd99b97b691ea80224d7aff535003b">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns raw pointer to the underlying data and adds entire array to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27dce51fb43ebc8d6a39d9f13c803f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dce51fb43ebc8d6a39d9f13c803f99">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1detail_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1707720aa273a00f5565b088905bf3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1707720aa273a00f5565b088905bf3a9">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills array with specified value inside internal transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad173e1452d51044f06fa5401415c6d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad173e1452d51044f06fa5401415c6d99">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element and add this element to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426b848717acf59ee40470444233e84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b848717acf59ee40470444233e84a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&amp; <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator - perform move assignment from other <a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a>. </p>
<p>This function creates a transaction internally.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fc9a5a1a84cf1fe2b03fa5faed70365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc9a5a1a84cf1fe2b03fa5faed70365">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&amp; <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator - perform assignment from other <a class="el" href="structpmem_1_1obj_1_1array.html" title="pmem::obj::array - persistent container with std::array compatible interface.">pmem::obj::array</a>. </p>
<p>This function creates a transaction internally.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a716e4393bb517a71a115bd1443952e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716e4393bb517a71a115bd1443952e83">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedd225328f3237f90131447698567d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd225328f3237f90131447698567d12">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed. </p>

</div>
</div>
<a id="ab82172c2ff69aef8927b633af3e275f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82172c2ff69aef8927b633af3e275f2">&#9670;&nbsp;</a></span>range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt;pointer&gt; <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns slice and snapshots requested range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8956b8c3f016a309b5394f691a768fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8956b8c3f016a309b5394f691a768fb">&#9670;&nbsp;</a></span>range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt;const_iterator&gt; <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a110da3eea10dd1f29cfc162f227e7cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110da3eea10dd1f29cfc162f227e7cd0">&#9670;&nbsp;</a></span>range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1slice.html">slice</a>&lt;<a class="el" href="structpmem_1_1detail_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a>&gt; <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>snapshot_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot_size</td><td>number of elements which should be snapshotted in a bulk while traversing this slice. If provided value is larger or equal to n, entire range is added to a transaction. If value is equal to 0 no snapshotting happens.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a055d6eaf7970468b686fce336d833a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055d6eaf7970468b686fce336d833a5c">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affb6e5f6089b57122988394e601647a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb6e5f6089b57122988394e601647a0">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac541423b874157227808aa80afc9d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac541423b874157227808aa80afc9d56b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::size_t Size = N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;Size != 0&gt;::type <a class="el" href="structpmem_1_1obj_1_1array.html">pmem::obj::array</a>&lt; T, N &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps content with other array's content inside internal transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>libpmemobj++/container/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
