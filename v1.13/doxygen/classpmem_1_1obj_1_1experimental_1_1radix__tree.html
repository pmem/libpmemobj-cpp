<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::radix_tree&lt; Key, Value, BytesView, MtMode &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git23.gf49772ac</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1radix__tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::radix_tree&lt; Key, Value, BytesView, MtMode &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Radix tree is an associative, ordered container.  
 <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="radix__tree_8hpp_source.html">libpmemobj++/experimental/radix_tree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1leaf.html">leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the structure which 'holds' key/value pair.  <a href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is internal node.  <a href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">radix_tree_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radix tree iterator supports multipass and bidirectional iteration.  <a href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6b9d3b178a7c3ca9c355cfa1965e09c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af6b9d3b178a7c3ca9c355cfa1965e09c">radix_tree</a> ()</td></tr>
<tr class="memdesc:af6b9d3b178a7c3ca9c355cfa1965e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default radix tree constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af6b9d3b178a7c3ca9c355cfa1965e09c">More...</a><br /></td></tr>
<tr class="separator:af6b9d3b178a7c3ca9c355cfa1965e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645bcd671af0f7a5f93129fb53f0e866"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a645bcd671af0f7a5f93129fb53f0e866"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a645bcd671af0f7a5f93129fb53f0e866">radix_tree</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a645bcd671af0f7a5f93129fb53f0e866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a645bcd671af0f7a5f93129fb53f0e866">More...</a><br /></td></tr>
<tr class="separator:a645bcd671af0f7a5f93129fb53f0e866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0051c29a315d79e8f8db74b7dec4dad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab0051c29a315d79e8f8db74b7dec4dad">radix_tree</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;m)</td></tr>
<tr class="memdesc:ab0051c29a315d79e8f8db74b7dec4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab0051c29a315d79e8f8db74b7dec4dad">More...</a><br /></td></tr>
<tr class="separator:ab0051c29a315d79e8f8db74b7dec4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84aff431de32f17fd769e4435a676bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af84aff431de32f17fd769e4435a676bb">radix_tree</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:af84aff431de32f17fd769e4435a676bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af84aff431de32f17fd769e4435a676bb">More...</a><br /></td></tr>
<tr class="separator:af84aff431de32f17fd769e4435a676bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26da05083c9407fd0639bc612ffeee53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a26da05083c9407fd0639bc612ffeee53">radix_tree</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a26da05083c9407fd0639bc612ffeee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a26da05083c9407fd0639bc612ffeee53">More...</a><br /></td></tr>
<tr class="separator:a26da05083c9407fd0639bc612ffeee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc07a93cf85b8df75a15b1b20abefde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acc07a93cf85b8df75a15b1b20abefde3">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;m)</td></tr>
<tr class="memdesc:acc07a93cf85b8df75a15b1b20abefde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acc07a93cf85b8df75a15b1b20abefde3">More...</a><br /></td></tr>
<tr class="separator:acc07a93cf85b8df75a15b1b20abefde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b9368cc06963f58afe936f70d46c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a30b9368cc06963f58afe936f70d46c57">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:a30b9368cc06963f58afe936f70d46c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a30b9368cc06963f58afe936f70d46c57">More...</a><br /></td></tr>
<tr class="separator:a30b9368cc06963f58afe936f70d46c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf7ae4492dfffc43983fe599adb911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a0cdf7ae4492dfffc43983fe599adb911">operator=</a> (std::initializer_list&lt; value_type &gt; ilist)</td></tr>
<tr class="memdesc:a0cdf7ae4492dfffc43983fe599adb911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a0cdf7ae4492dfffc43983fe599adb911">More...</a><br /></td></tr>
<tr class="separator:a0cdf7ae4492dfffc43983fe599adb911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bafb78b0176dbbd3b10d53ed7de3f6"><td class="memItemLeft" align="right" valign="top"><a id="ab0bafb78b0176dbbd3b10d53ed7de3f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab0bafb78b0176dbbd3b10d53ed7de3f6">~radix_tree</a> ()</td></tr>
<tr class="memdesc:ab0bafb78b0176dbbd3b10d53ed7de3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab0bafb78b0176dbbd3b10d53ed7de3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b60230ccd208ea193a54dc885a69bf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a82b60230ccd208ea193a54dc885a69bf">insert</a> (const value_type &amp;<a class="el" href="classpmem_1_1obj_1_1experimental_1_1v.html">v</a>)</td></tr>
<tr class="memdesc:a82b60230ccd208ea193a54dc885a69bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element if the tree doesn't already contain an element with an equivalent key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a82b60230ccd208ea193a54dc885a69bf">More...</a><br /></td></tr>
<tr class="separator:a82b60230ccd208ea193a54dc885a69bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad033295bae5a09c1dbcee4f0a4c4ea9b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad033295bae5a09c1dbcee4f0a4c4ea9b">insert</a> (value_type &amp;&amp;<a class="el" href="classpmem_1_1obj_1_1experimental_1_1v.html">v</a>)</td></tr>
<tr class="memdesc:ad033295bae5a09c1dbcee4f0a4c4ea9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element using move semantic if the tree doesn't already contain an element with an equivalent key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad033295bae5a09c1dbcee4f0a4c4ea9b">More...</a><br /></td></tr>
<tr class="separator:ad033295bae5a09c1dbcee4f0a4c4ea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f029cd2957aedd0aa847a282d94858"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ae1f029cd2957aedd0aa847a282d94858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae1f029cd2957aedd0aa847a282d94858">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ae1f029cd2957aedd0aa847a282d94858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last).  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae1f029cd2957aedd0aa847a282d94858">More...</a><br /></td></tr>
<tr class="separator:ae1f029cd2957aedd0aa847a282d94858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45748545d7206712d0e004ca76e753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a3f45748545d7206712d0e004ca76e753">insert</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a3f45748545d7206712d0e004ca76e753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list il.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a3f45748545d7206712d0e004ca76e753">More...</a><br /></td></tr>
<tr class="separator:a3f45748545d7206712d0e004ca76e753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca76d02d7df1ddaf38682b5916f2a84d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename BV  = BytesView, class... Args&gt; </td></tr>
<tr class="memitem:aca76d02d7df1ddaf38682b5916f2a84d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aca76d02d7df1ddaf38682b5916f2a84d">try_emplace</a> (K &amp;&amp;k, Args &amp;&amp;... args) -&gt; typename std::enable_if&lt; detail::has_is_transparent&lt; BV &gt;::value &amp;&amp;!std::is_same&lt; typename std::remove_const&lt; typename std::remove_reference&lt; K &gt;::type &gt;::type, key_type &gt;::value, std::pair&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&gt;::type</td></tr>
<tr class="memdesc:aca76d02d7df1ddaf38682b5916f2a84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aca76d02d7df1ddaf38682b5916f2a84d">More...</a><br /></td></tr>
<tr class="separator:aca76d02d7df1ddaf38682b5916f2a84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911144b704aa36422895e0f760db9487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a911144b704aa36422895e0f760db9487">erase</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a911144b704aa36422895e0f760db9487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos from the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a911144b704aa36422895e0f760db9487">More...</a><br /></td></tr>
<tr class="separator:a911144b704aa36422895e0f760db9487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bb8cffb2e40c24ae9472d509c5a644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa8bb8cffb2e40c24ae9472d509c5a644">erase</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> first, <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:aa8bb8cffb2e40c24ae9472d509c5a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa8bb8cffb2e40c24ae9472d509c5a644">More...</a><br /></td></tr>
<tr class="separator:aa8bb8cffb2e40c24ae9472d509c5a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9cf9d85d3c1f452d0ac4b294545a7e"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aac9cf9d85d3c1f452d0ac4b294545a7e">erase</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:aac9cf9d85d3c1f452d0ac4b294545a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aac9cf9d85d3c1f452d0ac4b294545a7e">More...</a><br /></td></tr>
<tr class="separator:aac9cf9d85d3c1f452d0ac4b294545a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81481efd41bc044e9a1c9549753bef71"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			  detail::has_is_transparent&lt;BytesView&gt;::value &amp;&amp;				  !std::is_same&lt;K, iterator&gt;::value &amp;&amp;				  !std::is_same&lt;K, const_iterator&gt;::value,			  K&gt;::type&gt; </td></tr>
<tr class="memitem:a81481efd41bc044e9a1c9549753bef71"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a81481efd41bc044e9a1c9549753bef71">erase</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a81481efd41bc044e9a1c9549753bef71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a81481efd41bc044e9a1c9549753bef71">More...</a><br /></td></tr>
<tr class="separator:a81481efd41bc044e9a1c9549753bef71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538c01a4c0e669fcc77eeb03c505d2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab538c01a4c0e669fcc77eeb03c505d2c">clear</a> ()</td></tr>
<tr class="memdesc:ab538c01a4c0e669fcc77eeb03c505d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab538c01a4c0e669fcc77eeb03c505d2c">More...</a><br /></td></tr>
<tr class="separator:ab538c01a4c0e669fcc77eeb03c505d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af619540544e8c905a41d90f96265ccff"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af619540544e8c905a41d90f96265ccff">count</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:af619540544e8c905a41d90f96265ccff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#af619540544e8c905a41d90f96265ccff">More...</a><br /></td></tr>
<tr class="separator:af619540544e8c905a41d90f96265ccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d69c77963d3f6c0581f4f205ae94da2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a2d69c77963d3f6c0581f4f205ae94da2"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2d69c77963d3f6c0581f4f205ae94da2">count</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a2d69c77963d3f6c0581f4f205ae94da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2d69c77963d3f6c0581f4f205ae94da2">More...</a><br /></td></tr>
<tr class="separator:a2d69c77963d3f6c0581f4f205ae94da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11b48a312946f29cf2461b5be54a810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac11b48a312946f29cf2461b5be54a810">find</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:ac11b48a312946f29cf2461b5be54a810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac11b48a312946f29cf2461b5be54a810">More...</a><br /></td></tr>
<tr class="separator:ac11b48a312946f29cf2461b5be54a810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c986ed9935d888cce483174956cdfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2c986ed9935d888cce483174956cdfe2">find</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a2c986ed9935d888cce483174956cdfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a2c986ed9935d888cce483174956cdfe2">More...</a><br /></td></tr>
<tr class="separator:a2c986ed9935d888cce483174956cdfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5ea4d707eae61f548053be7d843353"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a9e5ea4d707eae61f548053be7d843353"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9e5ea4d707eae61f548053be7d843353">find</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a9e5ea4d707eae61f548053be7d843353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9e5ea4d707eae61f548053be7d843353">More...</a><br /></td></tr>
<tr class="separator:a9e5ea4d707eae61f548053be7d843353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55311147ae4c0c37ded3941ac2d2ac19"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a55311147ae4c0c37ded3941ac2d2ac19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a55311147ae4c0c37ded3941ac2d2ac19">find</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a55311147ae4c0c37ded3941ac2d2ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a55311147ae4c0c37ded3941ac2d2ac19">More...</a><br /></td></tr>
<tr class="separator:a55311147ae4c0c37ded3941ac2d2ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b34803d4d846ab9cfe83622d160579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa2b34803d4d846ab9cfe83622d160579">lower_bound</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:aa2b34803d4d846ab9cfe83622d160579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aa2b34803d4d846ab9cfe83622d160579">More...</a><br /></td></tr>
<tr class="separator:aa2b34803d4d846ab9cfe83622d160579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff0b7b64e9c1a64c56883055c202bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a0ff0b7b64e9c1a64c56883055c202bff">lower_bound</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a0ff0b7b64e9c1a64c56883055c202bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a0ff0b7b64e9c1a64c56883055c202bff">More...</a><br /></td></tr>
<tr class="separator:a0ff0b7b64e9c1a64c56883055c202bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c58c06e0247a7d290d0806aa8011f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a9b5c58c06e0247a7d290d0806aa8011f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9b5c58c06e0247a7d290d0806aa8011f">lower_bound</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a9b5c58c06e0247a7d290d0806aa8011f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9b5c58c06e0247a7d290d0806aa8011f">More...</a><br /></td></tr>
<tr class="separator:a9b5c58c06e0247a7d290d0806aa8011f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f2e2ccbaf694abb1e958b1a45e5295"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:ae6f2e2ccbaf694abb1e958b1a45e5295"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae6f2e2ccbaf694abb1e958b1a45e5295">lower_bound</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:ae6f2e2ccbaf694abb1e958b1a45e5295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae6f2e2ccbaf694abb1e958b1a45e5295">More...</a><br /></td></tr>
<tr class="separator:ae6f2e2ccbaf694abb1e958b1a45e5295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf74a83bceb322b1d46c7ae1804a26fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acf74a83bceb322b1d46c7ae1804a26fd">upper_bound</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:acf74a83bceb322b1d46c7ae1804a26fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#acf74a83bceb322b1d46c7ae1804a26fd">More...</a><br /></td></tr>
<tr class="separator:acf74a83bceb322b1d46c7ae1804a26fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8215dc46b7ddc54d3465f99b1ce9dd93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8215dc46b7ddc54d3465f99b1ce9dd93">upper_bound</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a8215dc46b7ddc54d3465f99b1ce9dd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a8215dc46b7ddc54d3465f99b1ce9dd93">More...</a><br /></td></tr>
<tr class="separator:a8215dc46b7ddc54d3465f99b1ce9dd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4c2141f60212a4035e98a9a8e583b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a6ea4c2141f60212a4035e98a9a8e583b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6ea4c2141f60212a4035e98a9a8e583b">upper_bound</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a6ea4c2141f60212a4035e98a9a8e583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6ea4c2141f60212a4035e98a9a8e583b">More...</a><br /></td></tr>
<tr class="separator:a6ea4c2141f60212a4035e98a9a8e583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d6c37a4c9f9326c4098e2d8c2ea86"><td class="memTemplParams" colspan="2">template&lt;typename K , typename  = typename std::enable_if&lt;			detail::has_is_transparent&lt;BytesView&gt;::value, K&gt;::type&gt; </td></tr>
<tr class="memitem:a639d6c37a4c9f9326c4098e2d8c2ea86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a639d6c37a4c9f9326c4098e2d8c2ea86">upper_bound</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a639d6c37a4c9f9326c4098e2d8c2ea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a639d6c37a4c9f9326c4098e2d8c2ea86">More...</a><br /></td></tr>
<tr class="separator:a639d6c37a4c9f9326c4098e2d8c2ea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678d368ade5e9ffa6cb64fdd75340c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5678d368ade5e9ffa6cb64fdd75340c9">begin</a> ()</td></tr>
<tr class="memdesc:a5678d368ade5e9ffa6cb64fdd75340c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5678d368ade5e9ffa6cb64fdd75340c9">More...</a><br /></td></tr>
<tr class="separator:a5678d368ade5e9ffa6cb64fdd75340c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5aad5a40f48d6098690a21ca239e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6b5aad5a40f48d6098690a21ca239e1b">end</a> ()</td></tr>
<tr class="memdesc:a6b5aad5a40f48d6098690a21ca239e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6b5aad5a40f48d6098690a21ca239e1b">More...</a><br /></td></tr>
<tr class="separator:a6b5aad5a40f48d6098690a21ca239e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef58c58c4c53e5ac8e57471833b82c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a3ef58c58c4c53e5ac8e57471833b82c2">cbegin</a> () const</td></tr>
<tr class="memdesc:a3ef58c58c4c53e5ac8e57471833b82c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element of the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a3ef58c58c4c53e5ac8e57471833b82c2">More...</a><br /></td></tr>
<tr class="separator:a3ef58c58c4c53e5ac8e57471833b82c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a63a6cd496383a1051dffc063ce4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad30a63a6cd496383a1051dffc063ce4e">cend</a> () const</td></tr>
<tr class="memdesc:ad30a63a6cd496383a1051dffc063ce4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the map.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad30a63a6cd496383a1051dffc063ce4e">More...</a><br /></td></tr>
<tr class="separator:ad30a63a6cd496383a1051dffc063ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c82e23114a473ac66b4252e0fa746a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae6c82e23114a473ac66b4252e0fa746a">begin</a> () const</td></tr>
<tr class="memdesc:ae6c82e23114a473ac66b4252e0fa746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element of the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ae6c82e23114a473ac66b4252e0fa746a">More...</a><br /></td></tr>
<tr class="separator:ae6c82e23114a473ac66b4252e0fa746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cbf80475d11b54aaac97b43b0f3c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a51cbf80475d11b54aaac97b43b0f3c54">end</a> () const</td></tr>
<tr class="memdesc:a51cbf80475d11b54aaac97b43b0f3c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the map.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a51cbf80475d11b54aaac97b43b0f3c54">More...</a><br /></td></tr>
<tr class="separator:a51cbf80475d11b54aaac97b43b0f3c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909dd4e599193a94bdd03c1c30254ed9"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a909dd4e599193a94bdd03c1c30254ed9">rbegin</a> ()</td></tr>
<tr class="memdesc:a909dd4e599193a94bdd03c1c30254ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a909dd4e599193a94bdd03c1c30254ed9">More...</a><br /></td></tr>
<tr class="separator:a909dd4e599193a94bdd03c1c30254ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c98bb49bccfe5827b8fa4ba3c11b17"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a45c98bb49bccfe5827b8fa4ba3c11b17">rend</a> ()</td></tr>
<tr class="memdesc:a45c98bb49bccfe5827b8fa4ba3c11b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a45c98bb49bccfe5827b8fa4ba3c11b17">More...</a><br /></td></tr>
<tr class="separator:a45c98bb49bccfe5827b8fa4ba3c11b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a02f4d02ac75aa37377b94e11997802"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5a02f4d02ac75aa37377b94e11997802">crbegin</a> () const</td></tr>
<tr class="memdesc:a5a02f4d02ac75aa37377b94e11997802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const, reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5a02f4d02ac75aa37377b94e11997802">More...</a><br /></td></tr>
<tr class="separator:a5a02f4d02ac75aa37377b94e11997802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8e3c12490178ec19f47d95904b68f1"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1c8e3c12490178ec19f47d95904b68f1">crend</a> () const</td></tr>
<tr class="memdesc:a1c8e3c12490178ec19f47d95904b68f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const, reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1c8e3c12490178ec19f47d95904b68f1">More...</a><br /></td></tr>
<tr class="separator:a1c8e3c12490178ec19f47d95904b68f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ad84a2a88f32824bbe3892de1bede"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a710ad84a2a88f32824bbe3892de1bede">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a710ad84a2a88f32824bbe3892de1bede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a710ad84a2a88f32824bbe3892de1bede">More...</a><br /></td></tr>
<tr class="separator:a710ad84a2a88f32824bbe3892de1bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81743c7f071ac58c47dd4d8f41255234"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a81743c7f071ac58c47dd4d8f41255234">max_size</a> () const noexcept</td></tr>
<tr class="separator:a81743c7f071ac58c47dd4d8f41255234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc76a8444bd401b32ec64b3e55de57c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5dc76a8444bd401b32ec64b3e55de57c">size</a> () const noexcept</td></tr>
<tr class="separator:a5dc76a8444bd401b32ec64b3e55de57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb001c8541de8503662b912a08aa52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a48fb001c8541de8503662b912a08aa52">swap</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> &amp;rhs)</td></tr>
<tr class="memdesc:a48fb001c8541de8503662b912a08aa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member swap.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a48fb001c8541de8503662b912a08aa52">More...</a><br /></td></tr>
<tr class="separator:a48fb001c8541de8503662b912a08aa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd8a7e23e435112ef91e541c4ade89"><td class="memTemplParams" colspan="2">template&lt;bool Mt = MtMode, typename Enable  = typename std::enable_if&lt;Mt&gt;::type&gt; </td></tr>
<tr class="memitem:ac4bd8a7e23e435112ef91e541c4ade89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac4bd8a7e23e435112ef91e541c4ade89">garbage_collect</a> ()</td></tr>
<tr class="memdesc:ac4bd8a7e23e435112ef91e541c4ade89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to collect and free some garbage produced by erase, clear, insert_or_assign or assign_val in concurrent mode (if MtMode == true).  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac4bd8a7e23e435112ef91e541c4ade89">More...</a><br /></td></tr>
<tr class="separator:ac4bd8a7e23e435112ef91e541c4ade89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f39d8786d3880243638f430b0dedf9"><td class="memTemplParams" colspan="2">template&lt;bool Mt = MtMode, typename Enable  = typename std::enable_if&lt;Mt&gt;::type&gt; </td></tr>
<tr class="memitem:ad1f39d8786d3880243638f430b0dedf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad1f39d8786d3880243638f430b0dedf9">garbage_collect_force</a> ()</td></tr>
<tr class="memdesc:ad1f39d8786d3880243638f430b0dedf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs full epochs synchronisation.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad1f39d8786d3880243638f430b0dedf9">More...</a><br /></td></tr>
<tr class="separator:ad1f39d8786d3880243638f430b0dedf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9f9f7d0de453b47651a789cbd8ce31"><td class="memTemplParams" colspan="2">template&lt;bool Mt = MtMode, typename Enable  = typename std::enable_if&lt;Mt&gt;::type&gt; </td></tr>
<tr class="memitem:a6f9f9f7d0de453b47651a789cbd8ce31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6f9f9f7d0de453b47651a789cbd8ce31">runtime_initialize_mt</a> (<a class="el" href="classpmem_1_1detail_1_1ebr.html">ebr</a> *e=new <a class="el" href="classpmem_1_1detail_1_1ebr.html">ebr</a>())</td></tr>
<tr class="memdesc:a6f9f9f7d0de453b47651a789cbd8ce31"><td class="mdescLeft">&#160;</td><td class="mdescRight">If MtMode == true, this function must be called after each application restart.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6f9f9f7d0de453b47651a789cbd8ce31">More...</a><br /></td></tr>
<tr class="separator:a6f9f9f7d0de453b47651a789cbd8ce31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4176931890eb262d3d95f08d513d2c3f"><td class="memTemplParams" colspan="2"><a id="a4176931890eb262d3d95f08d513d2c3f"></a>
template&lt;bool Mt = MtMode, typename Enable  = typename std::enable_if&lt;Mt&gt;::type&gt; </td></tr>
<tr class="memitem:a4176931890eb262d3d95f08d513d2c3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4176931890eb262d3d95f08d513d2c3f">runtime_finalize_mt</a> ()</td></tr>
<tr class="memdesc:a4176931890eb262d3d95f08d513d2c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If MtMode == true, this function must be called before each application close and before calling radix destructor or there will be possible a memory leak. <br /></td></tr>
<tr class="separator:a4176931890eb262d3d95f08d513d2c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9861008e30d654c81af8276216dc2314"><td class="memTemplParams" colspan="2">template&lt;bool Mt = MtMode, typename Enable  = typename std::enable_if&lt;Mt&gt;::type&gt; </td></tr>
<tr class="memitem:a9861008e30d654c81af8276216dc2314"><td class="memTemplItemLeft" align="right" valign="top">worker_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9861008e30d654c81af8276216dc2314">register_worker</a> ()</td></tr>
<tr class="memdesc:a9861008e30d654c81af8276216dc2314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers and returns a new worker, which can perform critical operations (accessing some shared data that can be removed in other threads).  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a9861008e30d654c81af8276216dc2314">More...</a><br /></td></tr>
<tr class="separator:a9861008e30d654c81af8276216dc2314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6571eed2800b0e0d84b2b3d3ab0fcc"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6f6571eed2800b0e0d84b2b3d3ab0fcc"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6f6571eed2800b0e0d84b2b3d3ab0fcc">try_emplace</a> (const key_type &amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6f6571eed2800b0e0d84b2b3d3ab0fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6f6571eed2800b0e0d84b2b3d3ab0fcc">More...</a><br /></td></tr>
<tr class="separator:a6f6571eed2800b0e0d84b2b3d3ab0fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f39db2af971c8e68200c0f0ae6804c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab0f39db2af971c8e68200c0f0ae6804c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab0f39db2af971c8e68200c0f0ae6804c">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab0f39db2af971c8e68200c0f0ae6804c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab0f39db2af971c8e68200c0f0ae6804c">More...</a><br /></td></tr>
<tr class="separator:ab0f39db2af971c8e68200c0f0ae6804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b5ba88b73852255bb661a81af7c421"><td class="memTemplParams" colspan="2">template&lt;typename P , typename &gt; </td></tr>
<tr class="memitem:a29b5ba88b73852255bb661a81af7c421"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a29b5ba88b73852255bb661a81af7c421">insert</a> (P &amp;&amp;<a class="el" href="classpmem_1_1obj_1_1p.html">p</a>)</td></tr>
<tr class="memdesc:a29b5ba88b73852255bb661a81af7c421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element if the tree doesn't already contain an element with an equivalent key.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a29b5ba88b73852255bb661a81af7c421">More...</a><br /></td></tr>
<tr class="separator:a29b5ba88b73852255bb661a81af7c421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea96deed6034e7a9dea018ea2d26c3ab"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aea96deed6034e7a9dea018ea2d26c3ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aea96deed6034e7a9dea018ea2d26c3ab">try_emplace</a> (key_type &amp;&amp;k, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aea96deed6034e7a9dea018ea2d26c3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, does nothing.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#aea96deed6034e7a9dea018ea2d26c3ab">More...</a><br /></td></tr>
<tr class="separator:aea96deed6034e7a9dea018ea2d26c3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0094bddefa891a690e2e3fea137f233b"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a0094bddefa891a690e2e3fea137f233b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a0094bddefa891a690e2e3fea137f233b">insert_or_assign</a> (const key_type &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a0094bddefa891a690e2e3fea137f233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a0094bddefa891a690e2e3fea137f233b">More...</a><br /></td></tr>
<tr class="separator:a0094bddefa891a690e2e3fea137f233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd62e8fec402b5e100ed8cd3d270f9e"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a5fd62e8fec402b5e100ed8cd3d270f9e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5fd62e8fec402b5e100ed8cd3d270f9e">insert_or_assign</a> (key_type &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a5fd62e8fec402b5e100ed8cd3d270f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5fd62e8fec402b5e100ed8cd3d270f9e">More...</a><br /></td></tr>
<tr class="separator:a5fd62e8fec402b5e100ed8cd3d270f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19434a322c0611d87a8a1b58521690c7"><td class="memTemplParams" colspan="2">template&lt;typename M , typename K , typename &gt; </td></tr>
<tr class="memitem:a19434a322c0611d87a8a1b58521690c7"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a19434a322c0611d87a8a1b58521690c7">insert_or_assign</a> (K &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a19434a322c0611d87a8a1b58521690c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a19434a322c0611d87a8a1b58521690c7">More...</a><br /></td></tr>
<tr class="separator:a19434a322c0611d87a8a1b58521690c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a42d6ead8ca57935b6bfeede8dc303bcd"><td class="memTemplParams" colspan="2"><a id="a42d6ead8ca57935b6bfeede8dc303bcd"></a>
template&lt;bool Lower, typename K &gt; </td></tr>
<tr class="memitem:a42d6ead8ca57935b6bfeede8dc303bcd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a42d6ead8ca57935b6bfeede8dc303bcd">validate_bound</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> it, const K &amp;key) const</td></tr>
<tr class="memdesc:a42d6ead8ca57935b6bfeede8dc303bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if iterator points to element which compares bigger (or equal) to key. <br /></td></tr>
<tr class="separator:a42d6ead8ca57935b6bfeede8dc303bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ed80ba899b91aa162217269ee9579b"><td class="memTemplParams" colspan="2">template&lt;bool Mt = MtMode&gt; </td></tr>
<tr class="memitem:ab9ed80ba899b91aa162217269ee9579b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Mt, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab9ed80ba899b91aa162217269ee9579b">validate_path</a> (const path_type &amp;path) const</td></tr>
<tr class="memdesc:ab9ed80ba899b91aa162217269ee9579b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any node in the.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ab9ed80ba899b91aa162217269ee9579b">More...</a><br /></td></tr>
<tr class="separator:ab9ed80ba899b91aa162217269ee9579b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ae93265e2acae67088fcb570a04819"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7ae93265e2acae67088fcb570a04819"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad7ae93265e2acae67088fcb570a04819">free</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:ad7ae93265e2acae67088fcb570a04819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes node/leaf pointed by ptr.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ad7ae93265e2acae67088fcb570a04819">More...</a><br /></td></tr>
<tr class="separator:ad7ae93265e2acae67088fcb570a04819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6317bcfafc829713adbad736690e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1c6317bcfafc829713adbad736690e09">check_pmem</a> ()</td></tr>
<tr class="memdesc:a1c6317bcfafc829713adbad736690e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a1c6317bcfafc829713adbad736690e09">More...</a><br /></td></tr>
<tr class="separator:a1c6317bcfafc829713adbad736690e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689d9cbfd508d37796d6096a4aceedc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a689d9cbfd508d37796d6096a4aceedc1">check_tx_stage_work</a> ()</td></tr>
<tr class="memdesc:a689d9cbfd508d37796d6096a4aceedc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a689d9cbfd508d37796d6096a4aceedc1">More...</a><br /></td></tr>
<tr class="separator:a689d9cbfd508d37796d6096a4aceedc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, typename BytesView = bytes_view&lt;Key&gt;, bool MtMode = false&gt;<br />
class pmem::obj::experimental::radix_tree&lt; Key, Value, BytesView, MtMode &gt;</h3>

<p>Radix tree is an associative, ordered container. </p>
<p>Its API is similar to the API of std::map.</p>
<p>Unlike std::map radix tree does not use comparison (std::less or equivalent) to locate elements. Instead, keys are mapped to a sequence of bytes using user-provided BytesView type. The key's bytes uniquely define the position of an element. In some way, it is similar to a hash table (BytesView can be treated as a hash function) but with sorted elements.</p>
<p>The elements' ordering is defined based on the BytesView mapping. The byte sequences are compared using a function equivalent to std::string::compare.</p>
<p>BytesView should accept a pointer to the key type in a constructor and provide operator[] (should return a byte at the specified position in the byte representation of value) and size (should return size of value in bytes) method. The declaration should be as following:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BytesView {</div>
<div class="line"> BytesView(<span class="keyword">const</span> Type* t);</div>
<div class="line"> <span class="keywordtype">char</span> operator[](<span class="keywordtype">size_t</span> pos) <span class="keyword">const</span>; <span class="comment">// Must be const!</span></div>
<div class="line"> <span class="keywordtype">size_t</span> <a class="code" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5dc76a8444bd401b32ec64b3e55de57c">size</a>() <span class="keyword">const</span>; <span class="comment">// Must be const!</span></div>
<div class="line">};</div>
<div class="ttc" id="aclasspmem_1_1obj_1_1experimental_1_1radix__tree_html_a5dc76a8444bd401b32ec64b3e55de57c"><div class="ttname"><a href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5dc76a8444bd401b32ec64b3e55de57c">pmem::obj::experimental::radix_tree::size</a></div><div class="ttdeci">uint64_t size() const noexcept</div><div class="ttdef"><b>Definition:</b> radix_tree.hpp:961</div></div>
</div><!-- fragment --><p>By default, implementation for pmem::obj::basic_inline_string&lt;CharT, Traits&gt; and unsigned integral types is provided. Note that integral types are assumed to be in little-endian.</p>
<p>Iterators and references are stable (are not invalidated by inserts or erases of other elements nor by assigning to the value) for all value types except basic_inline_string&lt;CharT, Traits&gt;.</p>
<p>In case of basic_inline_string&lt;CharT, Traits&gt;, iterators and references are not invalidated by other inserts or erases, but might be invalidated by assigning new value to the element. Using find(K).assign_val("new_value") may invalidate other iterators and references to the element with key K.</p>
<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a48fb001c8541de8503662b912a08aa52" title="Member swap.">swap()</a> invalidates all references and iterators.</p>
<p>MtMode enables single-writer multiple-readers concurrency with read uncommitted isolation. In this, mode user HAS TO call runtime_initialize_mt after each application restart and runtime_finalize_mt before destroying radix tree.</p>
<p>Enabling MtMode has the following effects:</p><ul>
<li>erase and clear does not free nodes/leaves immediately, instead they are added to a garbage list which can be freed by calling <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#ac4bd8a7e23e435112ef91e541c4ade89" title="Tries to collect and free some garbage produced by erase, clear, insert_or_assign or assign_val in co...">garbage_collect()</a></li>
<li>insert_or_assign and <a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html#aac23aa09b8deef35e09fc41a439270bd" title="Handles assignment to the value.">iterator.assign_val</a> do not perform an in-place update, instead a new leaf is allocated and the old one is added to the garbage list</li>
<li>memory-reclamation mechanisms are initialized</li>
</ul>
<p>By default, concurrency is not enabled (it is not allowed to perform concurrent operations on radix tree).</p>
<p>An example of custom BytesView implementation: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>custom_key {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>custom_bytes_view {</div>
<div class="line">    custom_bytes_view(<span class="keyword">const</span> custom_key *k)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> *x = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(&amp;k-&gt;x);</div>
<div class="line">        <span class="keyword">auto</span> *y = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(&amp;k-&gt;y);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)</div>
<div class="line">            bytes[i] = x[<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) - i - 1];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)</div>
<div class="line">            bytes[i + 4] = y[<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) - i - 1];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Note that this function MUST be marked as const */</span></div>
<div class="line">    <span class="keywordtype">char</span> operator[](<span class="keywordtype">size_t</span> pos)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> bytes[pos];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Note that this function MUST be marked as const */</span></div>
<div class="line">    <span class="keywordtype">size_t</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5dc76a8444bd401b32ec64b3e55de57c">size</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(custom_key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span> bytes[<span class="keyword">sizeof</span>(custom_key)];</div>
<div class="line">};</div>
</div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af6b9d3b178a7c3ca9c355cfa1965e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b9d3b178a7c3ca9c355cfa1965e09c">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default radix tree constructor. </p>
<p>Constructs an empty container. </p><dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a645bcd671af0f7a5f93129fb53f0e866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645bcd671af0f7a5f93129fb53f0e866">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>If multiple elements in the range have keys that compare equivalent, the first element is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator of inserted range.</td></tr>
  </table>
  </dd>
</dl>
<p>InputIt must meet the requirements of LegacyInputIterator.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for inserted elements in transaction failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0051c29a315d79e8f8db74b7dec4dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0051c29a315d79e8f8db74b7dec4dad">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>reference to the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html" title="Radix tree is an associative, ordered container.">radix_tree</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af84aff431de32f17fd769e4435a676bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84aff431de32f17fd769e4435a676bb">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a710ad84a2a88f32824bbe3892de1bede" title="Checks whether the container is empty.">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>rvalue reference to the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html" title="Radix tree is an associative, ordered container.">radix_tree</a> to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26da05083c9407fd0639bc612ffeee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26da05083c9407fd0639bc612ffeee53">&#9670;&nbsp;</a></span>radix_tree() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5678d368ade5e9ffa6cb64fdd75340c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5678d368ade5e9ffa6cb64fdd75340c9">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6b5aad5a40f48d6098690a21ca239e1b" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="ae6c82e23114a473ac66b4252e0fa746a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c82e23114a473ac66b4252e0fa746a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6b5aad5a40f48d6098690a21ca239e1b" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the first element. </dd></dl>

</div>
</div>
<a id="a3ef58c58c4c53e5ac8e57471833b82c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef58c58c4c53e5ac8e57471833b82c2">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element of the container. </p>
<p>If the map is empty, the returned iterator will be equal to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6b5aad5a40f48d6098690a21ca239e1b" title="Returns an iterator to the element following the last element of the map.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the first element. </dd></dl>

</div>
</div>
<a id="ad30a63a6cd496383a1051dffc063ce4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a63a6cd496383a1051dffc063ce4e">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a1c6317bcfafc829713adbad736690e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6317bcfafc829713adbad736690e09">&#9670;&nbsp;</a></span>check_pmem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::check_pmem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if radix tree resides on pmem and throws an exception if not.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>if radix tree doesn't reside on pmem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a689d9cbfd508d37796d6096a4aceedc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689d9cbfd508d37796d6096a4aceedc1">&#9670;&nbsp;</a></span>check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::check_tx_stage_work</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if current transaction stage is equal to TX_STAGE_WORK and throws an exception otherwise.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__scope__error.html" title="Custom transaction error class.">pmem::transaction_scope_error</a></td><td>if current transaction stage is not equal to TX_STAGE_WORK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab538c01a4c0e669fcc77eeb03c505d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab538c01a4c0e669fcc77eeb03c505d2c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all elements from the container transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a5dc76a8444bd401b32ec64b3e55de57c">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d69c77963d3f6c0581f4f205ae94da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d69c77963d3f6c0581f4f205ae94da2">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to the specified argument. </dd></dl>

</div>
</div>
<a id="af619540544e8c905a41d90f96265ccff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af619540544e8c905a41d90f96265ccff">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that compares equivalent to the specified argument. </dd></dl>

</div>
</div>
<a id="a5a02f4d02ac75aa37377b94e11997802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a02f4d02ac75aa37377b94e11997802">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const, reverse iterator to the beginning. </p>
<p>Using reverse iterators in concurrent environment is not safe.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a1c8e3c12490178ec19f47d95904b68f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8e3c12490178ec19f47d95904b68f1">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const, reverse iterator to the end. </p>
<p>Using reverse iterators in concurrent environment is not safe.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="ab0f39db2af971c8e68200c0f0ae6804c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f39db2af971c8e68200c0f0ae6804c">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. </p>
<p>Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair&lt;const Key, T&gt;) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward&lt;Args&gt;(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710ad84a2a88f32824bbe3892de1bede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710ad84a2a88f32824bbe3892de1bede">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a6b5aad5a40f48d6098690a21ca239e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5aad5a40f48d6098690a21ca239e1b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a51cbf80475d11b54aaac97b43b0f3c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cbf80475d11b54aaac97b43b0f3c54">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the element following the last element of the map. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>const iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a81481efd41bc044e9a1c9549753bef71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81481efd41bc044e9a1c9549753bef71">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac9cf9d85d3c1f452d0ac4b294545a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9cf9d85d3c1f452d0ac4b294545a7e">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8bb8cffb2e40c24ae9472d509c5a644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bb8cffb2e40c24ae9472d509c5a644">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the elements in the range [first; last), which must be a valid range in *this. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator in the range of elements to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator in the range of elements to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a911144b704aa36422895e0f760db9487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911144b704aa36422895e0f760db9487">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element at pos from the container. </p>
<p>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a6b5aad5a40f48d6098690a21ca239e1b" title="Returns an iterator to the element following the last element of the map.">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the element to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the removed element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e5ea4d707eae61f548053be7d843353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5ea4d707eae61f548053be7d843353">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a55311147ae4c0c37ded3941ac2d2ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55311147ae4c0c37ded3941ac2d2ac19">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ac11b48a312946f29cf2461b5be54a810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11b48a312946f29cf2461b5be54a810">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a2c986ed9935d888cce483174956cdfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c986ed9935d888cce483174956cdfe2">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to an element with key equivalent to key. If no such element is found, past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ad7ae93265e2acae67088fcb570a04819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ae93265e2acae67088fcb570a04819">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes node/leaf pointed by ptr. </p>
<p>If concurrent mode is used, adds element to the garbage list. Otherwise, frees the element immediately. </p>

</div>
</div>
<a id="ac4bd8a7e23e435112ef91e541c4ade89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd8a7e23e435112ef91e541c4ade89">&#9670;&nbsp;</a></span>garbage_collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;bool Mt, typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::garbage_collect</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to collect and free some garbage produced by erase, clear, insert_or_assign or assign_val in concurrent mode (if MtMode == true). </p>
<p>It is not guaranteed that this method will free any memory. It depends on operations currently performed by other threads.</p>
<p>Garbage is not automatically collected on move/copy ctor/assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1f39d8786d3880243638f430b0dedf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f39d8786d3880243638f430b0dedf9">&#9670;&nbsp;</a></span>garbage_collect_force()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;bool Mt, typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::garbage_collect_force</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs full epochs synchronisation. </p>
<p>Transactionally collects and frees all garbage produced by erase, clear, insert_or_assign or assign_val in concurrent mode (if MtMode == true).</p>
<p>Garbage is not automatically collected on move/copy ctor/assignment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82b60230ccd208ea193a54dc885a69bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b60230ccd208ea193a54dc885a69bf">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts element if the tree doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f029cd2957aedd0aa847a282d94858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f029cd2957aedd0aa847a282d94858">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator of inserted range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator of inserted range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b5ba88b73852255bb661a81af7c421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b5ba88b73852255bb661a81af7c421">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts element if the tree doesn't already contain an element with an equivalent key. </p>
<p>This overload is equivalent to emplace(std::forward&lt;P&gt;(value)) and only participates in overload resolution if std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value == true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f45748545d7206712d0e004ca76e753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f45748545d7206712d0e004ca76e753">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from initializer list il. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>initializer list to insert the values from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad033295bae5a09c1dbcee4f0a4c4ea9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad033295bae5a09c1dbcee4f0a4c4ea9b">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts element using move semantic if the tree doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>element value to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0094bddefa891a690e2e3fea137f233b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0094bddefa891a690e2e3fea137f233b">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. </p>
<p>If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, std::forward&lt;M&gt;(obj)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the value to insert or assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator,bool&gt; The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19434a322c0611d87a8a1b58521690c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19434a322c0611d87a8a1b58521690c7">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;typename M , typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. </p>
<p>If the key does not exist, inserts the new value as if by insert, constructing it from value_type(std::forward&lt;K&gt;(k), std::forward&lt;M&gt;(obj)).</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the value to insert or assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator,bool&gt; The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd62e8fec402b5e100ed8cd3d270f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd62e8fec402b5e100ed8cd3d270f9e">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, assigns std::forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. </p>
<p>If the key does not exist, inserts the new value as if by insert, constructing it from value_type(std::move(k), std::forward&lt;M&gt;(obj))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the value to insert or assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator,bool&gt; The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b5c58c06e0247a7d290d0806aa8011f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5c58c06e0247a7d290d0806aa8011f">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ae6f2e2ccbaf694abb1e958b1a45e5295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f2e2ccbaf694abb1e958b1a45e5295">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="aa2b34803d4d846ab9cfe83622d160579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b34803d4d846ab9cfe83622d160579">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a0ff0b7b64e9c1a64c56883055c202bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff0b7b64e9c1a64c56883055c202bff">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a81743c7f071ac58c47dd4d8f41255234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81743c7f071ac58c47dd4d8f41255234">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold </dd></dl>

</div>
</div>
<a id="acc07a93cf85b8df75a15b1b20abefde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc07a93cf85b8df75a15b1b20abefde3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of other transactionally.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor's exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30b9368cc06963f58afe936f70d46c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b9368cc06963f58afe936f70d46c57">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container) transactionally. Other is in a valid but empty state afterwards.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cdf7ae4492dfffc43983fe599adb911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf7ae4492dfffc43983fe599adb911">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list to use as data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a909dd4e599193a94bdd03c1c30254ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909dd4e599193a94bdd03c1c30254ed9">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p>Using reverse iterators in concurrent environment is not safe.</p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a9861008e30d654c81af8276216dc2314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9861008e30d654c81af8276216dc2314">&#9670;&nbsp;</a></span>register_worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;bool Mt, typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::worker_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::register_worker</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers and returns a new worker, which can perform critical operations (accessing some shared data that can be removed in other threads). </p>
<p>There can be only one worker per thread. The worker will be automatically unregistered in the destructor.</p>
<dl class="section return"><dt>Returns</dt><dd>new registered worker. </dd></dl>

</div>
</div>
<a id="a45c98bb49bccfe5827b8fa4ba3c11b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c98bb49bccfe5827b8fa4ba3c11b17">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<p>Using reverse iterators in concurrent environment is not safe.</p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a6f9f9f7d0de453b47651a789cbd8ce31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9f9f7d0de453b47651a789cbd8ce31">&#9670;&nbsp;</a></span>runtime_initialize_mt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;bool Mt, typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::runtime_initialize_mt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1detail_1_1ebr.html">ebr</a> *&#160;</td>
          <td class="paramname"><em>e</em> = <code>new&#160;<a class="el" href="classpmem_1_1detail_1_1ebr.html">ebr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If MtMode == true, this function must be called after each application restart. </p>
<p>It is necessary to call <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html#a4176931890eb262d3d95f08d513d2c3f" title="If MtMode == true, this function must be called before each application close and before calling radi...">runtime_finalize_mt()</a> before closing the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to already created ebr, default it will be created automatically. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dc76a8444bd401b32ec64b3e55de57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc76a8444bd401b32ec64b3e55de57c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<a id="a48fb001c8541de8503662b912a08aa52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fb001c8541de8503662b912a08aa52">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Member swap. </p>
<p>Exchanges *this with</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f6571eed2800b0e0d84b2b3d3ab0fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6571eed2800b0e0d84b2b3d3ab0fcc">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</p>
<p>Unlike insert or emplace, this method do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types. In addition, try_emplace treats the key and the arguments to the mapped_type separately, unlike emplace, which requires the arguments to construct a value_type (that is, a std::pair).</p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca76d02d7df1ddaf38682b5916f2a84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca76d02d7df1ddaf38682b5916f2a84d">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename BV , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;
		detail::has_is_transparent&lt;BV&gt;::value &amp;&amp;
			!std::is_same&lt;typename std::remove_const&lt;
					      typename std::remove_reference&lt;
						      K&gt;::type&gt;::type,
				      key_type&gt;::value,
		std::pair&lt;<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(std::forward&lt;K&gt;(k)), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)).</p>
<p>Unlike insert or emplace, this method do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types. In addition, try_emplace treats the key and the arguments to the mapped_type separately, unlike emplace, which requires the arguments to construct a value_type (that is, a std::pair).</p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea96deed6034e7a9dea018ea2d26c3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea96deed6034e7a9dea018ea2d26c3ab">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView  = bytes_view&lt;Key&gt;, bool MtMode = false&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt;Key, Value, BytesView, MtMode&gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">key_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a key equivalent to k already exists in the container, does nothing. </p>
<p>Otherwise, behaves like emplace except that the element is constructed as value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)).</p>
<p>Unlike insert or emplace, this method do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types. In addition, try_emplace treats the key and the arguments to the mapped_type separately, unlike emplace, which requires the arguments to construct a value_type (that is, a std::pair).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ea4c2141f60212a4035e98a9a8e583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea4c2141f60212a4035e98a9a8e583b">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a639d6c37a4c9f9326c4098e2d8c2ea86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639d6c37a4c9f9326c4098e2d8c2ea86">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<p>This overload only participates in overload resolution if BytesView struct has a type member named is_transparent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="acf74a83bceb322b1d46c7ae1804a26fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf74a83bceb322b1d46c7ae1804a26fd">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a8215dc46b7ddc54d3465f99b1ce9dd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8215dc46b7ddc54d3465f99b1ce9dd93">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1radix__tree_1_1radix__tree__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>key value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is greater than key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="ab9ed80ba899b91aa162217269ee9579b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ed80ba899b91aa162217269ee9579b">&#9670;&nbsp;</a></span>validate_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename BytesView , bool MtMode&gt; </div>
<div class="memtemplate">
template&lt;bool Mt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!Mt, bool &gt;::type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1radix__tree.html">pmem::obj::experimental::radix_tree</a>&lt; Key, Value, BytesView, MtMode &gt;::validate_path </td>
          <td>(</td>
          <td class="paramtype">const path_type &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any node in the. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>was modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="radix__tree_8hpp_source.html">radix_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
