<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::self_relative_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.13.0-git15.g1f61bcf2</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj.html">obj</a></li><li class="navelem"><a class="el" href="namespacepmem_1_1obj_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::self_relative_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent self-relative pointer class.  
 <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="self__relative__ptr_8hpp_source.html">libpmemobj++/experimental/self_relative_ptr.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pmem::obj::experimental::self_relative_ptr&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.png" usemap="#pmem::obj::experimental::self_5Frelative_5Fptr_3C_20T_20_3E_map" alt=""/>
  <map id="pmem::obj::experimental::self_5Frelative_5Fptr_3C_20T_20_3E_map" name="pmem::obj::experimental::self_5Frelative_5Fptr_3C_20T_20_3E_map">
<area href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html" title="self_relative_ptr base template class" alt="pmem::detail::self_relative_ptr_base_impl&lt; OffsetType &gt;" shape="rect" coords="0,0,326,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad59315a07c5d3bfd6a761ac17007b23a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">iterator_category</a> = std::random_access_iterator_tag</td></tr>
<tr class="memdesc:ad59315a07c5d3bfd6a761ac17007b23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator requirements (members)  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">More...</a><br /></td></tr>
<tr class="separator:ad59315a07c5d3bfd6a761ac17007b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51ab4e13db7e2fb4e9ffae1cc49ca78"><td class="memItemLeft" align="right" valign="top"><a id="ac51ab4e13db7e2fb4e9ffae1cc49ca78"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a> = typename base_type::difference_type</td></tr>
<tr class="memdesc:ac51ab4e13db7e2fb4e9ffae1cc49ca78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> difference type. <br /></td></tr>
<tr class="separator:ac51ab4e13db7e2fb4e9ffae1cc49ca78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd724ab1b48eea1fdf7ca077e10078"><td class="memItemLeft" align="right" valign="top"><a id="a48dd724ab1b48eea1fdf7ca077e10078"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a48dd724ab1b48eea1fdf7ca077e10078">value_type</a> = T</td></tr>
<tr class="memdesc:a48dd724ab1b48eea1fdf7ca077e10078"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a>. <br /></td></tr>
<tr class="separator:a48dd724ab1b48eea1fdf7ca077e10078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e38c1e94f1f6e44e06fa69361b8902"><td class="memItemLeft" align="right" valign="top"><a id="a14e38c1e94f1f6e44e06fa69361b8902"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a14e38c1e94f1f6e44e06fa69361b8902">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a14e38c1e94f1f6e44e06fa69361b8902"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a>. <br /></td></tr>
<tr class="separator:a14e38c1e94f1f6e44e06fa69361b8902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="memItemLeft" align="right" valign="top"><a id="ac76f6b18f3ff9361c1c71227e5bf2234"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac76f6b18f3ff9361c1c71227e5bf2234">self_relative_ptr</a> () noexcept=default</td></tr>
<tr class="memdesc:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, equal the nullptr. <br /></td></tr>
<tr class="separator:ac76f6b18f3ff9361c1c71227e5bf2234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56034ec07863366fd5354b28e9a18a"><td class="memItemLeft" align="right" valign="top"><a id="acd56034ec07863366fd5354b28e9a18a"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd56034ec07863366fd5354b28e9a18a">self_relative_ptr</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:acd56034ec07863366fd5354b28e9a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr constructor. <br /></td></tr>
<tr class="separator:acd56034ec07863366fd5354b28e9a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0b186cde38f990d3b7c1a9fd7f68c793">self_relative_ptr</a> (element_type *ptr) noexcept</td></tr>
<tr class="memdesc:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile pointer constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0b186cde38f990d3b7c1a9fd7f68c793">More...</a><br /></td></tr>
<tr class="separator:a0b186cde38f990d3b7c1a9fd7f68c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a00f5397ca70925714e517ef7e5cc66"><td class="memItemLeft" align="right" valign="top"><a id="a4a00f5397ca70925714e517ef7e5cc66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4a00f5397ca70925714e517ef7e5cc66">self_relative_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; ptr) noexcept</td></tr>
<tr class="memdesc:a4a00f5397ca70925714e517ef7e5cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from persistent_ptr&lt;T&gt; <br /></td></tr>
<tr class="separator:a4a00f5397ca70925714e517ef7e5cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6b76812c31a4b81859d25846add4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4ad6b76812c31a4b81859d25846add4b">self_relative_ptr</a> (PMEMoid oid) noexcept</td></tr>
<tr class="memdesc:a4ad6b76812c31a4b81859d25846add4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMEMoid constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a4ad6b76812c31a4b81859d25846add4b">More...</a><br /></td></tr>
<tr class="separator:a4ad6b76812c31a4b81859d25846add4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="memItemLeft" align="right" valign="top"><a id="abe947cc99e3e59a738bfa4f3a624fcd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#abe947cc99e3e59a738bfa4f3a624fcd9">self_relative_ptr</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;ptr) noexcept</td></tr>
<tr class="memdesc:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:abe947cc99e3e59a738bfa4f3a624fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </td></tr>
<tr class="memitem:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586">self_relative_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; U &gt; const &amp;r) noexcept</td></tr>
<tr class="memdesc:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a different self_relative_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586">More...</a><br /></td></tr>
<tr class="separator:ac5be3c4ecb9a967cb30425fb3ed54586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c550851f90b7139e588445913fdfb48"><td class="memItemLeft" align="right" valign="top">element_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a9c550851f90b7139e588445913fdfb48">get</a> () const noexcept</td></tr>
<tr class="memdesc:a9c550851f90b7139e588445913fdfb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direct pointer.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a9c550851f90b7139e588445913fdfb48">More...</a><br /></td></tr>
<tr class="separator:a9c550851f90b7139e588445913fdfb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="memItemLeft" align="right" valign="top"><a id="a7cd65672ed7c3bca1cb5eba00f0f89b2"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7cd65672ed7c3bca1cb5eba00f0f89b2">to_persistent_ptr</a> () const</td></tr>
<tr class="memdesc:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to persitent ptr. <br /></td></tr>
<tr class="separator:a7cd65672ed7c3bca1cb5eba00f0f89b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="memItemLeft" align="right" valign="top"><a id="ae55b818d5a1bebba2cec1c14b5b03c4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ae55b818d5a1bebba2cec1c14b5b03c4d">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bool conversion operator. <br /></td></tr>
<tr class="separator:ae55b818d5a1bebba2cec1c14b5b03c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdc2ba22f7b28676888f087f82ae20"><td class="memItemLeft" align="right" valign="top"><a id="a2ecdc2ba22f7b28676888f087f82ae20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2ecdc2ba22f7b28676888f087f82ae20">operator persistent_ptr&lt; T &gt;</a> () const</td></tr>
<tr class="memdesc:a2ecdc2ba22f7b28676888f087f82ae20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:a2ecdc2ba22f7b28676888f087f82ae20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="memItemLeft" align="right" valign="top"><a id="a0988ed48e3632d8c2483d10f94e5b4c7"></a>
pmem::detail::sp_dereference&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a0988ed48e3632d8c2483d10f94e5b4c7">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator. <br /></td></tr>
<tr class="separator:a0988ed48e3632d8c2483d10f94e5b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ceb1160a93cf67b2d80ab329757ac"><td class="memItemLeft" align="right" valign="top"><a id="ac52ceb1160a93cf67b2d80ab329757ac"></a>
pmem::detail::sp_member_access&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac52ceb1160a93cf67b2d80ab329757ac">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:ac52ceb1160a93cf67b2d80ab329757ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator. <br /></td></tr>
<tr class="separator:ac52ceb1160a93cf67b2d80ab329757ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb880992038e280590f619cbe8b041"><td class="memTemplParams" colspan="2">template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a95fb880992038e280590f619cbe8b041"><td class="memTemplItemLeft" align="right" valign="top">pmem::detail::sp_array_access&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a95fb880992038e280590f619cbe8b041">operator[]</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a> i) const noexcept</td></tr>
<tr class="memdesc:a95fb880992038e280590f619cbe8b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array access operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a95fb880992038e280590f619cbe8b041">More...</a><br /></td></tr>
<tr class="separator:a95fb880992038e280590f619cbe8b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2283fb5e5ba26aa3a7443a353d062f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2283fb5e5ba26aa3a7443a353d062f49">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;r)</td></tr>
<tr class="memdesc:a2283fb5e5ba26aa3a7443a353d062f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a2283fb5e5ba26aa3a7443a353d062f49">More...</a><br /></td></tr>
<tr class="separator:a2283fb5e5ba26aa3a7443a353d062f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70042cf9bf7619af8f9f48409e34cf26"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a70042cf9bf7619af8f9f48409e34cf26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;r)</td></tr>
<tr class="memdesc:a70042cf9bf7619af8f9f48409e34cf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting assignment operator from a different self_relative_ptr&lt;&gt;.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26">More...</a><br /></td></tr>
<tr class="separator:a70042cf9bf7619af8f9f48409e34cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd01402f0ef7b1c9197aede9a9fa1a1c">operator=</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr move assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#acd01402f0ef7b1c9197aede9a9fa1a1c">More...</a><br /></td></tr>
<tr class="separator:acd01402f0ef7b1c9197aede9a9fa1a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002055eb8589d7119aef75c62e652e8"><td class="memItemLeft" align="right" valign="top"><a id="a6002055eb8589d7119aef75c62e652e8"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a6002055eb8589d7119aef75c62e652e8">operator++</a> ()</td></tr>
<tr class="memdesc:a6002055eb8589d7119aef75c62e652e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator. <br /></td></tr>
<tr class="separator:a6002055eb8589d7119aef75c62e652e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019147ec67e67e2d0f9844e3356bd549"><td class="memItemLeft" align="right" valign="top"><a id="a019147ec67e67e2d0f9844e3356bd549"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a019147ec67e67e2d0f9844e3356bd549">operator++</a> (int)</td></tr>
<tr class="memdesc:a019147ec67e67e2d0f9844e3356bd549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator. <br /></td></tr>
<tr class="separator:a019147ec67e67e2d0f9844e3356bd549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94e965b7ac0482e796ef889f5222d0"><td class="memItemLeft" align="right" valign="top"><a id="a5b94e965b7ac0482e796ef889f5222d0"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a5b94e965b7ac0482e796ef889f5222d0">operator--</a> ()</td></tr>
<tr class="memdesc:a5b94e965b7ac0482e796ef889f5222d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator. <br /></td></tr>
<tr class="separator:a5b94e965b7ac0482e796ef889f5222d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38720d3605a098774d9aa448d7b70f"><td class="memItemLeft" align="right" valign="top"><a id="a7b38720d3605a098774d9aa448d7b70f"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7b38720d3605a098774d9aa448d7b70f">operator--</a> (int)</td></tr>
<tr class="memdesc:a7b38720d3605a098774d9aa448d7b70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator. <br /></td></tr>
<tr class="separator:a7b38720d3605a098774d9aa448d7b70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04705aad40b6516a6fd81823fe756f95"><td class="memItemLeft" align="right" valign="top"><a id="a04705aad40b6516a6fd81823fe756f95"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a04705aad40b6516a6fd81823fe756f95">operator+=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a04705aad40b6516a6fd81823fe756f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. <br /></td></tr>
<tr class="separator:a04705aad40b6516a6fd81823fe756f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7159febd82754998c2902084de5413a8"><td class="memItemLeft" align="right" valign="top"><a id="a7159febd82754998c2902084de5413a8"></a>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a7159febd82754998c2902084de5413a8">operator-=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a7159febd82754998c2902084de5413a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator. <br /></td></tr>
<tr class="separator:a7159febd82754998c2902084de5413a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">pmem::detail::self_relative_ptr_base_impl&lt; OffsetType &gt;</a></td></tr>
<tr class="memitem:ad713d7670532e8f872f9ff4ba022a705 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="ad713d7670532e8f872f9ff4ba022a705"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ad713d7670532e8f872f9ff4ba022a705">self_relative_ptr_base_impl</a> () noexcept</td></tr>
<tr class="memdesc:ad713d7670532e8f872f9ff4ba022a705 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, equal the nullptr. <br /></td></tr>
<tr class="separator:ad713d7670532e8f872f9ff4ba022a705 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33096da94ecd88b680ee383a26193f62 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a33096da94ecd88b680ee383a26193f62"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a33096da94ecd88b680ee383a26193f62">self_relative_ptr_base_impl</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a33096da94ecd88b680ee383a26193f62 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr constructor. <br /></td></tr>
<tr class="separator:a33096da94ecd88b680ee383a26193f62 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4281f0d1a764abed72f0462cc2c7b28 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ae4281f0d1a764abed72f0462cc2c7b28">self_relative_ptr_base_impl</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:ae4281f0d1a764abed72f0462cc2c7b28 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile pointer constructor.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ae4281f0d1a764abed72f0462cc2c7b28">More...</a><br /></td></tr>
<tr class="separator:ae4281f0d1a764abed72f0462cc2c7b28 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f1c4b769963ef75ee41280c2e64422 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a24f1c4b769963ef75ee41280c2e64422">self_relative_ptr_base_impl</a> (<a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> const &amp;r) noexcept</td></tr>
<tr class="memdesc:a24f1c4b769963ef75ee41280c2e64422 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a24f1c4b769963ef75ee41280c2e64422">More...</a><br /></td></tr>
<tr class="separator:a24f1c4b769963ef75ee41280c2e64422 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88b7315bdb33b2f1cbd322a93c2be8f inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ae88b7315bdb33b2f1cbd322a93c2be8f">operator=</a> (<a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> const &amp;r)</td></tr>
<tr class="memdesc:ae88b7315bdb33b2f1cbd322a93c2be8f inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#ae88b7315bdb33b2f1cbd322a93c2be8f">More...</a><br /></td></tr>
<tr class="separator:ae88b7315bdb33b2f1cbd322a93c2be8f inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8fcf2b408022d57de72e2bc05b488d inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#afe8fcf2b408022d57de72e2bc05b488d">operator=</a> (std::nullptr_t &amp;&amp;)</td></tr>
<tr class="memdesc:afe8fcf2b408022d57de72e2bc05b488d inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullptr move assignment operator.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#afe8fcf2b408022d57de72e2bc05b488d">More...</a><br /></td></tr>
<tr class="separator:afe8fcf2b408022d57de72e2bc05b488d inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc1dd29d634c370a0fa8ed352d7b734 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#abbc1dd29d634c370a0fa8ed352d7b734">swap</a> (<a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> &amp;other)</td></tr>
<tr class="memdesc:abbc1dd29d634c370a0fa8ed352d7b734 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two self_relative_ptr_base objects of the same type.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#abbc1dd29d634c370a0fa8ed352d7b734">More...</a><br /></td></tr>
<tr class="separator:abbc1dd29d634c370a0fa8ed352d7b734 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657ec0425124c86d3403495d3e95c486 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a657ec0425124c86d3403495d3e95c486"></a>
byte_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a657ec0425124c86d3403495d3e95c486">to_byte_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a657ec0425124c86d3403495d3e95c486 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to byte pointer. <br /></td></tr>
<tr class="separator:a657ec0425124c86d3403495d3e95c486 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54699d0bc903b2f02c892b43ac14b991 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a54699d0bc903b2f02c892b43ac14b991"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a54699d0bc903b2f02c892b43ac14b991">to_void_pointer</a> () const noexcept</td></tr>
<tr class="memdesc:a54699d0bc903b2f02c892b43ac14b991 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to void*. <br /></td></tr>
<tr class="separator:a54699d0bc903b2f02c892b43ac14b991 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e05e732319e690352d80cb7a6b6447 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a47e05e732319e690352d80cb7a6b6447"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a47e05e732319e690352d80cb7a6b6447">operator void *</a> () const noexcept</td></tr>
<tr class="memdesc:a47e05e732319e690352d80cb7a6b6447 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion operator to void*. <br /></td></tr>
<tr class="separator:a47e05e732319e690352d80cb7a6b6447 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662bad10baca6180b80069c0a1bbf5e0 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a662bad10baca6180b80069c0a1bbf5e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a662bad10baca6180b80069c0a1bbf5e0">operator byte_ptr_type</a> () const noexcept</td></tr>
<tr class="memdesc:a662bad10baca6180b80069c0a1bbf5e0 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion operator to byte pointer. <br /></td></tr>
<tr class="separator:a662bad10baca6180b80069c0a1bbf5e0 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760fdb659416dc28baa265f1930283b0 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a760fdb659416dc28baa265f1930283b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a760fdb659416dc28baa265f1930283b0">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a760fdb659416dc28baa265f1930283b0 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast null checking without conversion to void*. <br /></td></tr>
<tr class="separator:a760fdb659416dc28baa265f1930283b0 inherit pub_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a61b645d35e63b21aa63373251da3fd4d"><td class="memItemLeft" align="right" valign="top"><a id="a61b645d35e63b21aa63373251da3fd4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a61b645d35e63b21aa63373251da3fd4d">verify_type</a> ()</td></tr>
<tr class="memdesc:a61b645d35e63b21aa63373251da3fd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if element_type is not polymorphic. <br /></td></tr>
<tr class="separator:a61b645d35e63b21aa63373251da3fd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">pmem::detail::self_relative_ptr_base_impl&lt; OffsetType &gt;</a></td></tr>
<tr class="memitem:aef6c1992c17cb3017c7d6e8759fc5737 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#aef6c1992c17cb3017c7d6e8759fc5737">self_relative_ptr_base_impl</a> (difference_type offset) noexcept</td></tr>
<tr class="memdesc:aef6c1992c17cb3017c7d6e8759fc5737 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset constructor.  <a href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#aef6c1992c17cb3017c7d6e8759fc5737">More...</a><br /></td></tr>
<tr class="separator:aef6c1992c17cb3017c7d6e8759fc5737 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb5f5adce1968be8558bf21b190a823 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a5bb5f5adce1968be8558bf21b190a823"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a5bb5f5adce1968be8558bf21b190a823">offset_to_pointer</a> (difference_type other_offset) const noexcept</td></tr>
<tr class="memdesc:a5bb5f5adce1968be8558bf21b190a823 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to void* use other offset. <br /></td></tr>
<tr class="separator:a5bb5f5adce1968be8558bf21b190a823 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142914472e5c0fbe3405c62d96e4b69 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="af142914472e5c0fbe3405c62d96e4b69"></a>
difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#af142914472e5c0fbe3405c62d96e4b69">pointer_to_offset</a> (const <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> &amp;ptr) const noexcept</td></tr>
<tr class="memdesc:af142914472e5c0fbe3405c62d96e4b69 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion self_relative_ptr_base to offset from itself. <br /></td></tr>
<tr class="separator:af142914472e5c0fbe3405c62d96e4b69 inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55695b88f5b6ed57c637b5821786d3ce inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a55695b88f5b6ed57c637b5821786d3ce"></a>
difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a55695b88f5b6ed57c637b5821786d3ce">pointer_to_offset</a> (void *ptr) const noexcept</td></tr>
<tr class="memdesc:a55695b88f5b6ed57c637b5821786d3ce inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion pointer to offset. <br /></td></tr>
<tr class="separator:a55695b88f5b6ed57c637b5821786d3ce inherit pro_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">pmem::detail::self_relative_ptr_base_impl&lt; OffsetType &gt;</a></td></tr>
<tr class="memitem:a1ea6a340a0bed6771e811c9264fd8131 inherit pub_static_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memItemLeft" align="right" valign="top"><a id="a1ea6a340a0bed6771e811c9264fd8131"></a>
static difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html#a1ea6a340a0bed6771e811c9264fd8131">distance_between</a> (const <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> &amp;first, const <a class="el" href="classpmem_1_1detail_1_1self__relative__ptr__base__impl.html">self_relative_ptr_base_impl</a> &amp;second)</td></tr>
<tr class="memdesc:a1ea6a340a0bed6771e811c9264fd8131 inherit pub_static_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte distance between two relative pointers. <br /></td></tr>
<tr class="separator:a1ea6a340a0bed6771e811c9264fd8131 inherit pub_static_methods_classpmem_1_1detail_1_1self__relative__ptr__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::self_relative_ptr&lt; T &gt;</h3>

<p>Persistent self-relative pointer class. </p>
<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> implements a smart ptr. It encapsulates the self offsetted pointer and provides member access, dereference and array access operators.</p>
<p>Template parameter type has following requirements:</p><ul>
<li>Is not polymorphic</li>
<li>Has no non-static data members of reference type</li>
<li>Satisfies Destructible requirement: <a href="https://en.cppreference.com/w/cpp/named_req/Destructible">https://en.cppreference.com/w/cpp/named_req/Destructible</a></li>
<li>All non-static data members and base classes follow the same requirements</li>
</ul>
Even if all of the above requirements are met, type representation may vary depending on ABI and compiler optimizations (as stated in [class.mem]: "the order of allocation of non-static data members with different access control is unspecified"). To enforce the same layout for all ABIs and optimization levels type should satisfy StandardLayoutType requirement.If pointer is used with array type, additional requirement is:</p><ul>
<li>Element type must be default constructible</li>
</ul>
The pointer is not designed to work with polymorphic types, as they have runtime RTTI info embedded, which is implementation specific and thus not consistently rebuildable. Such constructs as polymorphic members or members of a union defined within a class held in a pointer will also yield undefined behavior.C++ standard states that lifetime of an object is a runtime property [basic.lifetime]. Conditions which must be fulfilled for object's lifetime to begin, imply that using any non-trivially constructible object with pointer is undefined behaviour. This is being partially addressed by the following proposal: <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo</a>Another caveat is that snapshotting elements in a transaction and performing rollback uses memcpy internally. Using memcpy on an object in C++ is allowed by the standard only if the type satisfies TriviallyCopyable requirement. </p>
<p>Casting to self_relative_ptr_base can be easily done from any self_relative_ptr&lt;T&gt; objects, but when casting between convertible objects be advised to use constructors or operator= specified for such conversion, see:</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac5be3c4ecb9a967cb30425fb3ed54586" title="Copy constructor from a different self_relative_ptr&lt;&gt;.">self_relative_ptr::self_relative_ptr(self_relative_ptr&lt;U&gt; const &amp;r)</a> ,</li>
<li>self_relative_ptr&lt;T&gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#a70042cf9bf7619af8f9f48409e34cf26" title="Converting assignment operator from a different self_relative_ptr&lt;&gt;.">operator=(self_relative_ptr&lt;Y&gt; const &amp;r)</a> . When casting indirectly with (void *) or using static_cast, and then casting to the second (convertible) type, the offset will be re-calculated.</li>
</ul>
<p>The current version uses an approach where we store offset=real_offset-1 and zero offset (or real_offset equal one) is a null pointer. This is needed to support zero initialization.</p><ul>
<li>real_offset = pointer - this;</li>
<li>pointer = real_offset + this;</li>
<li>or pointer = offset + this + 1; </li>
</ul>
 </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad59315a07c5d3bfd6a761ac17007b23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59315a07c5d3bfd6a761ac17007b23a">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ad59315a07c5d3bfd6a761ac17007b23a">iterator_category</a> =  std::random_access_iterator_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random access iterator requirements (members) </p>
<p>The <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html" title="Persistent self-relative pointer class.">self_relative_ptr</a> iterator category. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0b186cde38f990d3b7c1a9fd7f68c793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b186cde38f990d3b7c1a9fd7f68c793">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">element_type *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volatile pointer constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>volatile pointer, pointing to persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ad6b76812c31a4b81859d25846add4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad6b76812c31a4b81859d25846add4b">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">PMEMoid&#160;</td>
          <td class="paramname"><em>oid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PMEMoid constructor. </p>
<p>Provided for easy interoperability between C++ and C API's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>C-style persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5be3c4ecb9a967cb30425fb3ed54586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5be3c4ecb9a967cb30425fb3ed54586">&#9670;&nbsp;</a></span>self_relative_ptr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;			!std::is_same&lt;				typename std::remove_cv&lt;T&gt;::type,				typename std::remove_cv&lt;U&gt;::type&gt;::value &amp;&amp;				!std::is_void&lt;U&gt;::value,			decltype(static_cast&lt;T *&gt;(std::declval&lt;U *&gt;()))&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a different self_relative_ptr&lt;&gt;. </p>
<p>Available only for convertible, non-void types. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c550851f90b7139e588445913fdfb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c550851f90b7139e588445913fdfb48">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">element_type* <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the direct pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>the direct pointer to the object. </dd></dl>

</div>
</div>
<a id="a2283fb5e5ba26aa3a7443a353d062f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2283fb5e5ba26aa3a7443a353d062f49">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>self-relative pointer assignment within a transaction automatically registers this operation so that a rollback is possible.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70042cf9bf7619af8f9f48409e34cf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70042cf9bf7619af8f9f48409e34cf26">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename  = typename std::enable_if&lt;			  std::is_convertible&lt;Y *, T *&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt;T&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting assignment operator from a different self_relative_ptr&lt;&gt;. </p>
<p>Available only for convertible types. Just like regular assignment, also automatically registers itself in a transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd01402f0ef7b1c9197aede9a9fa1a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01402f0ef7b1c9197aede9a9fa1a1c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">self_relative_ptr</a>&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullptr move assignment operator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95fb880992038e280590f619cbe8b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fb880992038e280590f619cbe8b041">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::detail::sp_array_access&lt;T&gt;::type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html">pmem::obj::experimental::self_relative_ptr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1self__relative__ptr.html#ac51ab4e13db7e2fb4e9ffae1cc49ca78">difference_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array access operator. </p>
<p>Contains run-time bounds checking for static arrays. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="self__relative__ptr_8hpp_source.html">self_relative_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
