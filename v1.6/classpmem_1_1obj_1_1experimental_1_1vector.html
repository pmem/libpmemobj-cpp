<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface.  
 <a href="classpmem_1_1obj_1_1experimental_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">libpmemobj++/experimental/vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a636c3f33b0647feb03e1caf9aece8ab2">vector</a> ()</td></tr>
<tr class="memdesc:a636c3f33b0647feb03e1caf9aece8ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a636c3f33b0647feb03e1caf9aece8ab2">More...</a><br /></td></tr>
<tr class="separator:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77628ae4d95b0e93037541f104ec86b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a77628ae4d95b0e93037541f104ec86b3">vector</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a77628ae4d95b0e93037541f104ec86b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="#a77628ae4d95b0e93037541f104ec86b3">More...</a><br /></td></tr>
<tr class="separator:a77628ae4d95b0e93037541f104ec86b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b0a598e44399198a1f05ee732e576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a486b0a598e44399198a1f05ee732e576">vector</a> (size_type count)</td></tr>
<tr class="memdesc:a486b0a598e44399198a1f05ee732e576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of T default constructed values.  <a href="#a486b0a598e44399198a1f05ee732e576">More...</a><br /></td></tr>
<tr class="separator:a486b0a598e44399198a1f05ee732e576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f6b898490147e4c6e620785d5194aa">vector</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ae1f6b898490147e4c6e620785d5194aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="#ae1f6b898490147e4c6e620785d5194aa">More...</a><br /></td></tr>
<tr class="separator:ae1f6b898490147e4c6e620785d5194aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1167a0629de37532aa57f39da47fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9b1167a0629de37532aa57f39da47fa9">vector</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a9b1167a0629de37532aa57f39da47fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9b1167a0629de37532aa57f39da47fa9">More...</a><br /></td></tr>
<tr class="separator:a9b1167a0629de37532aa57f39da47fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa503ab924495ac60140b9852ce7d52b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa503ab924495ac60140b9852ce7d52b0">vector</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa503ab924495ac60140b9852ce7d52b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aa503ab924495ac60140b9852ce7d52b0">More...</a><br /></td></tr>
<tr class="separator:aa503ab924495ac60140b9852ce7d52b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88f2db2da445af0fab25559262c636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7a88f2db2da445af0fab25559262c636">vector</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a7a88f2db2da445af0fab25559262c636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="#a7a88f2db2da445af0fab25559262c636">More...</a><br /></td></tr>
<tr class="separator:a7a88f2db2da445af0fab25559262c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a001086850b80531195cef02a20cac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a78a001086850b80531195cef02a20cac">vector</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a78a001086850b80531195cef02a20cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a78a001086850b80531195cef02a20cac">More...</a><br /></td></tr>
<tr class="separator:a78a001086850b80531195cef02a20cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acfe524ba035d4b199bd0288d3cfb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4acfe524ba035d4b199bd0288d3cfb71">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a4acfe524ba035d4b199bd0288d3cfb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a4acfe524ba035d4b199bd0288d3cfb71">More...</a><br /></td></tr>
<tr class="separator:a4acfe524ba035d4b199bd0288d3cfb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526939a78495ea025ed50ca87b918084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a526939a78495ea025ed50ca87b918084">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a526939a78495ea025ed50ca87b918084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a526939a78495ea025ed50ca87b918084">More...</a><br /></td></tr>
<tr class="separator:a526939a78495ea025ed50ca87b918084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5e5acfa00251ae623a27859ddb2de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#adb5e5acfa00251ae623a27859ddb2de3">operator=</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:adb5e5acfa00251ae623a27859ddb2de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist transactionally.  <a href="#adb5e5acfa00251ae623a27859ddb2de3">More...</a><br /></td></tr>
<tr class="separator:adb5e5acfa00251ae623a27859ddb2de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac250db331475486029225fb5ffda95b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac250db331475486029225fb5ffda95b9">operator=</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ac250db331475486029225fb5ffda95b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ac250db331475486029225fb5ffda95b9">More...</a><br /></td></tr>
<tr class="separator:ac250db331475486029225fb5ffda95b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7851ebcbb853614a9cfbc1a46cca04"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a7851ebcbb853614a9cfbc1a46cca04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2a7851ebcbb853614a9cfbc1a46cca04">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a2a7851ebcbb853614a9cfbc1a46cca04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last) transactionally.  <a href="#a2a7851ebcbb853614a9cfbc1a46cca04">More...</a><br /></td></tr>
<tr class="separator:a2a7851ebcbb853614a9cfbc1a46cca04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bfbabccc7470173742b166cf81daf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a59bfbabccc7470173742b166cf81daf3">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a59bfbabccc7470173742b166cf81daf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist transactionally.  <a href="#a59bfbabccc7470173742b166cf81daf3">More...</a><br /></td></tr>
<tr class="separator:a59bfbabccc7470173742b166cf81daf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfa502cfe61a810ca2840c50a460ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#afbfa502cfe61a810ca2840c50a460ccf">assign</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:afbfa502cfe61a810ca2840c50a460ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment method.  <a href="#afbfa502cfe61a810ca2840c50a460ccf">More...</a><br /></td></tr>
<tr class="separator:afbfa502cfe61a810ca2840c50a460ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae605ad1bc7d276cd45a164a487526f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae605ad1bc7d276cd45a164a487526f56">assign</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ae605ad1bc7d276cd45a164a487526f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment method.  <a href="#ae605ad1bc7d276cd45a164a487526f56">More...</a><br /></td></tr>
<tr class="separator:ae605ad1bc7d276cd45a164a487526f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b3074c3819a373be5d02d4d294f07c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa7b3074c3819a373be5d02d4d294f07c">assign</a> (const std::vector&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aa7b3074c3819a373be5d02d4d294f07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment method.  <a href="#aa7b3074c3819a373be5d02d4d294f07c">More...</a><br /></td></tr>
<tr class="separator:aa7b3074c3819a373be5d02d4d294f07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a395a49f38bcde6c2164405fc9bb2c35a">~vector</a> ()</td></tr>
<tr class="memdesc:a395a49f38bcde6c2164405fc9bb2c35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a395a49f38bcde6c2164405fc9bb2c35a">More...</a><br /></td></tr>
<tr class="separator:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7b1f1a08b1d34f9874c1d56dce9c8ec8">at</a> (size_type n)</td></tr>
<tr class="memdesc:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking and add it to a transaction.  <a href="#a7b1f1a08b1d34f9874c1d56dce9c8ec8">More...</a><br /></td></tr>
<tr class="separator:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db43b38bad316d12f51319fcdb2054"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a83db43b38bad316d12f51319fcdb2054">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a83db43b38bad316d12f51319fcdb2054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a83db43b38bad316d12f51319fcdb2054">More...</a><br /></td></tr>
<tr class="separator:a83db43b38bad316d12f51319fcdb2054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fc08c07d12cdacc4426285962f0c21"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:a38fc08c07d12cdacc4426285962f0c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a38fc08c07d12cdacc4426285962f0c21">More...</a><br /></td></tr>
<tr class="separator:a38fc08c07d12cdacc4426285962f0c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a57b4e5d1c66f006ad7f87f9573f3c6bc">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">More...</a><br /></td></tr>
<tr class="separator:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0ffcc2e74974015ed9741b1430227"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f0ffcc2e74974015ed9741b1430227">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ae1f0ffcc2e74974015ed9741b1430227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#ae1f0ffcc2e74974015ed9741b1430227">More...</a><br /></td></tr>
<tr class="separator:ae1f0ffcc2e74974015ed9741b1430227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ea56dd1be6b3e5d0427a62327b81e5">front</a> ()</td></tr>
<tr class="memdesc:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element and add this element to a transaction.  <a href="#ae5ea56dd1be6b3e5d0427a62327b81e5">More...</a><br /></td></tr>
<tr class="separator:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674fdb0401fd0f7396675035d1d8e72a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a674fdb0401fd0f7396675035d1d8e72a">front</a> () const</td></tr>
<tr class="memdesc:a674fdb0401fd0f7396675035d1d8e72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#a674fdb0401fd0f7396675035d1d8e72a">More...</a><br /></td></tr>
<tr class="separator:a674fdb0401fd0f7396675035d1d8e72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb83c8e3bda44858a6923319e880e6"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6">cfront</a> () const</td></tr>
<tr class="memdesc:abbfb83c8e3bda44858a6923319e880e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#abbfb83c8e3bda44858a6923319e880e6">More...</a><br /></td></tr>
<tr class="separator:abbfb83c8e3bda44858a6923319e880e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0014916c3340dfafdcba429a3afd4a"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a">back</a> ()</td></tr>
<tr class="memdesc:a4c0014916c3340dfafdcba429a3afd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element and add this element to a transaction.  <a href="#a4c0014916c3340dfafdcba429a3afd4a">More...</a><br /></td></tr>
<tr class="separator:a4c0014916c3340dfafdcba429a3afd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dc2516566c13ec6713c624cdfd2c21"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a01dc2516566c13ec6713c624cdfd2c21">back</a> () const</td></tr>
<tr class="memdesc:a01dc2516566c13ec6713c624cdfd2c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#a01dc2516566c13ec6713c624cdfd2c21">More...</a><br /></td></tr>
<tr class="separator:a01dc2516566c13ec6713c624cdfd2c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19e208064355c8176eeffa1c832cdd5"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5">cback</a> () const</td></tr>
<tr class="memdesc:af19e208064355c8176eeffa1c832cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#af19e208064355c8176eeffa1c832cdd5">More...</a><br /></td></tr>
<tr class="separator:af19e208064355c8176eeffa1c832cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10579fdbcf3a682355025954d4ba665f"><td class="memItemLeft" align="right" valign="top">value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f">data</a> ()</td></tr>
<tr class="memdesc:a10579fdbcf3a682355025954d4ba665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw pointer to the underlying data and adds entire array to a transaction.  <a href="#a10579fdbcf3a682355025954d4ba665f">More...</a><br /></td></tr>
<tr class="separator:a10579fdbcf3a682355025954d4ba665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9561c662b97f84da5e47e0f767f9bde"><td class="memItemLeft" align="right" valign="top">const value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad9561c662b97f84da5e47e0f767f9bde">data</a> () const noexcept</td></tr>
<tr class="memdesc:ad9561c662b97f84da5e47e0f767f9bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data.  <a href="#ad9561c662b97f84da5e47e0f767f9bde">More...</a><br /></td></tr>
<tr class="separator:ad9561c662b97f84da5e47e0f767f9bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3543940ea0b583b71e96ec3a89c68a"><td class="memItemLeft" align="right" valign="top">const value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a">cdata</a> () const noexcept</td></tr>
<tr class="memdesc:a8a3543940ea0b583b71e96ec3a89c68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data.  <a href="#a8a3543940ea0b583b71e96ec3a89c68a">More...</a><br /></td></tr>
<tr class="separator:a8a3543940ea0b583b71e96ec3a89c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab88d348f9aec780a683e0572b60be83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83">begin</a> ()</td></tr>
<tr class="memdesc:aab88d348f9aec780a683e0572b60be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#aab88d348f9aec780a683e0572b60be83">More...</a><br /></td></tr>
<tr class="separator:aab88d348f9aec780a683e0572b60be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb307d36ab9098655ba1a1166d37444"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a3cb307d36ab9098655ba1a1166d37444">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a3cb307d36ab9098655ba1a1166d37444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#a3cb307d36ab9098655ba1a1166d37444">More...</a><br /></td></tr>
<tr class="separator:a3cb307d36ab9098655ba1a1166d37444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae52abd4d3c066bf755b78f4b781c1d8"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aae52abd4d3c066bf755b78f4b781c1d8">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aae52abd4d3c066bf755b78f4b781c1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#aae52abd4d3c066bf755b78f4b781c1d8">More...</a><br /></td></tr>
<tr class="separator:aae52abd4d3c066bf755b78f4b781c1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d32b0060badd059f0ac41eb73bf54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54">end</a> ()</td></tr>
<tr class="memdesc:aac5d32b0060badd059f0ac41eb73bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to past the end.  <a href="#aac5d32b0060badd059f0ac41eb73bf54">More...</a><br /></td></tr>
<tr class="separator:aac5d32b0060badd059f0ac41eb73bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289592fadece20471f1588c0a1bddb3"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa289592fadece20471f1588c0a1bddb3">end</a> () const noexcept</td></tr>
<tr class="memdesc:aa289592fadece20471f1588c0a1bddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to past the end.  <a href="#aa289592fadece20471f1588c0a1bddb3">More...</a><br /></td></tr>
<tr class="separator:aa289592fadece20471f1588c0a1bddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac1f050f7fabb39ec5918fbc1fb3604ba">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end.  <a href="#ac1f050f7fabb39ec5918fbc1fb3604ba">More...</a><br /></td></tr>
<tr class="separator:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec3d65c0203596140b72b21581c795"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abdec3d65c0203596140b72b21581c795">rbegin</a> ()</td></tr>
<tr class="memdesc:abdec3d65c0203596140b72b21581c795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#abdec3d65c0203596140b72b21581c795">More...</a><br /></td></tr>
<tr class="separator:abdec3d65c0203596140b72b21581c795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2904e853e49b5abf858e08199fe3a361"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2904e853e49b5abf858e08199fe3a361">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a2904e853e49b5abf858e08199fe3a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a2904e853e49b5abf858e08199fe3a361">More...</a><br /></td></tr>
<tr class="separator:a2904e853e49b5abf858e08199fe3a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767248672d1dde6231a2edf45e4edad"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a0767248672d1dde6231a2edf45e4edad">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0767248672d1dde6231a2edf45e4edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a0767248672d1dde6231a2edf45e4edad">More...</a><br /></td></tr>
<tr class="separator:a0767248672d1dde6231a2edf45e4edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b79d6c2a9f83b2b786a7a38951431"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a301b79d6c2a9f83b2b786a7a38951431">rend</a> ()</td></tr>
<tr class="memdesc:a301b79d6c2a9f83b2b786a7a38951431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#a301b79d6c2a9f83b2b786a7a38951431">More...</a><br /></td></tr>
<tr class="separator:a301b79d6c2a9f83b2b786a7a38951431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad8102a1af5ef750fc2da054a6cfb3f1b">rend</a> () const noexcept</td></tr>
<tr class="memdesc:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end.  <a href="#ad8102a1af5ef750fc2da054a6cfb3f1b">More...</a><br /></td></tr>
<tr class="separator:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669cf45a5270311bbd00c3da4cd0c41"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9669cf45a5270311bbd00c3da4cd0c41">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a9669cf45a5270311bbd00c3da4cd0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a9669cf45a5270311bbd00c3da4cd0c41">More...</a><br /></td></tr>
<tr class="separator:a9669cf45a5270311bbd00c3da4cd0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e088a0d0b60af328308dd8851a2553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; pointer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac8e088a0d0b60af328308dd8851a2553">range</a> (size_type start, size_type n)</td></tr>
<tr class="memdesc:ac8e088a0d0b60af328308dd8851a2553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice and snapshots requested range.  <a href="#ac8e088a0d0b60af328308dd8851a2553">More...</a><br /></td></tr>
<tr class="separator:ac8e088a0d0b60af328308dd8851a2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864c9a207b81f4254e9d21c100f4e9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9864c9a207b81f4254e9d21c100f4e9a">range</a> (size_type start, size_type n, size_type snapshot_size)</td></tr>
<tr class="memdesc:a9864c9a207b81f4254e9d21c100f4e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice.  <a href="#a9864c9a207b81f4254e9d21c100f4e9a">More...</a><br /></td></tr>
<tr class="separator:a9864c9a207b81f4254e9d21c100f4e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed323ccb67d5cc5348249ba992f2144d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aed323ccb67d5cc5348249ba992f2144d">range</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:aed323ccb67d5cc5348249ba992f2144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="#aed323ccb67d5cc5348249ba992f2144d">More...</a><br /></td></tr>
<tr class="separator:aed323ccb67d5cc5348249ba992f2144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc45054fc2e7a562155b3c9d246f3604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#acc45054fc2e7a562155b3c9d246f3604">crange</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:acc45054fc2e7a562155b3c9d246f3604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="#acc45054fc2e7a562155b3c9d246f3604">More...</a><br /></td></tr>
<tr class="separator:acc45054fc2e7a562155b3c9d246f3604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68621a1b88210bc2cac19f5218f7be5d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a68621a1b88210bc2cac19f5218f7be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a68621a1b88210bc2cac19f5218f7be5d">More...</a><br /></td></tr>
<tr class="separator:a68621a1b88210bc2cac19f5218f7be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ae5f550e26055428de5c6bfbe103a8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a> () const noexcept</td></tr>
<tr class="separator:a47ae5f550e26055428de5c6bfbe103a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size</a> () const noexcept</td></tr>
<tr class="separator:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724b7a93aa0f7eec8847bbc9d3f8bf0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a724b7a93aa0f7eec8847bbc9d3f8bf0a">reserve</a> (size_type capacity_new)</td></tr>
<tr class="memdesc:a724b7a93aa0f7eec8847bbc9d3f8bf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of the vector to capacity_new transactionally.  <a href="#a724b7a93aa0f7eec8847bbc9d3f8bf0a">More...</a><br /></td></tr>
<tr class="separator:a724b7a93aa0f7eec8847bbc9d3f8bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6f34cabfe6535991feacf04745536"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity</a> () const noexcept</td></tr>
<tr class="separator:a48c6f34cabfe6535991feacf04745536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae559c0be703f3dcbf0674ce4619cba40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae559c0be703f3dcbf0674ce4619cba40">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ae559c0be703f3dcbf0674ce4619cba40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests transactional removal of unused capacity.  <a href="#ae559c0be703f3dcbf0674ce4619cba40">More...</a><br /></td></tr>
<tr class="separator:ae559c0be703f3dcbf0674ce4619cba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a206dfb1d76ce938b31d1ce9eed93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a800a206dfb1d76ce938b31d1ce9eed93">clear</a> ()</td></tr>
<tr class="memdesc:a800a206dfb1d76ce938b31d1ce9eed93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a vector transactionally.  <a href="#a800a206dfb1d76ce938b31d1ce9eed93">More...</a><br /></td></tr>
<tr class="separator:a800a206dfb1d76ce938b31d1ce9eed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008f5170008840628525c7e8327a2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a6008f5170008840628525c7e8327a2e2">free_data</a> ()</td></tr>
<tr class="memdesc:a6008f5170008840628525c7e8327a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a vector and frees all allocated persistent memory for data transactionally.  <a href="#a6008f5170008840628525c7e8327a2e2">More...</a><br /></td></tr>
<tr class="separator:a6008f5170008840628525c7e8327a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c7fcde8060a3f69cb7c637331a0e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a79c7fcde8060a3f69cb7c637331a0e60">insert</a> (const_iterator pos, const T &amp;value)</td></tr>
<tr class="memdesc:a79c7fcde8060a3f69cb7c637331a0e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before pos in the container transactionally.  <a href="#a79c7fcde8060a3f69cb7c637331a0e60">More...</a><br /></td></tr>
<tr class="separator:a79c7fcde8060a3f69cb7c637331a0e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7adb0e485e06743157655fcf0023f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#afd7adb0e485e06743157655fcf0023f4">insert</a> (const_iterator pos, T &amp;&amp;value)</td></tr>
<tr class="memdesc:afd7adb0e485e06743157655fcf0023f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves value before pos in the container transactionally.  <a href="#afd7adb0e485e06743157655fcf0023f4">More...</a><br /></td></tr>
<tr class="separator:afd7adb0e485e06743157655fcf0023f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caf183169e9da9ff8b0b62d394ef9a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9caf183169e9da9ff8b0b62d394ef9a5">insert</a> (const_iterator pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a9caf183169e9da9ff8b0b62d394ef9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before pos in the container transactionally.  <a href="#a9caf183169e9da9ff8b0b62d394ef9a5">More...</a><br /></td></tr>
<tr class="separator:a9caf183169e9da9ff8b0b62d394ef9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027a813f6ba99c92c93b82c857d2fd21"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a027a813f6ba99c92c93b82c857d2fd21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a027a813f6ba99c92c93b82c857d2fd21">insert</a> (const_iterator pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a027a813f6ba99c92c93b82c857d2fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last) before pos in the container transactionally.  <a href="#a027a813f6ba99c92c93b82c857d2fd21">More...</a><br /></td></tr>
<tr class="separator:a027a813f6ba99c92c93b82c857d2fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff133b9e6be243d3d424f87265eb329c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aff133b9e6be243d3d424f87265eb329c">insert</a> (const_iterator pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:aff133b9e6be243d3d424f87265eb329c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos in the container transactionally.  <a href="#aff133b9e6be243d3d424f87265eb329c">More...</a><br /></td></tr>
<tr class="separator:aff133b9e6be243d3d424f87265eb329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97d58bb5449ccb8ef9ac8d7edff7441"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae97d58bb5449ccb8ef9ac8d7edff7441"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae97d58bb5449ccb8ef9ac8d7edff7441">emplace</a> (const_iterator pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae97d58bb5449ccb8ef9ac8d7edff7441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos.  <a href="#ae97d58bb5449ccb8ef9ac8d7edff7441">More...</a><br /></td></tr>
<tr class="separator:ae97d58bb5449ccb8ef9ac8d7edff7441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba81c6240593837b8240c757fe69b399"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aba81c6240593837b8240c757fe69b399"><td class="memTemplItemLeft" align="right" valign="top">reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aba81c6240593837b8240c757fe69b399">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aba81c6240593837b8240c757fe69b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container.  <a href="#aba81c6240593837b8240c757fe69b399">More...</a><br /></td></tr>
<tr class="separator:aba81c6240593837b8240c757fe69b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d321b2771489ade6001dd6d8512cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a19d321b2771489ade6001dd6d8512cd0">erase</a> (const_iterator pos)</td></tr>
<tr class="memdesc:a19d321b2771489ade6001dd6d8512cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <a href="#a19d321b2771489ade6001dd6d8512cd0">More...</a><br /></td></tr>
<tr class="separator:a19d321b2771489ade6001dd6d8512cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8816d2c54e45312fe7435b5ebc8823bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8816d2c54e45312fe7435b5ebc8823bb">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:a8816d2c54e45312fe7435b5ebc8823bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last).  <a href="#a8816d2c54e45312fe7435b5ebc8823bb">More...</a><br /></td></tr>
<tr class="separator:a8816d2c54e45312fe7435b5ebc8823bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c2d7d88406a4f968d51a1570c75615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae3c2d7d88406a4f968d51a1570c75615">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ae3c2d7d88406a4f968d51a1570c75615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container transactionally.  <a href="#ae3c2d7d88406a4f968d51a1570c75615">More...</a><br /></td></tr>
<tr class="separator:ae3c2d7d88406a4f968d51a1570c75615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744151a15dde1ad437d09630578275d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a744151a15dde1ad437d09630578275d6">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a744151a15dde1ad437d09630578275d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container transactionally.  <a href="#a744151a15dde1ad437d09630578275d6">More...</a><br /></td></tr>
<tr class="separator:a744151a15dde1ad437d09630578275d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692a2011bfa77c667a8d8b417d9d445c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a692a2011bfa77c667a8d8b417d9d445c">pop_back</a> ()</td></tr>
<tr class="memdesc:a692a2011bfa77c667a8d8b417d9d445c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container transactionally.  <a href="#a692a2011bfa77c667a8d8b417d9d445c">More...</a><br /></td></tr>
<tr class="separator:a692a2011bfa77c667a8d8b417d9d445c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b95b576242f9fdcdfecfaad1188178b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a5b95b576242f9fdcdfecfaad1188178b">resize</a> (size_type count)</td></tr>
<tr class="memdesc:a5b95b576242f9fdcdfecfaad1188178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to count elements transactionally.  <a href="#a5b95b576242f9fdcdfecfaad1188178b">More...</a><br /></td></tr>
<tr class="separator:a5b95b576242f9fdcdfecfaad1188178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a66eb353a0725e84d14b18b9b5fc325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a1a66eb353a0725e84d14b18b9b5fc325">resize</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a1a66eb353a0725e84d14b18b9b5fc325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements transactionally.  <a href="#a1a66eb353a0725e84d14b18b9b5fc325">More...</a><br /></td></tr>
<tr class="separator:a1a66eb353a0725e84d14b18b9b5fc325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1ed01e57919aa22d333b13ef2087bf"><td class="memItemLeft" align="right" valign="top"><a id="a3a1ed01e57919aa22d333b13ef2087bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a3a1ed01e57919aa22d333b13ef2087bf">swap</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a3a1ed01e57919aa22d333b13ef2087bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with other transactionally. <br /></td></tr>
<tr class="separator:a3a1ed01e57919aa22d333b13ef2087bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20b29d64478338c10f35c5b347bcf32"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab20b29d64478338c10f35c5b347bcf32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ab20b29d64478338c10f35c5b347bcf32">assign</a> (size_type count, const_reference value)</td></tr>
<tr class="memdesc:ab20b29d64478338c10f35c5b347bcf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value value transactionally.  <a href="#ab20b29d64478338c10f35c5b347bcf32">More...</a><br /></td></tr>
<tr class="separator:ab20b29d64478338c10f35c5b347bcf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aba4cb6b3d5784b2df452b623b8c6417c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aba4cb6b3d5784b2df452b623b8c6417c">alloc</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a>)</td></tr>
<tr class="memdesc:aba4cb6b3d5784b2df452b623b8c6417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#aba4cb6b3d5784b2df452b623b8c6417c">More...</a><br /></td></tr>
<tr class="separator:aba4cb6b3d5784b2df452b623b8c6417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b54e4cef456536308f006ed113c2cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a24b54e4cef456536308f006ed113c2cc">check_pmem</a> ()</td></tr>
<tr class="memdesc:a24b54e4cef456536308f006ed113c2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a24b54e4cef456536308f006ed113c2cc">More...</a><br /></td></tr>
<tr class="separator:a24b54e4cef456536308f006ed113c2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef85f137ae5df463a88150f20a8383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#acbef85f137ae5df463a88150f20a8383">check_tx_stage_work</a> ()</td></tr>
<tr class="memdesc:acbef85f137ae5df463a88150f20a8383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#acbef85f137ae5df463a88150f20a8383">More...</a><br /></td></tr>
<tr class="separator:acbef85f137ae5df463a88150f20a8383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ccf18ad5c4c53d0cd5578d865ba53"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa13ccf18ad5c4c53d0cd5578d865ba53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa13ccf18ad5c4c53d0cd5578d865ba53">construct</a> (size_type idx, size_type count, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa13ccf18ad5c4c53d0cd5578d865ba53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#aa13ccf18ad5c4c53d0cd5578d865ba53">More...</a><br /></td></tr>
<tr class="separator:aa13ccf18ad5c4c53d0cd5578d865ba53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab172bc0cb5958fbcd3a90792e3ff03a7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab172bc0cb5958fbcd3a90792e3ff03a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ab172bc0cb5958fbcd3a90792e3ff03a7">construct_range</a> (size_type idx, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ab172bc0cb5958fbcd3a90792e3ff03a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ab172bc0cb5958fbcd3a90792e3ff03a7">More...</a><br /></td></tr>
<tr class="separator:ab172bc0cb5958fbcd3a90792e3ff03a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53045e6cf37991db138155d3ae84e086"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a53045e6cf37991db138155d3ae84e086"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a53045e6cf37991db138155d3ae84e086">construct_range_copy</a> (size_type idx, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a53045e6cf37991db138155d3ae84e086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a53045e6cf37991db138155d3ae84e086">More...</a><br /></td></tr>
<tr class="separator:a53045e6cf37991db138155d3ae84e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5a8edfd27ffe6744a36571982c6736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2a5a8edfd27ffe6744a36571982c6736">dealloc</a> ()</td></tr>
<tr class="memdesc:a2a5a8edfd27ffe6744a36571982c6736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a2a5a8edfd27ffe6744a36571982c6736">More...</a><br /></td></tr>
<tr class="separator:a2a5a8edfd27ffe6744a36571982c6736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f76a5d515a8ddd6c9a0a867752cbbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad0f76a5d515a8ddd6c9a0a867752cbbb">get_pool</a> () const noexcept</td></tr>
<tr class="memdesc:ad0f76a5d515a8ddd6c9a0a867752cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ad0f76a5d515a8ddd6c9a0a867752cbbb">More...</a><br /></td></tr>
<tr class="separator:ad0f76a5d515a8ddd6c9a0a867752cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5953150fc9a2a3f6547f3ae77d64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a37b5953150fc9a2a3f6547f3ae77d64e">insert_gap</a> (size_type idx, size_type count)</td></tr>
<tr class="memdesc:a37b5953150fc9a2a3f6547f3ae77d64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a37b5953150fc9a2a3f6547f3ae77d64e">More...</a><br /></td></tr>
<tr class="separator:a37b5953150fc9a2a3f6547f3ae77d64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dcd57e3e0b76697e75f00689a5a44e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a25dcd57e3e0b76697e75f00689a5a44e">realloc</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a>)</td></tr>
<tr class="memdesc:a25dcd57e3e0b76697e75f00689a5a44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a25dcd57e3e0b76697e75f00689a5a44e">More...</a><br /></td></tr>
<tr class="separator:a25dcd57e3e0b76697e75f00689a5a44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b585f0409efb24076e2e51ad29646"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a927b585f0409efb24076e2e51ad29646">get_recommended_capacity</a> (size_type at_least) const</td></tr>
<tr class="memdesc:a927b585f0409efb24076e2e51ad29646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a927b585f0409efb24076e2e51ad29646">More...</a><br /></td></tr>
<tr class="separator:a927b585f0409efb24076e2e51ad29646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e3cd9016b8da9a56d3d02b10a32bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68e3cd9016b8da9a56d3d02b10a32bc0">shrink</a> (size_type size_new)</td></tr>
<tr class="memdesc:a68e3cd9016b8da9a56d3d02b10a32bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a68e3cd9016b8da9a56d3d02b10a32bc0">More...</a><br /></td></tr>
<tr class="separator:a68e3cd9016b8da9a56d3d02b10a32bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77324b7384335ba15f3224061f91666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac77324b7384335ba15f3224061f91666">snapshot_data</a> (size_type idx_first, size_type idx_last)</td></tr>
<tr class="memdesc:ac77324b7384335ba15f3224061f91666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ac77324b7384335ba15f3224061f91666">More...</a><br /></td></tr>
<tr class="separator:ac77324b7384335ba15f3224061f91666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::vector&lt; T &gt;</h3>

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a636c3f33b0647feb03e1caf9aece8ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636c3f33b0647feb03e1caf9aece8ab2">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77628ae4d95b0e93037541f104ec86b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77628ae4d95b0e93037541f104ec86b3">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486b0a598e44399198a1f05ee732e576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486b0a598e44399198a1f05ee732e576">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of T default constructed values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f6b898490147e4c6e620785d5194aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f6b898490147e4c6e620785d5194aa">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>The first and last arguments must satisfy InputIterator requirements. This overload only participates in overload resolution if InputIt satisfies InputIterator, to avoid ambiguity with the overload of count-value constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1167a0629de37532aa57f39da47fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1167a0629de37532aa57f39da47fa9">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa503ab924495ac60140b9852ce7d52b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa503ab924495ac60140b9852ce7d52b0">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d" title="Checks whether the container is empty. ">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the vector to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == other.data() </dd>
<dd>
other.data() == nullptr </dd>
<dd>
other.capacity() == 0 </dd>
<dd>
other.size() == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a88f2db2da445af0fab25559262c636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a88f2db2da445af0fab25559262c636">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == init.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78a001086850b80531195cef02a20cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a001086850b80531195cef02a20cac">&#9670;&nbsp;</a></span>vector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of std::vector&lt;T&gt; other. This constructor is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a395a49f38bcde6c2164405fc9bb2c35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395a49f38bcde6c2164405fc9bb2c35a">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::~<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that free_data may throw an <a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">transaction_free_error</a> when freeing underlying array failed. It is recommended to call free_data manually before object destruction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aba4cb6b3d5784b2df452b623b8c6417c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4cb6b3d5784b2df452b623b8c6417c">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Allocates memory for given number of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>capacity of new underlying array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == capacity_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size exceeds biggest possible pmem allocation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7851ebcbb853614a9cfbc1a46cca04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7851ebcbb853614a9cfbc1a46cca04">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last) transactionally. </p>
<p>This overload participates in overload resolution only if InputIt satisfies InputIterator. All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a>, std::distance(first, last))</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if std::distance(first, last) &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59bfbabccc7470173742b166cf81daf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bfbabccc7470173742b166cf81daf3">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list ilist transactionally. </p>
<p>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::distance(<a class="el" href="array_8hpp.html#ad806dbb16c66eb3055bd249dbd675726" title="Non-member begin. ">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a51fbfe71ad89d817a95b324aac1d4a1b" title="Non-member end. ">ilist.end()</a>) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if std::distance(first, last) &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbfa502cfe61a810ca2840c50a460ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfa502cfe61a810ca2840c50a460ccf">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment method. </p>
<p>Replaces the contents with a copy of the contents of other transactionally. This method is not specified by STL standards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a>, other.capacity())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae605ad1bc7d276cd45a164a487526f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae605ad1bc7d276cd45a164a487526f56">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment method. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container) transactionally. Other is in a valid but empty state afterwards. This method is not specified by STL standards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7b3074c3819a373be5d02d4d294f07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b3074c3819a373be5d02d4d294f07c">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment method. </p>
<p>Replaces the contents with a copy of the contents of std::vector&lt;T&gt; other transactionally. This method is not specified by STL standards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a>, other.capacity())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20b29d64478338c10f35c5b347bcf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b29d64478338c10f35c5b347bcf32">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value value transactionally. </p>
<p>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(size(), count)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b1f1a08b1d34f9874c1d56dce9c8ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1f1a08b1d34f9874c1d56dce9c8ec8">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking and add it to a transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83db43b38bad316d12f51319fcdb2054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db43b38bad316d12f51319fcdb2054">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0014916c3340dfafdcba429a3afd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0014916c3340dfafdcba429a3afd4a">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01dc2516566c13ec6713c624cdfd2c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dc2516566c13ec6713c624cdfd2c21">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying array. </dd></dl>

</div>
</div>
<a id="aab88d348f9aec780a683e0572b60be83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab88d348f9aec780a683e0572b60be83">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a3cb307d36ab9098655ba1a1166d37444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb307d36ab9098655ba1a1166d37444">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a48c6f34cabfe6535991feacf04745536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c6f34cabfe6535991feacf04745536">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements that can be held in currently allocated storage </dd></dl>

</div>
</div>
<a id="af19e208064355c8176eeffa1c832cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19e208064355c8176eeffa1c832cdd5">&#9670;&nbsp;</a></span>cback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a" title="Access the last element and add this element to a transaction. ">back()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5" title="Access the last element. ">cback()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5" title="Access the last element. ">cback()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying array. </dd></dl>

</div>
</div>
<a id="aae52abd4d3c066bf755b78f4b781c1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae52abd4d3c066bf755b78f4b781c1d8">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aae52abd4d3c066bf755b78f4b781c1d8" title="Returns const iterator to the beginning. ">cbegin()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a8a3543940ea0b583b71e96ec3a89c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3543940ea0b583b71e96ec3a89c68a">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const raw pointer to the underlying data. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a" title="Returns const raw pointer to the underlying data. ">cdata()</a> will return const_pointer not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a" title="Returns const raw pointer to the underlying data. ">cdata()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const_pointer to the underlying data. </dd></dl>

</div>
</div>
<a id="ac1f050f7fabb39ec5918fbc1fb3604ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f050f7fabb39ec5918fbc1fb3604ba">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac1f050f7fabb39ec5918fbc1fb3604ba" title="Returns a const iterator to the end. ">cend()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="abbfb83c8e3bda44858a6923319e880e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfb83c8e3bda44858a6923319e880e6">&#9670;&nbsp;</a></span>cfront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cfront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ea56dd1be6b3e5d0427a62327b81e5" title="Access the first element and add this element to a transaction. ">front()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6" title="Access the first element. ">cfront()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6" title="Access the first element. ">cfront()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying array. </dd></dl>

</div>
</div>
<a id="a24b54e4cef456536308f006ed113c2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b54e4cef456536308f006ed113c2cc">&#9670;&nbsp;</a></span>check_pmem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::check_pmem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if vector resides on pmem and throws an exception if not.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pool_error</a></td><td>if vector doesn't reside on pmem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbef85f137ae5df463a88150f20a8383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbef85f137ae5df463a88150f20a8383">&#9670;&nbsp;</a></span>check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::check_tx_stage_work </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if current transaction stage is equal to TX_STAGE_WORK and throws an exception otherwise.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if current transaction stage is not equal to TX_STAGE_WORK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a800a206dfb1d76ce938b31d1ce9eed93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a206dfb1d76ce938b31d1ce9eed93">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a vector transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38fc08c07d12cdacc4426285962f0c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fc08c07d12cdacc4426285962f0c21">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7b1f1a08b1d34f9874c1d56dce9c8ec8" title="Access element at specific index with bounds checking and add it to a transaction. ">at()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21" title="Access element at specific index with bounds checking. ">const_at()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21" title="Access element at specific index with bounds checking. ">const_at()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa13ccf18ad5c4c53d0cd5578d865ba53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13ccf18ad5c4c53d0cd5578d865ba53">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is free space for additional elements. Constructs elements at given index in underlying array based on given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>underyling array index where new elements will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>variadic template arguments for value_type constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + count) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= count + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
args is valid argument for value_type constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab172bc0cb5958fbcd3a90792e3ff03a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab172bc0cb5958fbcd3a90792e3ff03a7">&#9670;&nbsp;</a></span>construct_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::construct_range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is free space for additional elements and input arguments satisfy InputIterator requirements. Moves elements at index idx in underlying array with the contents of the range [first, last). This overload participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>underyling array index where new elements will be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= std::distance(first, last) + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
std::move(InputIt::reference) is valid argument for value_type constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53045e6cf37991db138155d3ae84e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53045e6cf37991db138155d3ae84e086">&#9670;&nbsp;</a></span>construct_range_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::construct_range_copy </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is free space for additional elements and input arguments satisfy InputIterator requirements. Copy-constructs elements before pos in underlying array with the contents of the range [first, last).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>underyling array index where new elements will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= std::distance(first, last) + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
InputIt::reference is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc45054fc2e7a562155b3c9d246f3604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc45054fc2e7a562155b3c9d246f3604">&#9670;&nbsp;</a></span>crange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_iterator &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crange </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0767248672d1dde6231a2edf45e4edad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0767248672d1dde6231a2edf45e4edad">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abdec3d65c0203596140b72b21581c795" title="Returns a reverse iterator to the beginning. ">rbegin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a0767248672d1dde6231a2edf45e4edad" title="Returns a const reverse iterator to the beginning. ">crbegin()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a9669cf45a5270311bbd00c3da4cd0c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669cf45a5270311bbd00c3da4cd0c41">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a301b79d6c2a9f83b2b786a7a38951431" title="Returns a reverse iterator to the end. ">rend()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9669cf45a5270311bbd00c3da4cd0c41" title="Returns a const reverse iterator to the beginning. ">crend()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a10579fdbcf3a682355025954d4ba665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10579fdbcf3a682355025954d4ba665f">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns raw pointer to the underlying data and adds entire array to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the underlying data.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9561c662b97f84da5e47e0f767f9bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9561c662b97f84da5e47e0f767f9bde">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const raw pointer to the underlying data. </p>
<dl class="section return"><dt>Returns</dt><dd>const_pointer to the underlying data. </dd></dl>

</div>
</div>
<a id="a2a5a8edfd27ffe6744a36571982c6736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5a8edfd27ffe6744a36571982c6736">&#9670;&nbsp;</a></span>dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::dealloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Deallocates underlying array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97d58bb5449ccb8ef9ac8d7edff7441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97d58bb5449ccb8ef9ac8d7edff7441">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. </p>
<p>The element is constructed in-place. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. Note that standard allows args to be a self reference and internal emplace implementation handles this case by creating temporary element_type object. This object is being stored either on stack or on pmem, see <a class="el" href="structpmem_1_1detail_1_1temp__value.html" title="Template class for caching objects based on constructor&#39;s variadic template arguments and LIBPMEMOBJ_...">pmem::detail::temp_value</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the new element will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable, MoveInsertable and EmplaceConstructible.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity, or remains the same if there is enough space to add single element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba81c6240593837b8240c757fe69b399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba81c6240593837b8240c757fe69b399">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. </p>
<p>The element is constructed in-place. The arguments args... are forwarded to the constructor as std::forward&lt;Args&gt;(args).... If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveInsertable and EmplaceConstructible.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity, or remains the same if there is enough space to add single element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68621a1b88210bc2cac19f5218f7be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68621a1b88210bc2cac19f5218f7be5d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="aac5d32b0060badd059f0ac41eb73bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d32b0060badd059f0ac41eb73bf54">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="aa289592fadece20471f1588c0a1bddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289592fadece20471f1588c0a1bddb3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="a19d321b2771489ade6001dd6d8512cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d321b2771489ade6001dd6d8512cd0">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to the element to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator pos refers to the last element, the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> - 1.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8816d2c54e45312fe7435b5ebc8823bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8816d2c54e45312fe7435b5ebc8823bb">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>beginning of the range of elements to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of range of elements to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator pos refers to the last element, the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator is returned. If first and last refer to the same element, iterator to this element is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> - std::distance(first, last).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6008f5170008840628525c7e8327a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008f5170008840628525c7e8327a2e2">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a vector and frees all allocated persistent memory for data transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ea56dd1be6b3e5d0427a62327b81e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ea56dd1be6b3e5d0427a62327b81e5">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674fdb0401fd0f7396675035d1d8e72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674fdb0401fd0f7396675035d1d8e72a">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to first element in underlying array. </dd></dl>

</div>
</div>
<a id="ad0f76a5d515a8ddd6c9a0a867752cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f76a5d515a8ddd6c9a0a867752cbbb">&#9670;&nbsp;</a></span>get_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::get_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class. ">pool_base</a> object where vector resides.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>underlying array must reside in persistent memory pool. </dd></dl>

</div>
</div>
<a id="a927b585f0409efb24076e2e51ad29646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927b585f0409efb24076e2e51ad29646">&#9670;&nbsp;</a></span>get_recommended_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::get_recommended_capacity </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>at_least</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Returns recommended capacity for at least at_least elements.</p>
<dl class="section return"><dt>Returns</dt><dd>recommended new capacity. </dd></dl>

</div>
</div>
<a id="a79c7fcde8060a3f69cb7c637331a0e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c7fcde8060a3f69cb7c637331a0e60">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts value before pos in the container transactionally. </p>
<p>Causes reallocation if the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>. If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of CopyAssignable and CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity, or remains the same if there is enough space to add single element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd7adb0e485e06743157655fcf0023f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7adb0e485e06743157655fcf0023f4">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves value before pos in the container transactionally. </p>
<p>Causes reallocation if the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>. If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveAssignable and MoveInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity, or remains the same if there is enough space to add single element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9caf183169e9da9ff8b0b62d394ef9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9caf183169e9da9ff8b0b62d394ef9a5">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts count copies of the value before pos in the container transactionally. </p>
<p>Causes reallocation if the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>. If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of copies to be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>element value to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if count == 0.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of CopyAssignable and CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity + count, or remains the same if there is enough space to add count elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a027a813f6ba99c92c93b82c857d2fd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027a813f6ba99c92c93b82c857d2fd21">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last) before pos in the container transactionally. </p>
<p>Causes reallocation if the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>. If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. This overload participates in overload resolution only if InputIt qualifies as InputIterator, to avoid ambiguity with the pos-count-value overload. The behavior is undefined if first and last are iterators into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of elements to insert, can't be iterator into container for which insert is called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of elements to insert, can't be iterator into container for which insert is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted or pos if first == last.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of EmplaceConstructible, Swappable, CopyAssignable, CopyConstructible and CopyInsertable. </dd>
<dd>
InputIt must satisfies requirements of InputIterator.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity + std::distance(first, last), or remains the same if there is enough space to add std::distance(first, last) elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff133b9e6be243d3d424f87265eb329c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff133b9e6be243d3d424f87265eb329c">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos in the container transactionally. </p>
<p>Causes reallocation if the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than the old <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>. If the new <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator before which the content will be inserted. pos may be the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list to insert the values from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if ilist is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of EmplaceConstructible, Swappable, CopyAssignable, CopyConstructible and CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity + std::distance(<a class="el" href="array_8hpp.html#ad806dbb16c66eb3055bd249dbd675726" title="Non-member begin. ">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a51fbfe71ad89d817a95b324aac1d4a1b" title="Non-member end. ">ilist.end()</a>), or remains the same if there is enough space to add std::distance(<a class="el" href="array_8hpp.html#ad806dbb16c66eb3055bd249dbd675726" title="Non-member begin. ">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a51fbfe71ad89d817a95b324aac1d4a1b" title="Non-member end. ">ilist.end()</a>) elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37b5953150fc9a2a3f6547f3ae77d64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b5953150fc9a2a3f6547f3ae77d64e">&#9670;&nbsp;</a></span>insert_gap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::insert_gap </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Inserts a gap for count elements starting at index idx. If there is not enough space available, reallocation occurs with new recommended size.</p>
<p>param[in] idx index number where gap should be made. param[in] count length (expressed in number of elements) of the gap.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if there is not enough space for additional gap, capacity changes to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a927b585f0409efb24076e2e51ad29646" title="Private helper function. ">get_recommended_capacity()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e55449de7f6a9c04eaf19f3131681a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e55449de7f6a9c04eaf19f3131681a7">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold due to PMDK limitations. </dd></dl>

</div>
</div>
<a id="a4acfe524ba035d4b199bd0288d3cfb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acfe524ba035d4b199bd0288d3cfb71">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of other transactionally.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a>, other.capacity())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a526939a78495ea025ed50ca87b918084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526939a78495ea025ed50ca87b918084">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container) transactionally. Other is in a valid but empty state afterwards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb5e5acfa00251ae623a27859ddb2de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5e5acfa00251ae623a27859ddb2de3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist transactionally. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if ilist.size() &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac250db331475486029225fb5ffda95b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac250db331475486029225fb5ffda95b9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of std::vector&lt;T&gt; other transactionally. This method is not specified by STL standards.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a>, other.capacity())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57b4e5d1c66f006ad7f87f9573f3c6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f0ffcc2e74974015ed9741b1430227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0ffcc2e74974015ed9741b1430227">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array. </dd></dl>

</div>
</div>
<a id="a692a2011bfa77c667a8d8b417d9d445c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692a2011bfa77c667a8d8b417d9d445c">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element of the container transactionally. </p>
<p>Calling pop_back on an empty container does nothing. No iterators or references except for <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a" title="Access the last element and add this element to a transaction. ">back()</a> and <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> are invalidated.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::max(0, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> - 1)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>desctructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3c2d7d88406a4f968d51a1570c75615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c2d7d88406a4f968d51a1570c75615">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container transactionally. </p>
<p>The new element is initialized as a copy of value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value of the element to be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of CopyInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity, or remains the same if there is enough space to add single element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a744151a15dde1ad437d09630578275d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744151a15dde1ad437d09630578275d6">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container transactionally. </p>
<p>value is moved into the new element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value of the element to be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must meet the requirements of MoveInsertable.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + 1 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> is equal to the smallest next power of 2, bigger than old capacity, or remains the same if there is enough space to add single element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e088a0d0b60af328308dd8851a2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e088a0d0b60af328308dd8851a2553">&#9670;&nbsp;</a></span>range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::pointer &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns slice and snapshots requested range. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9864c9a207b81f4254e9d21c100f4e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9864c9a207b81f4254e9d21c100f4e9a">&#9670;&nbsp;</a></span>range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a>&lt; T &gt; &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>snapshot_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns slice. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot_size</td><td>number of elements which should be snapshotted in a bulk while traversing this slice. If provided value is larger or equal to n, entire range is added to a transaction. If value is equal to 0 no snapshotting happens.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed323ccb67d5cc5348249ba992f2144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed323ccb67d5cc5348249ba992f2144d">&#9670;&nbsp;</a></span>range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; typename <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_iterator &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<p>This method is not specified by STL standards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdec3d65c0203596140b72b21581c795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec3d65c0203596140b72b21581c795">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a2904e853e49b5abf858e08199fe3a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2904e853e49b5abf858e08199fe3a361">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a25dcd57e3e0b76697e75f00689a5a44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dcd57e3e0b76697e75f00689a5a44e">&#9670;&nbsp;</a></span>realloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::realloc </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Allocates new memory for capacity_new number of elements and copies or moves old elements to new memory area. If the current size is greater than capacity_new, the container is reduced to its first capacity_new elements.</p>
<p>param[in] capacity_new new capacity.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == capacity_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a301b79d6c2a9f83b2b786a7a38951431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301b79d6c2a9f83b2b786a7a38951431">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="ad8102a1af5ef750fc2da054a6cfb3f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8102a1af5ef750fc2da054a6cfb3f1b">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a724b7a93aa0f7eec8847bbc9d3f8bf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724b7a93aa0f7eec8847bbc9d3f8bf0a">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the capacity of the vector to capacity_new transactionally. </p>
<p>If capacity_new is greater than the current <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, new storage is allocated, otherwise the method does nothing. If capacity_new is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>new capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(capacity(), capacity_new)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new_cap &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b95b576242f9fdcdfecfaad1188178b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b95b576242f9fdcdfecfaad1188178b">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the container to count elements transactionally. </p>
<p>If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == std::max(count, capacity()) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a66eb353a0725e84d14b18b9b5fc325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a66eb353a0725e84d14b18b9b5fc325">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements transactionally. </p>
<p>If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to initialize the new elements with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::min(_size, count)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68e3cd9016b8da9a56d3d02b10a32bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e3cd9016b8da9a56d3d02b10a32bc0">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::shrink </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Destroys elements in underlying array beginning from position size_new.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_new</td><td>new size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>) must be snapshotted in current transaction. </dd>
<dd>
size_new &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == size_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae559c0be703f3dcbf0674ce4619cba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae559c0be703f3dcbf0674ce4619cba40">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests transactional removal of unused capacity. </p>
<p>New capacity will be set to current vector size. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when reallocating failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47ae5f550e26055428de5c6bfbe103a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae5f550e26055428de5c6bfbe103a8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<a id="ac77324b7384335ba15f3224061f91666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77324b7384335ba15f3224061f91666">&#9670;&nbsp;</a></span>snapshot_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::snapshot_data </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Takes a “snapshot” of data in range [&amp;_data[idx_first], &amp;_data[idx_last])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_first</td><td>first index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_last</td><td>last index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
