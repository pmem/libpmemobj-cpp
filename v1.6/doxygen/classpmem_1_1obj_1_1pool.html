<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::pool&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.6.1</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::pool&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>PMEMobj pool class.  
 <a href="classpmem_1_1obj_1_1pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pool_8hpp_source.html">libpmemobj++/pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae26e5edd74a7fecaa683353fc22fe8b5"><td class="memItemLeft" align="right" valign="top"><a id="ae26e5edd74a7fecaa683353fc22fe8b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#ae26e5edd74a7fecaa683353fc22fe8b5">pool</a> () noexcept=default</td></tr>
<tr class="memdesc:ae26e5edd74a7fecaa683353fc22fe8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted constructor. <br /></td></tr>
<tr class="separator:ae26e5edd74a7fecaa683353fc22fe8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5473cb18d6e9cd0ab88fc875c611e2b"><td class="memItemLeft" align="right" valign="top"><a id="aa5473cb18d6e9cd0ab88fc875c611e2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#aa5473cb18d6e9cd0ab88fc875c611e2b">pool</a> (const <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;) noexcept=default</td></tr>
<tr class="memdesc:aa5473cb18d6e9cd0ab88fc875c611e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:aa5473cb18d6e9cd0ab88fc875c611e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b44411aeb6b321e38d7378d5b62ece"><td class="memItemLeft" align="right" valign="top"><a id="a41b44411aeb6b321e38d7378d5b62ece"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a41b44411aeb6b321e38d7378d5b62ece">pool</a> (<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a41b44411aeb6b321e38d7378d5b62ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a41b44411aeb6b321e38d7378d5b62ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5143f7a1d95c97781de03e9062fc85cc"><td class="memItemLeft" align="right" valign="top"><a id="a5143f7a1d95c97781de03e9062fc85cc"></a>
<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a5143f7a1d95c97781de03e9062fc85cc">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;) noexcept=default</td></tr>
<tr class="memdesc:a5143f7a1d95c97781de03e9062fc85cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy assignment operator. <br /></td></tr>
<tr class="separator:a5143f7a1d95c97781de03e9062fc85cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0621e8ce454f924858b65e27866c69a"><td class="memItemLeft" align="right" valign="top"><a id="ad0621e8ce454f924858b65e27866c69a"></a>
<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#ad0621e8ce454f924858b65e27866c69a">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ad0621e8ce454f924858b65e27866c69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move assignment operator. <br /></td></tr>
<tr class="separator:ad0621e8ce454f924858b65e27866c69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6240769ecb4fd657c9c0eae53b7a78"><td class="memItemLeft" align="right" valign="top"><a id="a1f6240769ecb4fd657c9c0eae53b7a78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a1f6240769ecb4fd657c9c0eae53b7a78">~pool</a> () noexcept=default</td></tr>
<tr class="memdesc:a1f6240769ecb4fd657c9c0eae53b7a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a1f6240769ecb4fd657c9c0eae53b7a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b373fb46d72a5c395194ff71af8ff17"><td class="memItemLeft" align="right" valign="top"><a id="a7b373fb46d72a5c395194ff71af8ff17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a7b373fb46d72a5c395194ff71af8ff17">pool</a> (const <a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;pb) noexcept</td></tr>
<tr class="memdesc:a7b373fb46d72a5c395194ff71af8ff17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:a7b373fb46d72a5c395194ff71af8ff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e3d24e46a574a4cc092bdb1af57a3c"><td class="memItemLeft" align="right" valign="top"><a id="a71e3d24e46a574a4cc092bdb1af57a3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a71e3d24e46a574a4cc092bdb1af57a3c">pool</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&amp;pb) noexcept</td></tr>
<tr class="memdesc:a71e3d24e46a574a4cc092bdb1af57a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a71e3d24e46a574a4cc092bdb1af57a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8253223d35089f9736fe37cc1f38ed53"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a8253223d35089f9736fe37cc1f38ed53"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a8253223d35089f9736fe37cc1f38ed53">ctl_get</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8253223d35089f9736fe37cc1f38ed53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a8253223d35089f9736fe37cc1f38ed53">More...</a><br /></td></tr>
<tr class="separator:a8253223d35089f9736fe37cc1f38ed53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f19b41b5e921b5edd0cf46cab20369e"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a3f19b41b5e921b5edd0cf46cab20369e"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a3f19b41b5e921b5edd0cf46cab20369e">ctl_set</a> (const std::string &amp;name, M arg)</td></tr>
<tr class="memdesc:a3f19b41b5e921b5edd0cf46cab20369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a3f19b41b5e921b5edd0cf46cab20369e">More...</a><br /></td></tr>
<tr class="separator:a3f19b41b5e921b5edd0cf46cab20369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c170c19673a29ace63092d083781330"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a7c170c19673a29ace63092d083781330"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a7c170c19673a29ace63092d083781330">ctl_exec</a> (const std::string &amp;name, M arg)</td></tr>
<tr class="memdesc:a7c170c19673a29ace63092d083781330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a7c170c19673a29ace63092d083781330">More...</a><br /></td></tr>
<tr class="separator:a7c170c19673a29ace63092d083781330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9909db1249389347b4d81b00a5e3df6"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ad9909db1249389347b4d81b00a5e3df6"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#ad9909db1249389347b4d81b00a5e3df6">ctl_get</a> (const std::wstring &amp;name)</td></tr>
<tr class="memdesc:ad9909db1249389347b4d81b00a5e3df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#ad9909db1249389347b4d81b00a5e3df6">More...</a><br /></td></tr>
<tr class="separator:ad9909db1249389347b4d81b00a5e3df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef9f3fd95a13e5a7361e756471e022b"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a3ef9f3fd95a13e5a7361e756471e022b"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a3ef9f3fd95a13e5a7361e756471e022b">ctl_set</a> (const std::wstring &amp;name, M arg)</td></tr>
<tr class="memdesc:a3ef9f3fd95a13e5a7361e756471e022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify libpmemobj state at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#a3ef9f3fd95a13e5a7361e756471e022b">More...</a><br /></td></tr>
<tr class="separator:a3ef9f3fd95a13e5a7361e756471e022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af453acceffd968ca68108e3475a7cfdc"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:af453acceffd968ca68108e3475a7cfdc"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#af453acceffd968ca68108e3475a7cfdc">ctl_exec</a> (const std::wstring &amp;name, M arg)</td></tr>
<tr class="memdesc:af453acceffd968ca68108e3475a7cfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute function at pool scope.  <a href="classpmem_1_1obj_1_1pool.html#af453acceffd968ca68108e3475a7cfdc">More...</a><br /></td></tr>
<tr class="separator:af453acceffd968ca68108e3475a7cfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b71b78e8229b009639835a5ad159d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">root</a> ()</td></tr>
<tr class="memdesc:a85b71b78e8229b009639835a5ad159d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves pool's root object.  <a href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">More...</a><br /></td></tr>
<tr class="separator:a85b71b78e8229b009639835a5ad159d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1dcc1ec8833d4a9215ce3b6d24f51a79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">open</a> (const std::string &amp;path, const std::string &amp;layout)</td></tr>
<tr class="memdesc:a1dcc1ec8833d4a9215ce3b6d24f51a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing object store memory pool.  <a href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">More...</a><br /></td></tr>
<tr class="separator:a1dcc1ec8833d4a9215ce3b6d24f51a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a780cfb3bc6c708856783938a9e8c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">create</a> (const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</td></tr>
<tr class="memdesc:a8c7a780cfb3bc6c708856783938a9e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new transactional object store pool.  <a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">More...</a><br /></td></tr>
<tr class="separator:a8c7a780cfb3bc6c708856783938a9e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff95b310c46cf87e957dfc8fafedabc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">check</a> (const std::string &amp;path, const std::string &amp;layout)</td></tr>
<tr class="memdesc:a2ff95b310c46cf87e957dfc8fafedabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given pool is consistent.  <a href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">More...</a><br /></td></tr>
<tr class="separator:a2ff95b310c46cf87e957dfc8fafedabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cc3ae8b8de69613706b26418c2b8ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a11cc3ae8b8de69613706b26418c2b8ee">open</a> (const std::wstring &amp;path, const std::wstring &amp;layout)</td></tr>
<tr class="memdesc:a11cc3ae8b8de69613706b26418c2b8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing object store memory pool.  <a href="classpmem_1_1obj_1_1pool.html#a11cc3ae8b8de69613706b26418c2b8ee">More...</a><br /></td></tr>
<tr class="separator:a11cc3ae8b8de69613706b26418c2b8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc51b425f8e25cc03fdc307187566f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a32bc51b425f8e25cc03fdc307187566f">create</a> (const std::wstring &amp;path, const std::wstring &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</td></tr>
<tr class="memdesc:a32bc51b425f8e25cc03fdc307187566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new transactional object store pool.  <a href="classpmem_1_1obj_1_1pool.html#a32bc51b425f8e25cc03fdc307187566f">More...</a><br /></td></tr>
<tr class="separator:a32bc51b425f8e25cc03fdc307187566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb6b9957bcb43a7d55b81a8054da9e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1pool.html#a8ddb6b9957bcb43a7d55b81a8054da9e">check</a> (const std::wstring &amp;path, const std::wstring &amp;layout)</td></tr>
<tr class="memdesc:a8ddb6b9957bcb43a7d55b81a8054da9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given pool is consistent.  <a href="classpmem_1_1obj_1_1pool.html#a8ddb6b9957bcb43a7d55b81a8054da9e">More...</a><br /></td></tr>
<tr class="separator:a8ddb6b9957bcb43a7d55b81a8054da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::pool&lt; T &gt;</h3>

<p>PMEMobj pool class. </p>
<p>This class is the pmemobj pool handler. It provides basic primitives for operations on pmemobj pools. The template parameter defines the type of the root object within the pool. The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="p_8hpp.html">libpmemobj++/p.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>pmem::obj;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">pool_example()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// pool root structure</span></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">root</a> {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> some_array[42];</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> some_other_array[42];</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;double&gt;</a> some_variable;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a pmemobj pool</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// close a pmemobj pool</span></div>
<div class="line">    pop.close();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// or open a pmemobj pool</span></div>
<div class="line">    pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pool&lt;root&gt;::open</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// typical usage schemes</span></div>
<div class="line">    <span class="keyword">auto</span> root_obj = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// low-level memory manipulation</span></div>
<div class="line">    root_obj-&gt;some_variable = 3.2;</div>
<div class="line">    pop.persist(root_obj-&gt;some_variable);</div>
<div class="line"> </div>
<div class="line">    pop.memset_persist(root_obj-&gt;some_array, 2,</div>
<div class="line">               <span class="keyword">sizeof</span>(root_obj-&gt;some_array));</div>
<div class="line"> </div>
<div class="line">    pop.memcpy_persist(root_obj-&gt;some_other_array, root_obj-&gt;some_array,</div>
<div class="line">               <span class="keyword">sizeof</span>(root_obj-&gt;some_array));</div>
<div class="line"> </div>
<div class="line">    pop.close();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// check pool consistency</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">pool&lt;root&gt;::check</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ff95b310c46cf87e957dfc8fafedabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff95b310c46cf87e957dfc8fafedabc">&#9670;&nbsp;</a></span>check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::check </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given pool is consistent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, 1 if file is consistent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a8ddb6b9957bcb43a7d55b81a8054da9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddb6b9957bcb43a7d55b81a8054da9e">&#9670;&nbsp;</a></span>check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::check </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given pool is consistent. </p>
<p>Wide string variant. Available only on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, 1 if file is consistent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a8c7a780cfb3bc6c708856783938a9e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a780cfb3bc6c708856783938a9e8c">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>PMEMOBJ_MIN_POOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEFAULT_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new transactional object store pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file to be created. If exists the pool can be created in-place depending on the size parameter. Existing file must be zeroed. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool, can be a null-terminated string. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the pool in bytes. If zero and the file exists the pool is created in-place. </td></tr>
    <tr><td class="paramname">mode</td><td>File mode for the new file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the created pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during creation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32bc51b425f8e25cc03fdc307187566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bc51b425f8e25cc03fdc307187566f">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>PMEMOBJ_MIN_POOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEFAULT_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new transactional object store pool. </p>
<p>Wide string variant. Available only on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file to be created. If exists the pool can be created in-place depending on the size parameter. Existing file must be zeroed. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool, can be a null-terminated string. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the pool in bytes. If zero and the file exists the pool is created in-place. </td></tr>
    <tr><td class="paramname">mode</td><td>File mode for the new file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the created pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during creation occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c170c19673a29ace63092d083781330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c170c19673a29ace63092d083781330">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute function at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="af453acceffd968ca68108e3475a7cfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af453acceffd968ca68108e3475a7cfdc">&#9670;&nbsp;</a></span>ctl_exec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_exec </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute function at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a8253223d35089f9736fe37cc1f38ed53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8253223d35089f9736fe37cc1f38ed53">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="ad9909db1249389347b4d81b00a5e3df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9909db1249389347b4d81b00a5e3df6">&#9670;&nbsp;</a></span>ctl_get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_get </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable representing internal state</dd></dl>
<p>For more details, see: <a href="http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a3f19b41b5e921b5edd0cf46cab20369e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f19b41b5e921b5edd0cf46cab20369e">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a3ef9f3fd95a13e5a7361e756471e022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef9f3fd95a13e5a7361e756471e022b">&#9670;&nbsp;</a></span>ctl_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::ctl_set </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify libpmemobj state at pool scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>extra argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of arg, possibly modified by query</dd></dl>
<p>For more details, see: <a href="http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3">http://pmem.io/pmdk/manpages/linux/master/libpmemobj/pmemobj_ctl_get.3</a> </p>

</div>
</div>
<a id="a1dcc1ec8833d4a9215ce3b6d24f51a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcc1ec8833d4a9215ce3b6d24f51a79">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing object store memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the opened pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during opening occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11cc3ae8b8de69613706b26418c2b8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cc3ae8b8de69613706b26418c2b8ee">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing object store memory pool. </p>
<p>Wide string variant. Available only on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>System path to the file containing the memory pool or a pool set. </td></tr>
    <tr><td class="paramname">layout</td><td>Unique identifier of the pool as specified at pool creation time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the opened pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>when an error during opening occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85b71b78e8229b009639835a5ad159d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b71b78e8229b009639835a5ad159d2">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1pool.html">pmem::obj::pool</a>&lt; T &gt;::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves pool's root object. </p>
<dl class="section return"><dt>Returns</dt><dd>persistent pointer to the root object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libpmemobj++/<a class="el" href="persistent__ptr_8hpp_source.html">persistent_ptr.hpp</a></li>
<li>libpmemobj++/<a class="el" href="pool_8hpp_source.html">pool.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:641</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1p_html"><div class="ttname"><a href="classpmem_1_1obj_1_1p.html">pmem::obj::p</a></div><div class="ttdoc">Resides on pmem class.</div><div class="ttdef"><b>Definition:</b> p.hpp:64</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a85b71b78e8229b009639835a5ad159d2"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a85b71b78e8229b009639835a5ad159d2">pmem::obj::pool::root</a></div><div class="ttdeci">persistent_ptr&lt; T &gt; root()</div><div class="ttdoc">Retrieves pool's root object.</div><div class="ttdef"><b>Definition:</b> pool.hpp:591</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="ap_8hpp_html"><div class="ttname"><a href="p_8hpp.html">p.hpp</a></div><div class="ttdoc">Resides on pmem property template.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a1dcc1ec8833d4a9215ce3b6d24f51a79"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a1dcc1ec8833d4a9215ce3b6d24f51a79">pmem::obj::pool::open</a></div><div class="ttdeci">static pool&lt; T &gt; open(const std::string &amp;path, const std::string &amp;layout)</div><div class="ttdoc">Opens an existing object store memory pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:619</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a2ff95b310c46cf87e957dfc8fafedabc"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a2ff95b310c46cf87e957dfc8fafedabc">pmem::obj::pool::check</a></div><div class="ttdeci">static int check(const std::string &amp;path, const std::string &amp;layout)</div><div class="ttdoc">Checks if a given pool is consistent.</div><div class="ttdef"><b>Definition:</b> pool.hpp:658</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
