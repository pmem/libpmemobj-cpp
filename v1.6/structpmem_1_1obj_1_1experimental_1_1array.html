<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::array&lt; T, N &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structpmem_1_1obj_1_1experimental_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::array&lt; T, N &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a> - EXPERIMENTAL persistent container with std::array compatible interface.  
 <a href="structpmem_1_1obj_1_1experimental_1_1array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">libpmemobj++/experimental/array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b08f4d51629e2df4df3ea9d3c0ed57e"><td class="memItemLeft" align="right" valign="top"><a id="a0b08f4d51629e2df4df3ea9d3c0ed57e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a0b08f4d51629e2df4df3ea9d3c0ed57e">array</a> ()=default</td></tr>
<tr class="memdesc:a0b08f4d51629e2df4df3ea9d3c0ed57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted constructor. <br /></td></tr>
<tr class="separator:a0b08f4d51629e2df4df3ea9d3c0ed57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26e4a679d91d33392e924cb6c500d12"><td class="memItemLeft" align="right" valign="top"><a id="ab26e4a679d91d33392e924cb6c500d12"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ab26e4a679d91d33392e924cb6c500d12">array</a> (const <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;)=default</td></tr>
<tr class="memdesc:ab26e4a679d91d33392e924cb6c500d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor. <br /></td></tr>
<tr class="separator:ab26e4a679d91d33392e924cb6c500d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3ff6b4ed3c41385a04915219a6d6e9"><td class="memItemLeft" align="right" valign="top"><a id="a2e3ff6b4ed3c41385a04915219a6d6e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a2e3ff6b4ed3c41385a04915219a6d6e9">array</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a2e3ff6b4ed3c41385a04915219a6d6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted move constructor. <br /></td></tr>
<tr class="separator:a2e3ff6b4ed3c41385a04915219a6d6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bccc2060e31d7542a6474be21fd0505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a6bccc2060e31d7542a6474be21fd0505">operator=</a> (const <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:a6bccc2060e31d7542a6474be21fd0505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator - perform assignment from other <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a>.  <a href="#a6bccc2060e31d7542a6474be21fd0505">More...</a><br /></td></tr>
<tr class="separator:a6bccc2060e31d7542a6474be21fd0505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9811fabf1a6be1f192e0a9df229e3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ad9811fabf1a6be1f192e0a9df229e3f0">operator=</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ad9811fabf1a6be1f192e0a9df229e3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator - perform move assignment from other <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a>.  <a href="#ad9811fabf1a6be1f192e0a9df229e3f0">More...</a><br /></td></tr>
<tr class="separator:ad9811fabf1a6be1f192e0a9df229e3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dbf9b01038b26280b6528be6dc0c63"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#af1dbf9b01038b26280b6528be6dc0c63">at</a> (size_type n)</td></tr>
<tr class="memdesc:af1dbf9b01038b26280b6528be6dc0c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#af1dbf9b01038b26280b6528be6dc0c63">More...</a><br /></td></tr>
<tr class="separator:af1dbf9b01038b26280b6528be6dc0c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1d897bece3b54aef7f19d9d0958145"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aaa1d897bece3b54aef7f19d9d0958145">at</a> (size_type n) const</td></tr>
<tr class="memdesc:aaa1d897bece3b54aef7f19d9d0958145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#aaa1d897bece3b54aef7f19d9d0958145">More...</a><br /></td></tr>
<tr class="separator:aaa1d897bece3b54aef7f19d9d0958145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f636840c77790207bb18ccb7f12d271"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a9f636840c77790207bb18ccb7f12d271">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:a9f636840c77790207bb18ccb7f12d271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#a9f636840c77790207bb18ccb7f12d271">More...</a><br /></td></tr>
<tr class="separator:a9f636840c77790207bb18ccb7f12d271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa932271866762acd8428e1e3714093c6"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aa932271866762acd8428e1e3714093c6">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:aa932271866762acd8428e1e3714093c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#aa932271866762acd8428e1e3714093c6">More...</a><br /></td></tr>
<tr class="separator:aa932271866762acd8428e1e3714093c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9046bbf6ccc80c41134731940a39c7"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a4b9046bbf6ccc80c41134731940a39c7">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:a4b9046bbf6ccc80c41134731940a39c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#a4b9046bbf6ccc80c41134731940a39c7">More...</a><br /></td></tr>
<tr class="separator:a4b9046bbf6ccc80c41134731940a39c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd56264027a5074e0098126dbf41ecf"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a9fd56264027a5074e0098126dbf41ecf">data</a> ()</td></tr>
<tr class="memdesc:a9fd56264027a5074e0098126dbf41ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw pointer to the underlying data and adds entire array to a transaction.  <a href="#a9fd56264027a5074e0098126dbf41ecf">More...</a><br /></td></tr>
<tr class="separator:a9fd56264027a5074e0098126dbf41ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1613001851064c4a8d6fde51b245b8"><td class="memItemLeft" align="right" valign="top"><a id="aed1613001851064c4a8d6fde51b245b8"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aed1613001851064c4a8d6fde51b245b8">data</a> () const noexcept</td></tr>
<tr class="memdesc:aed1613001851064c4a8d6fde51b245b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data. <br /></td></tr>
<tr class="separator:aed1613001851064c4a8d6fde51b245b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f60e4390221dd69fea8b5178259dec"><td class="memItemLeft" align="right" valign="top"><a id="a47f60e4390221dd69fea8b5178259dec"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a47f60e4390221dd69fea8b5178259dec">cdata</a> () const noexcept</td></tr>
<tr class="memdesc:a47f60e4390221dd69fea8b5178259dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data. <br /></td></tr>
<tr class="separator:a47f60e4390221dd69fea8b5178259dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba3104261fae344ce59c73808877c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aaba3104261fae344ce59c73808877c3b">begin</a> ()</td></tr>
<tr class="memdesc:aaba3104261fae344ce59c73808877c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#aaba3104261fae344ce59c73808877c3b">More...</a><br /></td></tr>
<tr class="separator:aaba3104261fae344ce59c73808877c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb6a262da1b351f24188901194c2a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a3eb6a262da1b351f24188901194c2a5d">end</a> ()</td></tr>
<tr class="memdesc:a3eb6a262da1b351f24188901194c2a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="#a3eb6a262da1b351f24188901194c2a5d">More...</a><br /></td></tr>
<tr class="separator:a3eb6a262da1b351f24188901194c2a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0162f20496d6921c80aa4bb09364483f"><td class="memItemLeft" align="right" valign="top"><a id="a0162f20496d6921c80aa4bb09364483f"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a0162f20496d6921c80aa4bb09364483f">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a0162f20496d6921c80aa4bb09364483f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="separator:a0162f20496d6921c80aa4bb09364483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace46cae7d3329adf991c7eafb84c37df"><td class="memItemLeft" align="right" valign="top"><a id="ace46cae7d3329adf991c7eafb84c37df"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ace46cae7d3329adf991c7eafb84c37df">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ace46cae7d3329adf991c7eafb84c37df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="separator:ace46cae7d3329adf991c7eafb84c37df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037283eb5486a1a4f12e3aedd830bea0"><td class="memItemLeft" align="right" valign="top"><a id="a037283eb5486a1a4f12e3aedd830bea0"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a037283eb5486a1a4f12e3aedd830bea0">end</a> () const noexcept</td></tr>
<tr class="memdesc:a037283eb5486a1a4f12e3aedd830bea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end. <br /></td></tr>
<tr class="separator:a037283eb5486a1a4f12e3aedd830bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b372d2e25056536c24e3e32f840449"><td class="memItemLeft" align="right" valign="top"><a id="af5b372d2e25056536c24e3e32f840449"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#af5b372d2e25056536c24e3e32f840449">cend</a> () const noexcept</td></tr>
<tr class="memdesc:af5b372d2e25056536c24e3e32f840449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end. <br /></td></tr>
<tr class="separator:af5b372d2e25056536c24e3e32f840449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d27b0b700dd82029f981a7337b0be5"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a26d27b0b700dd82029f981a7337b0be5">rbegin</a> ()</td></tr>
<tr class="memdesc:a26d27b0b700dd82029f981a7337b0be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#a26d27b0b700dd82029f981a7337b0be5">More...</a><br /></td></tr>
<tr class="separator:a26d27b0b700dd82029f981a7337b0be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35d9161fb289de527b714ccedd636a5"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ab35d9161fb289de527b714ccedd636a5">rend</a> ()</td></tr>
<tr class="memdesc:ab35d9161fb289de527b714ccedd636a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#ab35d9161fb289de527b714ccedd636a5">More...</a><br /></td></tr>
<tr class="separator:ab35d9161fb289de527b714ccedd636a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc05d86fd31b6afc4c690ed5c246b32"><td class="memItemLeft" align="right" valign="top"><a id="affc05d86fd31b6afc4c690ed5c246b32"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#affc05d86fd31b6afc4c690ed5c246b32">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:affc05d86fd31b6afc4c690ed5c246b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning. <br /></td></tr>
<tr class="separator:affc05d86fd31b6afc4c690ed5c246b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4b8a0336cd255d4b9d0feb25442f7b"><td class="memItemLeft" align="right" valign="top"><a id="a8d4b8a0336cd255d4b9d0feb25442f7b"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a8d4b8a0336cd255d4b9d0feb25442f7b">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a8d4b8a0336cd255d4b9d0feb25442f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning. <br /></td></tr>
<tr class="separator:a8d4b8a0336cd255d4b9d0feb25442f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204593194e3520c6c18d2e61a922f708"><td class="memItemLeft" align="right" valign="top"><a id="a204593194e3520c6c18d2e61a922f708"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a204593194e3520c6c18d2e61a922f708">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a204593194e3520c6c18d2e61a922f708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end. <br /></td></tr>
<tr class="separator:a204593194e3520c6c18d2e61a922f708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40481521e7cca369e37989da830bc66"><td class="memItemLeft" align="right" valign="top"><a id="ae40481521e7cca369e37989da830bc66"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ae40481521e7cca369e37989da830bc66">crend</a> () const noexcept</td></tr>
<tr class="memdesc:ae40481521e7cca369e37989da830bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning. <br /></td></tr>
<tr class="separator:ae40481521e7cca369e37989da830bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47906ad94f3f623fb45971565f9110aa"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a47906ad94f3f623fb45971565f9110aa">front</a> ()</td></tr>
<tr class="memdesc:a47906ad94f3f623fb45971565f9110aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element and add this element to a transaction.  <a href="#a47906ad94f3f623fb45971565f9110aa">More...</a><br /></td></tr>
<tr class="separator:a47906ad94f3f623fb45971565f9110aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38aff6bb5e17944a3a31824b3fc0bf86"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a38aff6bb5e17944a3a31824b3fc0bf86">back</a> ()</td></tr>
<tr class="memdesc:a38aff6bb5e17944a3a31824b3fc0bf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element and add this element to a transaction.  <a href="#a38aff6bb5e17944a3a31824b3fc0bf86">More...</a><br /></td></tr>
<tr class="separator:a38aff6bb5e17944a3a31824b3fc0bf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97e5837f16f9494f5cd62231a833c61"><td class="memItemLeft" align="right" valign="top"><a id="af97e5837f16f9494f5cd62231a833c61"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#af97e5837f16f9494f5cd62231a833c61">front</a> () const</td></tr>
<tr class="memdesc:af97e5837f16f9494f5cd62231a833c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. <br /></td></tr>
<tr class="separator:af97e5837f16f9494f5cd62231a833c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f739cbf03253c3323f132de1e88bec"><td class="memItemLeft" align="right" valign="top"><a id="aa1f739cbf03253c3323f132de1e88bec"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aa1f739cbf03253c3323f132de1e88bec">cfront</a> () const</td></tr>
<tr class="memdesc:aa1f739cbf03253c3323f132de1e88bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element. <br /></td></tr>
<tr class="separator:aa1f739cbf03253c3323f132de1e88bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a2a46e7116298f8b509fc74b1fcd82"><td class="memItemLeft" align="right" valign="top"><a id="ae9a2a46e7116298f8b509fc74b1fcd82"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ae9a2a46e7116298f8b509fc74b1fcd82">back</a> () const</td></tr>
<tr class="memdesc:ae9a2a46e7116298f8b509fc74b1fcd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. <br /></td></tr>
<tr class="separator:ae9a2a46e7116298f8b509fc74b1fcd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d7703fc6a59d71060e7d111dbe4d3"><td class="memItemLeft" align="right" valign="top"><a id="ab71d7703fc6a59d71060e7d111dbe4d3"></a>
const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ab71d7703fc6a59d71060e7d111dbe4d3">cback</a> () const</td></tr>
<tr class="memdesc:ab71d7703fc6a59d71060e7d111dbe4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element. <br /></td></tr>
<tr class="separator:ab71d7703fc6a59d71060e7d111dbe4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b690221c22c58562c5694430cac4fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; pointer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ab1b690221c22c58562c5694430cac4fa">range</a> (size_type start, size_type n)</td></tr>
<tr class="memdesc:ab1b690221c22c58562c5694430cac4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice and snapshots requested range.  <a href="#ab1b690221c22c58562c5694430cac4fa">More...</a><br /></td></tr>
<tr class="separator:ab1b690221c22c58562c5694430cac4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1e8de9f03593cfcded689e4171f120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a1b1e8de9f03593cfcded689e4171f120">range</a> (size_type start, size_type n, size_type snapshot_size)</td></tr>
<tr class="memdesc:a1b1e8de9f03593cfcded689e4171f120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slice.  <a href="#a1b1e8de9f03593cfcded689e4171f120">More...</a><br /></td></tr>
<tr class="separator:a1b1e8de9f03593cfcded689e4171f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158127f3f70b68560d2adf69ad64595f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a158127f3f70b68560d2adf69ad64595f">range</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:a158127f3f70b68560d2adf69ad64595f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="#a158127f3f70b68560d2adf69ad64595f">More...</a><br /></td></tr>
<tr class="separator:a158127f3f70b68560d2adf69ad64595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad203a5c2cc81cdb75125c44cf2afb178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#ad203a5c2cc81cdb75125c44cf2afb178">crange</a> (size_type start, size_type n) const</td></tr>
<tr class="memdesc:ad203a5c2cc81cdb75125c44cf2afb178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const slice.  <a href="#ad203a5c2cc81cdb75125c44cf2afb178">More...</a><br /></td></tr>
<tr class="separator:ad203a5c2cc81cdb75125c44cf2afb178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfe6d912377ca6305032377a71fee62"><td class="memItemLeft" align="right" valign="top"><a id="a8bfe6d912377ca6305032377a71fee62"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a8bfe6d912377ca6305032377a71fee62">size</a> () const noexcept</td></tr>
<tr class="memdesc:a8bfe6d912377ca6305032377a71fee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of the array. <br /></td></tr>
<tr class="separator:a8bfe6d912377ca6305032377a71fee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5be31884491b905fa32f55972aa92d"><td class="memItemLeft" align="right" valign="top"><a id="a1c5be31884491b905fa32f55972aa92d"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a1c5be31884491b905fa32f55972aa92d">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a1c5be31884491b905fa32f55972aa92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum size of the array. <br /></td></tr>
<tr class="separator:a1c5be31884491b905fa32f55972aa92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6719e69d2ecad0403bd5bb13fe24831"><td class="memItemLeft" align="right" valign="top"><a id="aa6719e69d2ecad0403bd5bb13fe24831"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aa6719e69d2ecad0403bd5bb13fe24831">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aa6719e69d2ecad0403bd5bb13fe24831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether array is empty. <br /></td></tr>
<tr class="separator:aa6719e69d2ecad0403bd5bb13fe24831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed61fb674d94cc7e2d8d01baa7529822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#aed61fb674d94cc7e2d8d01baa7529822">fill</a> (const_reference value)</td></tr>
<tr class="memdesc:aed61fb674d94cc7e2d8d01baa7529822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills array with specified value inside internal transaction.  <a href="#aed61fb674d94cc7e2d8d01baa7529822">More...</a><br /></td></tr>
<tr class="separator:aed61fb674d94cc7e2d8d01baa7529822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db581feab346acb95b70b4b206cbebd"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a2db581feab346acb95b70b4b206cbebd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size !=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a2db581feab346acb95b70b4b206cbebd">swap</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:a2db581feab346acb95b70b4b206cbebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps content with other array's content inside internal transaction.  <a href="#a2db581feab346acb95b70b4b206cbebd">More...</a><br /></td></tr>
<tr class="separator:a2db581feab346acb95b70b4b206cbebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945b6ae9b19718253cb6574c546200ca"><td class="memTemplParams" colspan="2"><a id="a945b6ae9b19718253cb6574c546200ca"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a945b6ae9b19718253cb6574c546200ca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size==0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a945b6ae9b19718253cb6574c546200ca">swap</a> (<a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:a945b6ae9b19718253cb6574c546200ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap for zero-sized array. <br /></td></tr>
<tr class="separator:a945b6ae9b19718253cb6574c546200ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acd4a8b75a55671257b31544cbfcbc7d4"><td class="memTemplParams" colspan="2"><a id="acd4a8b75a55671257b31544cbfcbc7d4"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:acd4a8b75a55671257b31544cbfcbc7d4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size !=0, T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#acd4a8b75a55671257b31544cbfcbc7d4">_get_data</a> ()</td></tr>
<tr class="memdesc:acd4a8b75a55671257b31544cbfcbc7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for non-zero sized array. <br /></td></tr>
<tr class="separator:acd4a8b75a55671257b31544cbfcbc7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed361e699dd981960e24140d2e726f9"><td class="memTemplParams" colspan="2"><a id="a0ed361e699dd981960e24140d2e726f9"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a0ed361e699dd981960e24140d2e726f9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size !=0, const T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a0ed361e699dd981960e24140d2e726f9">_get_data</a> () const</td></tr>
<tr class="memdesc:a0ed361e699dd981960e24140d2e726f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for non-zero sized array. <br /></td></tr>
<tr class="separator:a0ed361e699dd981960e24140d2e726f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a636fb783adf2bdae0036c9402bf5d"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a79a636fb783adf2bdae0036c9402bf5d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size==0, T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a79a636fb783adf2bdae0036c9402bf5d">_get_data</a> ()</td></tr>
<tr class="memdesc:a79a636fb783adf2bdae0036c9402bf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for zero sized array.  <a href="#a79a636fb783adf2bdae0036c9402bf5d">More...</a><br /></td></tr>
<tr class="separator:a79a636fb783adf2bdae0036c9402bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9566ccf6e8d3ae15ed5c2cdc68b8476d"><td class="memTemplParams" colspan="2"><a id="a9566ccf6e8d3ae15ed5c2cdc68b8476d"></a>
template&lt;std::size_t Size = N&gt; </td></tr>
<tr class="memitem:a9566ccf6e8d3ae15ed5c2cdc68b8476d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Size==0, const T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#a9566ccf6e8d3ae15ed5c2cdc68b8476d">_get_data</a> () const</td></tr>
<tr class="memdesc:a9566ccf6e8d3ae15ed5c2cdc68b8476d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for zero sized array. <br /></td></tr>
<tr class="separator:a9566ccf6e8d3ae15ed5c2cdc68b8476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb629f6f4cae47a3547f7f3be600d113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html#adb629f6f4cae47a3547f7f3be600d113">_get_pool</a> () const</td></tr>
<tr class="memdesc:adb629f6f4cae47a3547f7f3be600d113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether object is on pmem and return <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class. ">pool_base</a> instance.  <a href="#adb629f6f4cae47a3547f7f3be600d113">More...</a><br /></td></tr>
<tr class="separator:adb629f6f4cae47a3547f7f3be600d113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t N&gt;<br />
struct pmem::obj::experimental::array&lt; T, N &gt;</h3>

<p><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a> - EXPERIMENTAL persistent container with std::array compatible interface. </p>
<p><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a> can only be stored on pmem. Creating array on stack will result with "pool_error" exception.</p>
<p>All methods which allow write access to specific element will add it to an active transaction.</p>
<p>All methods which return non-const pointer to raw data add entire array to a transaction.</p>
<p>When a non-const iterator is returned it adds part of the array to a transaction while traversing. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a79a636fb783adf2bdae0036c9402bf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a636fb783adf2bdae0036c9402bf5d">&#9670;&nbsp;</a></span>_get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::size_t Size = N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;Size == 0, T *&gt;::type <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::_get_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Support for zero sized array. </p>
<p>Return value is a unique address (address of the array itself); </p>

</div>
</div>
<a id="adb629f6f4cae47a3547f7f3be600d113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb629f6f4cae47a3547f7f3be600d113">&#9670;&nbsp;</a></span>_get_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::_get_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether object is on pmem and return <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class. ">pool_base</a> instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1dbf9b01038b26280b6528be6dc0c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dbf9b01038b26280b6528be6dc0c63">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of bound. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa1d897bece3b54aef7f19d9d0958145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1d897bece3b54aef7f19d9d0958145">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38aff6bb5e17944a3a31824b3fc0bf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38aff6bb5e17944a3a31824b3fc0bf86">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last element and add this element to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba3104261fae344ce59c73808877c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba3104261fae344ce59c73808877c3b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f636840c77790207bb18ccb7f12d271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f636840c77790207bb18ccb7f12d271">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad203a5c2cc81cdb75125c44cf2afb178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad203a5c2cc81cdb75125c44cf2afb178">&#9670;&nbsp;</a></span>crange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt;const_iterator&gt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::crange </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fd56264027a5074e0098126dbf41ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd56264027a5074e0098126dbf41ecf">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns raw pointer to the underlying data and adds entire array to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eb6a262da1b351f24188901194c2a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb6a262da1b351f24188901194c2a5d">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed61fb674d94cc7e2d8d01baa7529822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed61fb674d94cc7e2d8d01baa7529822">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills array with specified value inside internal transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47906ad94f3f623fb45971565f9110aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47906ad94f3f623fb45971565f9110aa">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first element and add this element to a transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bccc2060e31d7542a6474be21fd0505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bccc2060e31d7542a6474be21fd0505">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a>&amp; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator - perform assignment from other <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a>. </p>
<p>This function creates a transaction internally.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9811fabf1a6be1f192e0a9df229e3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9811fabf1a6be1f192e0a9df229e3f0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a>&amp; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator - perform move assignment from other <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html" title="pmem::obj::experimental::array - EXPERIMENTAL persistent container with std::array compatible interfa...">pmem::obj::experimental::array</a>. </p>
<p>This function creates a transaction internally.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa932271866762acd8428e1e3714093c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa932271866762acd8428e1e3714093c6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b9046bbf6ccc80c41134731940a39c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9046bbf6ccc80c41134731940a39c7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed. </p>

</div>
</div>
<a id="ab1b690221c22c58562c5694430cac4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b690221c22c58562c5694430cac4fa">&#9670;&nbsp;</a></span>range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt;pointer&gt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns slice and snapshots requested range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1e8de9f03593cfcded689e4171f120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1e8de9f03593cfcded689e4171f120">&#9670;&nbsp;</a></span>range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt;<a class="el" href="structpmem_1_1obj_1_1experimental_1_1range__snapshotting__iterator.html">range_snapshotting_iterator</a>&lt;T&gt; &gt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>snapshot_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot_size</td><td>number of elements which should be snapshotted in a bulk while traversing this slice. If provided value is larger or equal to n, entire range is added to a transaction. If value is equal to 0 no snapshotting happens.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a158127f3f70b68560d2adf69ad64595f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158127f3f70b68560d2adf69ad64595f">&#9670;&nbsp;</a></span>range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1slice.html">slice</a>&lt;const_iterator&gt; <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start index of requested range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slice from start to start + n.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any element of the range would be outside of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26d27b0b700dd82029f981a7337b0be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d27b0b700dd82029f981a7337b0be5">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35d9161fb289de527b714ccedd636a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35d9161fb289de527b714ccedd636a5">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2db581feab346acb95b70b4b206cbebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db581feab346acb95b70b4b206cbebd">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::size_t Size = N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;Size != 0&gt;::type <a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">pmem::obj::experimental::array</a>&lt; T, N &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps content with other array's content inside internal transaction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
