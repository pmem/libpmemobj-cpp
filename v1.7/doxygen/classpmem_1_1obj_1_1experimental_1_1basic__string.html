<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::basic_string&lt; CharT, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.7</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::basic_string&lt; CharT, Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible interface.  
 <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__string_8hpp_source.html">libpmemobj++/experimental/basic_string.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d13876f6b7705e0dfdae08acacfaa7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7d13876f6b7705e0dfdae08acacfaa7f">basic_string</a> ()</td></tr>
<tr class="memdesc:a7d13876f6b7705e0dfdae08acacfaa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7d13876f6b7705e0dfdae08acacfaa7f">More...</a><br /></td></tr>
<tr class="separator:a7d13876f6b7705e0dfdae08acacfaa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c936dff4606f9e09cf178c0d3359e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a49c936dff4606f9e09cf178c0d3359e2">basic_string</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:a49c936dff4606f9e09cf178c0d3359e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the container with count copies of elements with value ch.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a49c936dff4606f9e09cf178c0d3359e2">More...</a><br /></td></tr>
<tr class="separator:a49c936dff4606f9e09cf178c0d3359e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf58e1bcd43a7213f5fbd44bce006b21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf58e1bcd43a7213f5fbd44bce006b21">basic_string</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:aaf58e1bcd43a7213f5fbd44bce006b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with a substring [pos, min(pos+count, other.size()) of other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf58e1bcd43a7213f5fbd44bce006b21">More...</a><br /></td></tr>
<tr class="separator:aaf58e1bcd43a7213f5fbd44bce006b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8cd193ab8204565648bb5ca999cd50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2c8cd193ab8204565648bb5ca999cd50">basic_string</a> (const std::basic_string&lt; CharT &gt; &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:a2c8cd193ab8204565648bb5ca999cd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with a substring [pos, min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2c8cd193ab8204565648bb5ca999cd50">More...</a><br /></td></tr>
<tr class="separator:a2c8cd193ab8204565648bb5ca999cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a255c1d207f2773e1d95c33fc57f4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a89a255c1d207f2773e1d95c33fc57f4b">basic_string</a> (const CharT *s, size_type count)</td></tr>
<tr class="memdesc:a89a255c1d207f2773e1d95c33fc57f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with the first count elements of C-style string s.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a89a255c1d207f2773e1d95c33fc57f4b">More...</a><br /></td></tr>
<tr class="separator:a89a255c1d207f2773e1d95c33fc57f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f174d78e65b57d2a81cd3a31d677fca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0f174d78e65b57d2a81cd3a31d677fca">basic_string</a> (const CharT *s)</td></tr>
<tr class="memdesc:a0f174d78e65b57d2a81cd3a31d677fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with the contents of s.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0f174d78e65b57d2a81cd3a31d677fca">More...</a><br /></td></tr>
<tr class="separator:a0f174d78e65b57d2a81cd3a31d677fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46adde6ad12bdfd544e6e1d5204bc665"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a46adde6ad12bdfd544e6e1d5204bc665"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a46adde6ad12bdfd544e6e1d5204bc665">basic_string</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a46adde6ad12bdfd544e6e1d5204bc665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the string with the contents of the range [first, last).  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a46adde6ad12bdfd544e6e1d5204bc665">More...</a><br /></td></tr>
<tr class="separator:a46adde6ad12bdfd544e6e1d5204bc665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062405734d14101836de1617cfaa088c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a062405734d14101836de1617cfaa088c">basic_string</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other)</td></tr>
<tr class="memdesc:a062405734d14101836de1617cfaa088c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a062405734d14101836de1617cfaa088c">More...</a><br /></td></tr>
<tr class="separator:a062405734d14101836de1617cfaa088c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7b15b783291d3bd60ffbc7490e761c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4c7b15b783291d3bd60ffbc7490e761c">basic_string</a> (const std::basic_string&lt; CharT &gt; &amp;other)</td></tr>
<tr class="memdesc:a4c7b15b783291d3bd60ffbc7490e761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4c7b15b783291d3bd60ffbc7490e761c">More...</a><br /></td></tr>
<tr class="separator:a4c7b15b783291d3bd60ffbc7490e761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4233c850af185b3c164d3749b0455fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa4233c850af185b3c164d3749b0455fe">basic_string</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa4233c850af185b3c164d3749b0455fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa4233c850af185b3c164d3749b0455fe">More...</a><br /></td></tr>
<tr class="separator:aa4233c850af185b3c164d3749b0455fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1f3c8d134020fb77020005d68f6f7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6a1f3c8d134020fb77020005d68f6f7d">basic_string</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:a6a1f3c8d134020fb77020005d68f6f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the container with the contents of the initializer list init.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6a1f3c8d134020fb77020005d68f6f7d">More...</a><br /></td></tr>
<tr class="separator:a6a1f3c8d134020fb77020005d68f6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2846936f4c528d98782ac959020347a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af2846936f4c528d98782ac959020347a">~basic_string</a> ()</td></tr>
<tr class="memdesc:af2846936f4c528d98782ac959020347a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af2846936f4c528d98782ac959020347a">More...</a><br /></td></tr>
<tr class="separator:af2846936f4c528d98782ac959020347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25e9887350ba1e523c037e4299613f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae25e9887350ba1e523c037e4299613f0">operator=</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other)</td></tr>
<tr class="memdesc:ae25e9887350ba1e523c037e4299613f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae25e9887350ba1e523c037e4299613f0">More...</a><br /></td></tr>
<tr class="separator:ae25e9887350ba1e523c037e4299613f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8880f3c3282290b40a1a548eeaac6395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8880f3c3282290b40a1a548eeaac6395">operator=</a> (const std::basic_string&lt; CharT &gt; &amp;other)</td></tr>
<tr class="memdesc:a8880f3c3282290b40a1a548eeaac6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8880f3c3282290b40a1a548eeaac6395">More...</a><br /></td></tr>
<tr class="separator:a8880f3c3282290b40a1a548eeaac6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339651e065a2f36c8f505ff7bc55e689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a339651e065a2f36c8f505ff7bc55e689">operator=</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a339651e065a2f36c8f505ff7bc55e689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a339651e065a2f36c8f505ff7bc55e689">More...</a><br /></td></tr>
<tr class="separator:a339651e065a2f36c8f505ff7bc55e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2724d48368f4c61ab0797075031f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4f2724d48368f4c61ab0797075031f90">operator=</a> (const CharT *s)</td></tr>
<tr class="memdesc:a4f2724d48368f4c61ab0797075031f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with copy of C-style string s transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4f2724d48368f4c61ab0797075031f90">More...</a><br /></td></tr>
<tr class="separator:a4f2724d48368f4c61ab0797075031f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d3972852c0ca602af1388d0695c9c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a04d3972852c0ca602af1388d0695c9c2">operator=</a> (CharT ch)</td></tr>
<tr class="memdesc:a04d3972852c0ca602af1388d0695c9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with character ch transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a04d3972852c0ca602af1388d0695c9c2">More...</a><br /></td></tr>
<tr class="separator:a04d3972852c0ca602af1388d0695c9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43c9ce280f65d22e0d01fd961c8fc27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac43c9ce280f65d22e0d01fd961c8fc27">operator=</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:ac43c9ce280f65d22e0d01fd961c8fc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with those of the initializer list ilist transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac43c9ce280f65d22e0d01fd961c8fc27">More...</a><br /></td></tr>
<tr class="separator:ac43c9ce280f65d22e0d01fd961c8fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01745c1b661b5977eda2f441e591cadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a01745c1b661b5977eda2f441e591cadf">assign</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:a01745c1b661b5977eda2f441e591cadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with count copies of character ch transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a01745c1b661b5977eda2f441e591cadf">More...</a><br /></td></tr>
<tr class="separator:a01745c1b661b5977eda2f441e591cadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852c852210485a71e0827ed0e3037762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a852c852210485a71e0827ed0e3037762">assign</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other)</td></tr>
<tr class="memdesc:a852c852210485a71e0827ed0e3037762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string with the copy of the contents of other transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a852c852210485a71e0827ed0e3037762">More...</a><br /></td></tr>
<tr class="separator:a852c852210485a71e0827ed0e3037762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd36b026a014784c8fd5a9ecb7fd5b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#acd36b026a014784c8fd5a9ecb7fd5b91">assign</a> (const std::basic_string&lt; CharT &gt; &amp;other)</td></tr>
<tr class="memdesc:acd36b026a014784c8fd5a9ecb7fd5b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string with the copy of the contents of std::basic_string&lt;CharT&gt; other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#acd36b026a014784c8fd5a9ecb7fd5b91">More...</a><br /></td></tr>
<tr class="separator:acd36b026a014784c8fd5a9ecb7fd5b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d79b5ecc846ec185a33c4a4468312dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6d79b5ecc846ec185a33c4a4468312dc">assign</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:a6d79b5ecc846ec185a33c4a4468312dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with a substring [pos, std::min(pos+count, other.size()) of other transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6d79b5ecc846ec185a33c4a4468312dc">More...</a><br /></td></tr>
<tr class="separator:a6d79b5ecc846ec185a33c4a4468312dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0035d5d07c15fcedd54b5ede00e7c298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0035d5d07c15fcedd54b5ede00e7c298">assign</a> (const std::basic_string&lt; CharT &gt; &amp;other, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:a0035d5d07c15fcedd54b5ede00e7c298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with a substring [pos, std::min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0035d5d07c15fcedd54b5ede00e7c298">More...</a><br /></td></tr>
<tr class="separator:a0035d5d07c15fcedd54b5ede00e7c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabefb7329119f1f5d0e479bbe7f9668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adabefb7329119f1f5d0e479bbe7f9668">assign</a> (const CharT *s, size_type count)</td></tr>
<tr class="memdesc:adabefb7329119f1f5d0e479bbe7f9668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with the first count elements of C-style string s transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adabefb7329119f1f5d0e479bbe7f9668">More...</a><br /></td></tr>
<tr class="separator:adabefb7329119f1f5d0e479bbe7f9668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe2bc8a8e9ca67e19e001ca6613d819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2fe2bc8a8e9ca67e19e001ca6613d819">assign</a> (const CharT *s)</td></tr>
<tr class="memdesc:a2fe2bc8a8e9ca67e19e001ca6613d819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with copy of C-style string s transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2fe2bc8a8e9ca67e19e001ca6613d819">More...</a><br /></td></tr>
<tr class="separator:a2fe2bc8a8e9ca67e19e001ca6613d819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4ce02d1ea4365b52365d4803410293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4e4ce02d1ea4365b52365d4803410293">assign</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a4e4ce02d1ea4365b52365d4803410293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the string with the contents of other using move semantics transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4e4ce02d1ea4365b52365d4803410293">More...</a><br /></td></tr>
<tr class="separator:a4e4ce02d1ea4365b52365d4803410293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f97749d40640d52cebf64762a40c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac70f97749d40640d52cebf64762a40c7">assign</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:ac70f97749d40640d52cebf64762a40c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those of the initializer list ilist transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac70f97749d40640d52cebf64762a40c7">More...</a><br /></td></tr>
<tr class="separator:ac70f97749d40640d52cebf64762a40c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ee8aa04b5200d10589ca9d8ace785"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a114ee8aa04b5200d10589ca9d8ace785">at</a> (size_type n)</td></tr>
<tr class="memdesc:a114ee8aa04b5200d10589ca9d8ace785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking and snapshot it if there is an active transaction.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a114ee8aa04b5200d10589ca9d8ace785">More...</a><br /></td></tr>
<tr class="separator:a114ee8aa04b5200d10589ca9d8ace785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7c8867a952de3388819e8b911347d"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8bc7c8867a952de3388819e8b911347d">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a8bc7c8867a952de3388819e8b911347d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8bc7c8867a952de3388819e8b911347d">More...</a><br /></td></tr>
<tr class="separator:a8bc7c8867a952de3388819e8b911347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6347729401d23409ae8e3c20cbbdfa4"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:ab6347729401d23409ae8e3c20cbbdfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4">More...</a><br /></td></tr>
<tr class="separator:ab6347729401d23409ae8e3c20cbbdfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a43584f35e464b753766f263b98f6a"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a13a43584f35e464b753766f263b98f6a">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a13a43584f35e464b753766f263b98f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and snapshot it if there is an active transaction.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a13a43584f35e464b753766f263b98f6a">More...</a><br /></td></tr>
<tr class="separator:a13a43584f35e464b753766f263b98f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f7eaab5e9a72d3c8794d8857576d3"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab59f7eaab5e9a72d3c8794d8857576d3">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ab59f7eaab5e9a72d3c8794d8857576d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab59f7eaab5e9a72d3c8794d8857576d3">More...</a><br /></td></tr>
<tr class="separator:ab59f7eaab5e9a72d3c8794d8857576d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a95614480a2ad9c7fa4279c7ff7a40f"><td class="memItemLeft" align="right" valign="top">CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0a95614480a2ad9c7fa4279c7ff7a40f">front</a> ()</td></tr>
<tr class="memdesc:a0a95614480a2ad9c7fa4279c7ff7a40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element and snapshot it if there is an active transaction.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0a95614480a2ad9c7fa4279c7ff7a40f">More...</a><br /></td></tr>
<tr class="separator:a0a95614480a2ad9c7fa4279c7ff7a40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1290019d34af257ce831aa51800f4c1f"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1290019d34af257ce831aa51800f4c1f">front</a> () const</td></tr>
<tr class="memdesc:a1290019d34af257ce831aa51800f4c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1290019d34af257ce831aa51800f4c1f">More...</a><br /></td></tr>
<tr class="separator:a1290019d34af257ce831aa51800f4c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e2613e5b2cb491cddd071bc7d3b39"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39">cfront</a> () const</td></tr>
<tr class="memdesc:adb2e2613e5b2cb491cddd071bc7d3b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39">More...</a><br /></td></tr>
<tr class="separator:adb2e2613e5b2cb491cddd071bc7d3b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf75feee0c5a6d8b5dec8dd9cde24bed"><td class="memItemLeft" align="right" valign="top">CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adf75feee0c5a6d8b5dec8dd9cde24bed">back</a> ()</td></tr>
<tr class="memdesc:adf75feee0c5a6d8b5dec8dd9cde24bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element and snapshot it if there is an active transaction.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adf75feee0c5a6d8b5dec8dd9cde24bed">More...</a><br /></td></tr>
<tr class="separator:adf75feee0c5a6d8b5dec8dd9cde24bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dfa7c2d10786a2837a36981b4b1440"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac4dfa7c2d10786a2837a36981b4b1440">back</a> () const</td></tr>
<tr class="memdesc:ac4dfa7c2d10786a2837a36981b4b1440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac4dfa7c2d10786a2837a36981b4b1440">More...</a><br /></td></tr>
<tr class="separator:ac4dfa7c2d10786a2837a36981b4b1440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b9e19d268d06cfbdae3d274a99da02"><td class="memItemLeft" align="right" valign="top">const CharT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02">cback</a> () const</td></tr>
<tr class="memdesc:a37b9e19d268d06cfbdae3d274a99da02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02">More...</a><br /></td></tr>
<tr class="separator:a37b9e19d268d06cfbdae3d274a99da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924a8b0829e7c20a71a322f7507dc966"><td class="memItemLeft" align="right" valign="top">const CharT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a924a8b0829e7c20a71a322f7507dc966">cdata</a> () const noexcept</td></tr>
<tr class="separator:a924a8b0829e7c20a71a322f7507dc966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9ca34c0b5b017cd5817360930e152"><td class="memItemLeft" align="right" valign="top">const CharT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a92e9ca34c0b5b017cd5817360930e152">c_str</a> () const noexcept</td></tr>
<tr class="separator:a92e9ca34c0b5b017cd5817360930e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84575172811e6af3fa4735f6c98fb46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae84575172811e6af3fa4735f6c98fb46">begin</a> ()</td></tr>
<tr class="memdesc:ae84575172811e6af3fa4735f6c98fb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae84575172811e6af3fa4735f6c98fb46">More...</a><br /></td></tr>
<tr class="separator:ae84575172811e6af3fa4735f6c98fb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b726ea004e140eaedd644510a34fe4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae6b726ea004e140eaedd644510a34fe4">begin</a> () const noexcept</td></tr>
<tr class="memdesc:ae6b726ea004e140eaedd644510a34fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae6b726ea004e140eaedd644510a34fe4">More...</a><br /></td></tr>
<tr class="separator:ae6b726ea004e140eaedd644510a34fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8faca84731379e1ff9c794643b2e33"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a5b8faca84731379e1ff9c794643b2e33">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a5b8faca84731379e1ff9c794643b2e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a5b8faca84731379e1ff9c794643b2e33">More...</a><br /></td></tr>
<tr class="separator:a5b8faca84731379e1ff9c794643b2e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ba2aa7a34084c46018888f67cc9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4">end</a> ()</td></tr>
<tr class="memdesc:a526ba2aa7a34084c46018888f67cc9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to past the end.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4">More...</a><br /></td></tr>
<tr class="separator:a526ba2aa7a34084c46018888f67cc9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c8133289e2290e7d476eb65294f4f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0e2c8133289e2290e7d476eb65294f4f">end</a> () const noexcept</td></tr>
<tr class="memdesc:a0e2c8133289e2290e7d476eb65294f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to past the end.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0e2c8133289e2290e7d476eb65294f4f">More...</a><br /></td></tr>
<tr class="separator:a0e2c8133289e2290e7d476eb65294f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f708491eb1ba92834e12a25b3b273f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa8f708491eb1ba92834e12a25b3b273f">cend</a> () const noexcept</td></tr>
<tr class="memdesc:aa8f708491eb1ba92834e12a25b3b273f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to past the end.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa8f708491eb1ba92834e12a25b3b273f">More...</a><br /></td></tr>
<tr class="separator:aa8f708491eb1ba92834e12a25b3b273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0930182af8a2448d010aa603c1495326"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0930182af8a2448d010aa603c1495326">rbegin</a> ()</td></tr>
<tr class="memdesc:a0930182af8a2448d010aa603c1495326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0930182af8a2448d010aa603c1495326">More...</a><br /></td></tr>
<tr class="separator:a0930182af8a2448d010aa603c1495326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa6e329ea0d45e17a74e880994f947e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8fa6e329ea0d45e17a74e880994f947e">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a8fa6e329ea0d45e17a74e880994f947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8fa6e329ea0d45e17a74e880994f947e">More...</a><br /></td></tr>
<tr class="separator:a8fa6e329ea0d45e17a74e880994f947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550ba03ad47efe24c30fff1b4c2548b7"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a550ba03ad47efe24c30fff1b4c2548b7">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a550ba03ad47efe24c30fff1b4c2548b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the beginning.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a550ba03ad47efe24c30fff1b4c2548b7">More...</a><br /></td></tr>
<tr class="separator:a550ba03ad47efe24c30fff1b4c2548b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1ba265e840da1b926a621ee932e332"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aad1ba265e840da1b926a621ee932e332">rend</a> ()</td></tr>
<tr class="memdesc:aad1ba265e840da1b926a621ee932e332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aad1ba265e840da1b926a621ee932e332">More...</a><br /></td></tr>
<tr class="separator:aad1ba265e840da1b926a621ee932e332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77ec7a6f29e8a004e4e8bbaa262a1c"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6e77ec7a6f29e8a004e4e8bbaa262a1c">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a6e77ec7a6f29e8a004e4e8bbaa262a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6e77ec7a6f29e8a004e4e8bbaa262a1c">More...</a><br /></td></tr>
<tr class="separator:a6e77ec7a6f29e8a004e4e8bbaa262a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d27e932b80a8f6572055fdbca5fa368"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2d27e932b80a8f6572055fdbca5fa368">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a2d27e932b80a8f6572055fdbca5fa368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the end.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2d27e932b80a8f6572055fdbca5fa368">More...</a><br /></td></tr>
<tr class="separator:a2d27e932b80a8f6572055fdbca5fa368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c0f6e18623b888cb65dae95a9d79d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abe1c0f6e18623b888cb65dae95a9d79d">empty</a> () const noexcept</td></tr>
<tr class="separator:abe1c0f6e18623b888cb65dae95a9d79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d70fe47d10ff8af64ece41610b0c2c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size</a> () const noexcept</td></tr>
<tr class="separator:a10d70fe47d10ff8af64ece41610b0c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad312f37adadcbbf3396945fa685165"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7ad312f37adadcbbf3396945fa685165">length</a> () const noexcept</td></tr>
<tr class="separator:a7ad312f37adadcbbf3396945fa685165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41f64c4d254dac34bde1a6e475e5585"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size</a> () const noexcept</td></tr>
<tr class="separator:aa41f64c4d254dac34bde1a6e475e5585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae688b8f07ddcd5314de694e4ef91dad8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity</a> () const noexcept</td></tr>
<tr class="separator:ae688b8f07ddcd5314de694e4ef91dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f2e06a142986d71fd4281d1a1c1e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac9f2e06a142986d71fd4281d1a1c1e67">resize</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:ac9f2e06a142986d71fd4281d1a1c1e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the string to count characters transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac9f2e06a142986d71fd4281d1a1c1e67">More...</a><br /></td></tr>
<tr class="separator:ac9f2e06a142986d71fd4281d1a1c1e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277ae71bc4e95ee236a187a9251f452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8277ae71bc4e95ee236a187a9251f452">resize</a> (size_type n)</td></tr>
<tr class="memdesc:a8277ae71bc4e95ee236a187a9251f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the string to count characters transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8277ae71bc4e95ee236a187a9251f452">More...</a><br /></td></tr>
<tr class="separator:a8277ae71bc4e95ee236a187a9251f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb5f5ee3bf50b379aea23497bbd1643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4eb5f5ee3bf50b379aea23497bbd1643">reserve</a> (size_type new_cap=0)</td></tr>
<tr class="memdesc:a4eb5f5ee3bf50b379aea23497bbd1643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the string to new_cap transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a4eb5f5ee3bf50b379aea23497bbd1643">More...</a><br /></td></tr>
<tr class="separator:a4eb5f5ee3bf50b379aea23497bbd1643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce135d86a3cb44379de7d00d174d3d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abce135d86a3cb44379de7d00d174d3d5">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:abce135d86a3cb44379de7d00d174d3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused capacity transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abce135d86a3cb44379de7d00d174d3d5">More...</a><br /></td></tr>
<tr class="separator:abce135d86a3cb44379de7d00d174d3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48a06395ce0af510bbea55c0805ce07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab48a06395ce0af510bbea55c0805ce07">clear</a> ()</td></tr>
<tr class="memdesc:ab48a06395ce0af510bbea55c0805ce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all characters from the string transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab48a06395ce0af510bbea55c0805ce07">More...</a><br /></td></tr>
<tr class="separator:ab48a06395ce0af510bbea55c0805ce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271994efb0040688a3feb7d5392c253b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a271994efb0040688a3feb7d5392c253b">erase</a> (size_type index=0, size_type count=npos)</td></tr>
<tr class="memdesc:a271994efb0040688a3feb7d5392c253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters from string starting at index transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a271994efb0040688a3feb7d5392c253b">More...</a><br /></td></tr>
<tr class="separator:a271994efb0040688a3feb7d5392c253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94c51bfd094b006063e77603cad10f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad94c51bfd094b006063e77603cad10f3">erase</a> (const_iterator pos)</td></tr>
<tr class="memdesc:ad94c51bfd094b006063e77603cad10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove character from string at pos position transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad94c51bfd094b006063e77603cad10f3">More...</a><br /></td></tr>
<tr class="separator:ad94c51bfd094b006063e77603cad10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efe18b1b78afcfaf8b715daa3276a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2efe18b1b78afcfaf8b715daa3276a49">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:a2efe18b1b78afcfaf8b715daa3276a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters from string at [first, last) range transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2efe18b1b78afcfaf8b715daa3276a49">More...</a><br /></td></tr>
<tr class="separator:a2efe18b1b78afcfaf8b715daa3276a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a254b366ac8a14024171dafe32336b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;			  !std::is_convertible&lt;T, size_type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af4a254b366ac8a14024171dafe32336b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af4a254b366ac8a14024171dafe32336b">erase</a> (T param)</td></tr>
<tr class="memdesc:af4a254b366ac8a14024171dafe32336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Participate in overload resulution only if T is not convertible to size_type.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#af4a254b366ac8a14024171dafe32336b">More...</a><br /></td></tr>
<tr class="separator:af4a254b366ac8a14024171dafe32336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dbad2006284b8c56352fb3830223cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad8dbad2006284b8c56352fb3830223cc">append</a> (size_type count, CharT ch)</td></tr>
<tr class="memdesc:ad8dbad2006284b8c56352fb3830223cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append count copies of character ch to the string transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad8dbad2006284b8c56352fb3830223cc">More...</a><br /></td></tr>
<tr class="separator:ad8dbad2006284b8c56352fb3830223cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa030fc48fb50b22f97b83dc92e3c0375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa030fc48fb50b22f97b83dc92e3c0375">append</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str)</td></tr>
<tr class="memdesc:aa030fc48fb50b22f97b83dc92e3c0375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append string str transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa030fc48fb50b22f97b83dc92e3c0375">More...</a><br /></td></tr>
<tr class="separator:aa030fc48fb50b22f97b83dc92e3c0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb74e7c883572ffd23212cc373a6ae21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aeb74e7c883572ffd23212cc373a6ae21">append</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;str, size_type pos, size_type count=npos)</td></tr>
<tr class="memdesc:aeb74e7c883572ffd23212cc373a6ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append substring [pos, pos + count) of str string transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aeb74e7c883572ffd23212cc373a6ae21">More...</a><br /></td></tr>
<tr class="separator:aeb74e7c883572ffd23212cc373a6ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc34ce145038070a7ff4236cd44f741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abdc34ce145038070a7ff4236cd44f741">append</a> (const CharT *s, size_type count)</td></tr>
<tr class="memdesc:abdc34ce145038070a7ff4236cd44f741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters in the range [s, s + count) transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abdc34ce145038070a7ff4236cd44f741">More...</a><br /></td></tr>
<tr class="separator:abdc34ce145038070a7ff4236cd44f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab683cabdae64c92252c98aa6502be6ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab683cabdae64c92252c98aa6502be6ec">append</a> (const CharT *s)</td></tr>
<tr class="memdesc:ab683cabdae64c92252c98aa6502be6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append C-style string transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab683cabdae64c92252c98aa6502be6ec">More...</a><br /></td></tr>
<tr class="separator:ab683cabdae64c92252c98aa6502be6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1407ac483de831d458c605ead38a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf1407ac483de831d458c605ead38a88">append</a> (std::initializer_list&lt; CharT &gt; ilist)</td></tr>
<tr class="memdesc:aaf1407ac483de831d458c605ead38a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters from the ilist initializer list transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf1407ac483de831d458c605ead38a88">More...</a><br /></td></tr>
<tr class="separator:aaf1407ac483de831d458c605ead38a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037abcc78fa96219dc1a24587d628de6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a037abcc78fa96219dc1a24587d628de6">compare</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other) const</td></tr>
<tr class="memdesc:a037abcc78fa96219dc1a24587d628de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this string to other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a037abcc78fa96219dc1a24587d628de6">More...</a><br /></td></tr>
<tr class="separator:a037abcc78fa96219dc1a24587d628de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c804f16487c05db4208fe1d29224c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac74c804f16487c05db4208fe1d29224c">compare</a> (const std::basic_string&lt; CharT &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac74c804f16487c05db4208fe1d29224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this string to std::basic_string&lt;CharT&gt; other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac74c804f16487c05db4208fe1d29224c">More...</a><br /></td></tr>
<tr class="separator:ac74c804f16487c05db4208fe1d29224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a06c0ef69676e35b6bd3cfdce3762e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa1a06c0ef69676e35b6bd3cfdce3762e">compare</a> (size_type pos, size_type count, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1a06c0ef69676e35b6bd3cfdce3762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count) substring of this to other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa1a06c0ef69676e35b6bd3cfdce3762e">More...</a><br /></td></tr>
<tr class="separator:aa1a06c0ef69676e35b6bd3cfdce3762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcef57c33ff14f67e4651119c4d3d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a3bcef57c33ff14f67e4651119c4d3d55">compare</a> (size_type pos, size_type count, const std::basic_string&lt; CharT &gt; &amp;other) const</td></tr>
<tr class="memdesc:a3bcef57c33ff14f67e4651119c4d3d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count) substring of this to std::basic_string&lt;CharT&gt; other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a3bcef57c33ff14f67e4651119c4d3d55">More...</a><br /></td></tr>
<tr class="separator:a3bcef57c33ff14f67e4651119c4d3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3ed854a3ed1e5ebf5f7fb7569209e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aad3ed854a3ed1e5ebf5f7fb7569209e4">compare</a> (size_type pos1, size_type count1, const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other, size_type pos2, size_type count2=npos) const</td></tr>
<tr class="memdesc:aad3ed854a3ed1e5ebf5f7fb7569209e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aad3ed854a3ed1e5ebf5f7fb7569209e4">More...</a><br /></td></tr>
<tr class="separator:aad3ed854a3ed1e5ebf5f7fb7569209e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f371ce3428c15e1547a7b055c49850d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1f371ce3428c15e1547a7b055c49850d">compare</a> (size_type pos1, size_type count1, const std::basic_string&lt; CharT &gt; &amp;other, size_type pos2, size_type count2=npos) const</td></tr>
<tr class="memdesc:a1f371ce3428c15e1547a7b055c49850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of std::basic_string&lt;CharT&gt; other.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1f371ce3428c15e1547a7b055c49850d">More...</a><br /></td></tr>
<tr class="separator:a1f371ce3428c15e1547a7b055c49850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dfaa2fc3d30c4b615bb345c5a900ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a26dfaa2fc3d30c4b615bb345c5a900ac">compare</a> (const CharT *s) const</td></tr>
<tr class="memdesc:a26dfaa2fc3d30c4b615bb345c5a900ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this string to s.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a26dfaa2fc3d30c4b615bb345c5a900ac">More...</a><br /></td></tr>
<tr class="separator:a26dfaa2fc3d30c4b615bb345c5a900ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769eb94ffb310cdc279191c27df73cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad769eb94ffb310cdc279191c27df73cd">compare</a> (size_type pos, size_type count, const CharT *s) const</td></tr>
<tr class="memdesc:ad769eb94ffb310cdc279191c27df73cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count) substring of this to s.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad769eb94ffb310cdc279191c27df73cd">More...</a><br /></td></tr>
<tr class="separator:ad769eb94ffb310cdc279191c27df73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763cffb1f2439ca5fb0a107142fb15f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a763cffb1f2439ca5fb0a107142fb15f5">compare</a> (size_type pos, size_type count1, const CharT *s, size_type count2) const</td></tr>
<tr class="memdesc:a763cffb1f2439ca5fb0a107142fb15f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares [pos, pos + count1) substring of this to [s, s + count2) substring of s.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a763cffb1f2439ca5fb0a107142fb15f5">More...</a><br /></td></tr>
<tr class="separator:a763cffb1f2439ca5fb0a107142fb15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9454e658d7ff8cb2244bdcb2338e658"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable &gt; </td></tr>
<tr class="memitem:ae9454e658d7ff8cb2244bdcb2338e658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae9454e658d7ff8cb2244bdcb2338e658">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ae9454e658d7ff8cb2244bdcb2338e658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with copies of elements in the range [first, last) transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae9454e658d7ff8cb2244bdcb2338e658">More...</a><br /></td></tr>
<tr class="separator:ae9454e658d7ff8cb2244bdcb2338e658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb50bb73a285a1086ba23f7766b36f7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable &gt; </td></tr>
<tr class="memitem:aaeb50bb73a285a1086ba23f7766b36f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaeb50bb73a285a1086ba23f7766b36f7">append</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:aaeb50bb73a285a1086ba23f7766b36f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append characters in the range [first, last) transactionally.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaeb50bb73a285a1086ba23f7766b36f7">More...</a><br /></td></tr>
<tr class="separator:aaeb50bb73a285a1086ba23f7766b36f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdd408b3929ce784004ccc236c085f8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable &gt; </td></tr>
<tr class="memitem:a7bdd408b3929ce784004ccc236c085f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7bdd408b3929ce784004ccc236c085f8">erase</a> (T param)</td></tr>
<tr class="memdesc:a7bdd408b3929ce784004ccc236c085f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Participate in overload resulution only if T is convertible to size_type.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7bdd408b3929ce784004ccc236c085f8">More...</a><br /></td></tr>
<tr class="separator:a7bdd408b3929ce784004ccc236c085f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7a73397ef9970aff7df1e67b3212a3ef"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a7a73397ef9970aff7df1e67b3212a3ef"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7a73397ef9970aff7df1e67b3212a3ef">get_size</a> (InputIt first, InputIt last) const</td></tr>
<tr class="memdesc:a7a73397ef9970aff7df1e67b3212a3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of generic get_size method used to calculate size based on provided parameters.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7a73397ef9970aff7df1e67b3212a3ef">More...</a><br /></td></tr>
<tr class="separator:a7a73397ef9970aff7df1e67b3212a3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4e4fe677319c6477085637e5b178c3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1d4e4fe677319c6477085637e5b178c3">get_size</a> (size_type count, value_type ch) const</td></tr>
<tr class="memdesc:a1d4e4fe677319c6477085637e5b178c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of generic get_size method used to calculate size based on provided parameters.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a1d4e4fe677319c6477085637e5b178c3">More...</a><br /></td></tr>
<tr class="separator:a1d4e4fe677319c6477085637e5b178c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a54981fd56128506298de2317e5b4f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a78a54981fd56128506298de2317e5b4f">get_size</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;other) const</td></tr>
<tr class="memdesc:a78a54981fd56128506298de2317e5b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of generic get_size method used to calculate size based on provided parameters.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a78a54981fd56128506298de2317e5b4f">More...</a><br /></td></tr>
<tr class="separator:a78a54981fd56128506298de2317e5b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f3ebbbd4159f48caa7a3cb8de08599"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac5f3ebbbd4159f48caa7a3cb8de08599"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac5f3ebbbd4159f48caa7a3cb8de08599">replace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac5f3ebbbd4159f48caa7a3cb8de08599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function which replaces current content based on provided parameters.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ac5f3ebbbd4159f48caa7a3cb8de08599">More...</a><br /></td></tr>
<tr class="separator:ac5f3ebbbd4159f48caa7a3cb8de08599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04af91240ccce74722307c1c8480be1e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a04af91240ccce74722307c1c8480be1e"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a04af91240ccce74722307c1c8480be1e">initialize</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a04af91240ccce74722307c1c8480be1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function which initializes memory based on provided parameters - forwards parameters to initialize function of either non_sso.data or sso.data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a04af91240ccce74722307c1c8480be1e">More...</a><br /></td></tr>
<tr class="separator:a04af91240ccce74722307c1c8480be1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e6cd3ac6395a99501919abe4091b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9b3e6cd3ac6395a99501919abe4091b5">allocate</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity</a>)</td></tr>
<tr class="memdesc:a9b3e6cd3ac6395a99501919abe4091b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for container of capacity bytes.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9b3e6cd3ac6395a99501919abe4091b5">More...</a><br /></td></tr>
<tr class="separator:a9b3e6cd3ac6395a99501919abe4091b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d811ceb9088d3cc3a21ab89195a492"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a11d811ceb9088d3cc3a21ab89195a492"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a11d811ceb9088d3cc3a21ab89195a492">assign_sso_data</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a11d811ceb9088d3cc3a21ab89195a492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sso data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a11d811ceb9088d3cc3a21ab89195a492">More...</a><br /></td></tr>
<tr class="separator:a11d811ceb9088d3cc3a21ab89195a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324dcc22b9a9645f6dda753b5dea1d0a"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a324dcc22b9a9645f6dda753b5dea1d0a">assign_sso_data</a> (size_type count, value_type ch)</td></tr>
<tr class="memdesc:a324dcc22b9a9645f6dda753b5dea1d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sso data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a324dcc22b9a9645f6dda753b5dea1d0a">More...</a><br /></td></tr>
<tr class="separator:a324dcc22b9a9645f6dda753b5dea1d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe08fb402d6b54fbeb39b37873a46438"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abe08fb402d6b54fbeb39b37873a46438">assign_sso_data</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:abe08fb402d6b54fbeb39b37873a46438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sso data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#abe08fb402d6b54fbeb39b37873a46438">More...</a><br /></td></tr>
<tr class="separator:abe08fb402d6b54fbeb39b37873a46438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Enable  = typename std::enable_if&lt;			pmem::detail::is_input_iterator&lt;InputIt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="memTemplItemLeft" align="right" valign="top">pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9a8a9b74ac31f6d51d3ec7bc39608d28">assign_large_data</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize non_sso.data - call constructor of non_sso.data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9a8a9b74ac31f6d51d3ec7bc39608d28">More...</a><br /></td></tr>
<tr class="separator:a9a8a9b74ac31f6d51d3ec7bc39608d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec5e26ebc171a87b8c2c1f86c478cd"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad3ec5e26ebc171a87b8c2c1f86c478cd">assign_large_data</a> (size_type count, value_type ch)</td></tr>
<tr class="memdesc:ad3ec5e26ebc171a87b8c2c1f86c478cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize non_sso.data - call constructor of non_sso.data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad3ec5e26ebc171a87b8c2c1f86c478cd">More...</a><br /></td></tr>
<tr class="separator:ad3ec5e26ebc171a87b8c2c1f86c478cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf74f8756e3419052aaa769b6ddf6879"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf74f8756e3419052aaa769b6ddf6879">assign_large_data</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aaf74f8756e3419052aaa769b6ddf6879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize non_sso.data - call constructor of non_sso.data.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aaf74f8756e3419052aaa769b6ddf6879">More...</a><br /></td></tr>
<tr class="separator:aaf74f8756e3419052aaa769b6ddf6879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d5a536acb228fc3beb1a90bf36658"><td class="memItemLeft" align="right" valign="top"><a id="a464d5a536acb228fc3beb1a90bf36658"></a>
<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a464d5a536acb228fc3beb1a90bf36658">get_pool</a> () const</td></tr>
<tr class="memdesc:a464d5a536acb228fc3beb1a90bf36658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class.">pool_base</a> instance and assert that object is on pmem. <br /></td></tr>
<tr class="separator:a464d5a536acb228fc3beb1a90bf36658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e98e3724230ea38be1c64a5d37fcd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a8e98e3724230ea38be1c64a5d37fcd23">check_pmem</a> () const</td></tr>
<tr class="separator:a8e98e3724230ea38be1c64a5d37fcd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe6cb60642353c8b1ced86492d94513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#acbe6cb60642353c8b1ced86492d94513">check_tx_stage_work</a> () const</td></tr>
<tr class="separator:acbe6cb60642353c8b1ced86492d94513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f220a35a83a3f4d1770b022c7d82043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a9f220a35a83a3f4d1770b022c7d82043">check_pmem_tx</a> () const</td></tr>
<tr class="separator:a9f220a35a83a3f4d1770b022c7d82043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54af95f032a30fdfd1644f4f6219b267"><td class="memItemLeft" align="right" valign="top"><a id="a54af95f032a30fdfd1644f4f6219b267"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a54af95f032a30fdfd1644f4f6219b267">snapshot_sso</a> () const</td></tr>
<tr class="memdesc:a54af95f032a30fdfd1644f4f6219b267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot sso data. <br /></td></tr>
<tr class="separator:a54af95f032a30fdfd1644f4f6219b267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8ed5036d8df793db33592de6a946f7"><td class="memItemLeft" align="right" valign="top"><a id="a6e8ed5036d8df793db33592de6a946f7"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a6e8ed5036d8df793db33592de6a946f7">get_sso_size</a> () const</td></tr>
<tr class="memdesc:a6e8ed5036d8df793db33592de6a946f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of sso string. <br /></td></tr>
<tr class="separator:a6e8ed5036d8df793db33592de6a946f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510f39d64c6f3385a834287d0810d88"><td class="memItemLeft" align="right" valign="top"><a id="ad510f39d64c6f3385a834287d0810d88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad510f39d64c6f3385a834287d0810d88">enable_sso</a> ()</td></tr>
<tr class="memdesc:ad510f39d64c6f3385a834287d0810d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable sso string. <br /></td></tr>
<tr class="separator:ad510f39d64c6f3385a834287d0810d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fe00a2770ad0554a4b156df49effc7"><td class="memItemLeft" align="right" valign="top"><a id="a94fe00a2770ad0554a4b156df49effc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a94fe00a2770ad0554a4b156df49effc7">disable_sso</a> ()</td></tr>
<tr class="memdesc:a94fe00a2770ad0554a4b156df49effc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sso string. <br /></td></tr>
<tr class="separator:a94fe00a2770ad0554a4b156df49effc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3bc6dde318282d9ebeb8a696678665"><td class="memItemLeft" align="right" valign="top"><a id="a7d3bc6dde318282d9ebeb8a696678665"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a7d3bc6dde318282d9ebeb8a696678665">set_sso_size</a> (size_type new_size)</td></tr>
<tr class="memdesc:a7d3bc6dde318282d9ebeb8a696678665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size for sso. <br /></td></tr>
<tr class="separator:a7d3bc6dde318282d9ebeb8a696678665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2560487847d51b525572657ca25c0638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2560487847d51b525572657ca25c0638">sso_to_large</a> (size_t new_capacity)</td></tr>
<tr class="memdesc:a2560487847d51b525572657ca25c0638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize sso string to large string.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a2560487847d51b525572657ca25c0638">More...</a><br /></td></tr>
<tr class="separator:a2560487847d51b525572657ca25c0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14112c493bbcf4cc127095cfc4c6f53e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a14112c493bbcf4cc127095cfc4c6f53e">large_to_sso</a> ()</td></tr>
<tr class="memdesc:a14112c493bbcf4cc127095cfc4c6f53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize large string to sso string of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> size.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a14112c493bbcf4cc127095cfc4c6f53e">More...</a><br /></td></tr>
<tr class="separator:a14112c493bbcf4cc127095cfc4c6f53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="memItemLeft" >union {</td></tr>
<tr class="memitem:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This union holds sso data inside of an array and non sso data inside a vector.  <a href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a87ed0f5bec8217c4235bd9e5185e1ffe">More...</a><br /></td></tr>
<tr class="separator:a87ed0f5bec8217c4235bd9e5185e1ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt;<br />
class pmem::obj::experimental::basic_string&lt; CharT, Traits &gt;</h3>

<p>pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible interface. </p>
<p>The implementation is NOT complete. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7d13876f6b7705e0dfdae08acacfaa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d13876f6b7705e0dfdae08acacfaa7f">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Construct an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49c936dff4606f9e09cf178c0d3359e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c936dff4606f9e09cf178c0d3359e2">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the container with count copies of elements with value ch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf58e1bcd43a7213f5fbd44bce006b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf58e1bcd43a7213f5fbd44bce006b21">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with a substring [pos, min(pos+count, other.size()) of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8cd193ab8204565648bb5ca999cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8cd193ab8204565648bb5ca999cd50">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with a substring [pos, min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89a255c1d207f2773e1d95c33fc57f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a255c1d207f2773e1d95c33fc57f4b">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with the first count elements of C-style string s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the resulting string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f174d78e65b57d2a81cd3a31d677fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f174d78e65b57d2a81cd3a31d677fca">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with the contents of s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46adde6ad12bdfd544e6e1d5204bc665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46adde6ad12bdfd544e6e1d5204bc665">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the string with the contents of the range [first, last). </p>
<p>This constructor only participates in overload resolution if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to end of the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a062405734d14101836de1617cfaa088c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062405734d14101836de1617cfaa088c">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Construct the string with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c7b15b783291d3bd60ffbc7490e761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7b15b783291d3bd60ffbc7490e761c">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Construct the string with the copy of the contents of std::basic_string&lt;CharT&gt; other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the std::basic_string&lt;CharT&gt; to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4233c850af185b3c164d3749b0455fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4233c850af185b3c164d3749b0455fe">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Construct the string with the contents of other using move semantics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the string to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a1f3c8d134020fb77020005d68f6f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1f3c8d134020fb77020005d68f6f7d">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2846936f4c528d98782ac959020347a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2846936f4c528d98782ac959020347a">&#9670;&nbsp;</a></span>~basic_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::~<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>XXX: implement free_data() </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b3e6cd3ac6395a99501919abe4091b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3e6cd3ac6395a99501919abe4091b5">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate storage for container of capacity bytes. </p>
<p>Based on capacity determine if sso or large string is used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>data must be uninitialized. </dd>
<dd>
must be called in transaction scope.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa030fc48fb50b22f97b83dc92e3c0375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa030fc48fb50b22f97b83dc92e3c0375">&#9670;&nbsp;</a></span>append() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append string str transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + str.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb74e7c883572ffd23212cc373a6ae21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb74e7c883572ffd23212cc373a6ae21">&#9670;&nbsp;</a></span>append() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append substring [pos, pos + count) of str string transactionally. </p>
<p>Length of the string to append is determined as the smaller of count and str.size() - pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>index of the first character to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos &lt;= str.size()</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::min(count, str.size() - pos). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos &gt; str.size(). </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab683cabdae64c92252c98aa6502be6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab683cabdae64c92252c98aa6502be6ec">&#9670;&nbsp;</a></span>append() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append C-style string transactionally. </p>
<p>Length of the string is determined by the first null character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + traits::length(s). </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc34ce145038070a7ff4236cd44f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc34ce145038070a7ff4236cd44f741">&#9670;&nbsp;</a></span>append() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters in the range [s, s + count) transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to C-style string to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeb50bb73a285a1086ba23f7766b36f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb50bb73a285a1086ba23f7766b36f7">&#9670;&nbsp;</a></span>append() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters in the range [first, last) transactionally. </p>
<p>This overload participates in overload resolution only if InputIt qualifies as InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8dbad2006284b8c56352fb3830223cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dbad2006284b8c56352fb3830223cc">&#9670;&nbsp;</a></span>append() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append count copies of character ch to the string transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character value to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1407ac483de831d458c605ead38a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1407ac483de831d458c605ead38a88">&#9670;&nbsp;</a></span>append() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append characters from the ilist initializer list transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer list with characters to append from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> + std::distance(<a class="el" href="array_8hpp.html#ad806dbb16c66eb3055bd249dbd675726" title="Non-member begin.">ilist.begin()</a>, <a class="el" href="array_8hpp.html#a51fbfe71ad89d817a95b324aac1d4a1b" title="Non-member end.">ilist.end()</a>) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == sso_capacity if new size is less than or equal to sso_capacity, or the smallest next power of 2, bigger than new size if it is greater than old capacity, or remains the same if there is enough space to store all new elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4ce02d1ea4365b52365d4803410293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4ce02d1ea4365b52365d4803410293">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string with the contents of other using move semantics transactionally. </p>
<p>Other is left in valid state with size equal to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the string to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a852c852210485a71e0827ed0e3037762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852c852210485a71e0827ed0e3037762">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string with the copy of the contents of other transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d79b5ecc846ec185a33c4a4468312dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d79b5ecc846ec185a33c4a4468312dc">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with a substring [pos, std::min(pos+count, other.size()) of other transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fe2bc8a8e9ca67e19e001ca6613d819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe2bc8a8e9ca67e19e001ca6613d819">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with copy of C-style string s transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adabefb7329119f1f5d0e479bbe7f9668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabefb7329119f1f5d0e479bbe7f9668">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with the first count elements of C-style string s transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd36b026a014784c8fd5a9ecb7fd5b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd36b026a014784c8fd5a9ecb7fd5b91">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the string with the copy of the contents of std::basic_string&lt;CharT&gt; other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the std::basic_string&lt;CharT&gt; to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0035d5d07c15fcedd54b5ede00e7c298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0035d5d07c15fcedd54b5ede00e7c298">&#9670;&nbsp;</a></span>assign() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with a substring [pos, std::min(pos+count, other.size()) of std::basic_string&lt;CharT&gt; other transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; from which substring will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>start position of substring in other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; other.size() </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9454e658d7ff8cb2244bdcb2338e658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9454e658d7ff8cb2244bdcb2338e658">&#9670;&nbsp;</a></span>assign() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with copies of elements in the range [first, last) transactionally. </p>
<p>This function participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to end of the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01745c1b661b5977eda2f441e591cadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01745c1b661b5977eda2f441e591cadf">&#9670;&nbsp;</a></span>assign() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with count copies of character ch transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac70f97749d40640d52cebf64762a40c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70f97749d40640d52cebf64762a40c7">&#9670;&nbsp;</a></span>assign() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents with those of the initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer_list of characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf74f8756e3419052aaa769b6ddf6879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf74f8756e3419052aaa769b6ddf6879">&#9670;&nbsp;</a></span>assign_large_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_large_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize non_sso.data - call constructor of non_sso.data. </p>
<p>Overload for rvalue reference of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a>. </p>

</div>
</div>
<a id="a9a8a9b74ac31f6d51d3ec7bc39608d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a9b74ac31f6d51d3ec7bc39608d28">&#9670;&nbsp;</a></span>assign_large_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_large_data </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize non_sso.data - call constructor of non_sso.data. </p>
<p>Overload for pair of iterators. </p>

</div>
</div>
<a id="ad3ec5e26ebc171a87b8c2c1f86c478cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ec5e26ebc171a87b8c2c1f86c478cd">&#9670;&nbsp;</a></span>assign_large_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_large_data </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize non_sso.data - call constructor of non_sso.data. </p>
<p>Overload for (count, value). </p>

</div>
</div>
<a id="abe08fb402d6b54fbeb39b37873a46438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe08fb402d6b54fbeb39b37873a46438">&#9670;&nbsp;</a></span>assign_sso_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_sso_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sso data. </p>
<p>Overload for rvalue reference of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a>. </p>

</div>
</div>
<a id="a11d811ceb9088d3cc3a21ab89195a492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d811ceb9088d3cc3a21ab89195a492">&#9670;&nbsp;</a></span>assign_sso_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_sso_data </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sso data. </p>
<p>Overload for pair of iterators </p>

</div>
</div>
<a id="a324dcc22b9a9645f6dda753b5dea1d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324dcc22b9a9645f6dda753b5dea1d0a">&#9670;&nbsp;</a></span>assign_sso_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::assign_sso_data </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sso data. </p>
<p>Overload for (count, value). </p>

</div>
</div>
<a id="a114ee8aa04b5200d10589ca9d8ace785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114ee8aa04b5200d10589ca9d8ace785">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking and snapshot it if there is an active transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc7c8867a952de3388819e8b911347d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc7c8867a952de3388819e8b911347d">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf75feee0c5a6d8b5dec8dd9cde24bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf75feee0c5a6d8b5dec8dd9cde24bed">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element and snapshot it if there is an active transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to last element in string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4dfa7c2d10786a2837a36981b4b1440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dfa7c2d10786a2837a36981b4b1440">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to last element in string. </dd></dl>

</div>
</div>
<a id="ae84575172811e6af3fa4735f6c98fb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84575172811e6af3fa4735f6c98fb46">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first element in the string. </dd></dl>

</div>
</div>
<a id="ae6b726ea004e140eaedd644510a34fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b726ea004e140eaedd644510a34fe4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const iterator pointing to the first element in the string. </dd></dl>

</div>
</div>
<a id="a92e9ca34c0b5b017cd5817360930e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e9ca34c0b5b017cd5817360930e152">&#9670;&nbsp;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::c_str</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>pointer to underlying data. </dd></dl>

</div>
</div>
<a id="ae688b8f07ddcd5314de694e4ef91dad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae688b8f07ddcd5314de694e4ef91dad8">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of characters that can be held in currently allocated storage. </dd></dl>

</div>
</div>
<a id="a37b9e19d268d06cfbdae3d274a99da02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b9e19d268d06cfbdae3d274a99da02">&#9670;&nbsp;</a></span>cback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adf75feee0c5a6d8b5dec8dd9cde24bed" title="Access last element and snapshot it if there is an active transaction.">back()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02" title="Access last element.">cback()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::basic_string doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a37b9e19d268d06cfbdae3d274a99da02" title="Access last element.">cback()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const reference to last element in string. </dd></dl>

</div>
</div>
<a id="a5b8faca84731379e1ff9c794643b2e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8faca84731379e1ff9c794643b2e33">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cbegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const iterator pointing to the first element in the string. </dd></dl>

</div>
</div>
<a id="a924a8b0829e7c20a71a322f7507dc966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a8b0829e7c20a71a322f7507dc966">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cdata</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const pointer to underlying data. </dd></dl>

</div>
</div>
<a id="aa8f708491eb1ba92834e12a25b3b273f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f708491eb1ba92834e12a25b3b273f">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the string. </dd></dl>

</div>
</div>
<a id="adb2e2613e5b2cb491cddd071bc7d3b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e2613e5b2cb491cddd071bc7d3b39">&#9670;&nbsp;</a></span>cfront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::cfront</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a0a95614480a2ad9c7fa4279c7ff7a40f" title="Access first element and snapshot it if there is an active transaction.">front()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39" title="Access first element.">cfront()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::basic_string doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#adb2e2613e5b2cb491cddd071bc7d3b39" title="Access first element.">cfront()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const reference to first element in string. </dd></dl>

</div>
</div>
<a id="a8e98e3724230ea38be1c64a5d37fcd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e98e3724230ea38be1c64a5d37fcd23">&#9670;&nbsp;</a></span>check_pmem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::check_pmem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f220a35a83a3f4d1770b022c7d82043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f220a35a83a3f4d1770b022c7d82043">&#9670;&nbsp;</a></span>check_pmem_tx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::check_pmem_tx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if called outside of a transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbe6cb60642353c8b1ced86492d94513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe6cb60642353c8b1ced86492d94513">&#9670;&nbsp;</a></span>check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::check_tx_stage_work</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>if called outside of a transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab48a06395ce0af510bbea55c0805ce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48a06395ce0af510bbea55c0805ce07">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all characters from the string transactionally. </p>
<p>All pointers, references, and iterators are invalidated.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037abcc78fa96219dc1a24587d628de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037abcc78fa96219dc1a24587d628de6">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this string to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if *this &lt; other in lexicographical order, zero if *this == other and positive value if *this &gt; other. </dd></dl>

</div>
</div>
<a id="a26dfaa2fc3d30c4b615bb345c5a900ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dfaa2fc3d30c4b615bb345c5a900ac">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this string to s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>C-style string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if *this &lt; s in lexicographical order, zero if *this == s and positive value if *this &gt; s. </dd></dl>

</div>
</div>
<a id="ac74c804f16487c05db4208fe1d29224c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c804f16487c05db4208fe1d29224c">&#9670;&nbsp;</a></span>compare() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this string to std::basic_string&lt;CharT&gt; other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if *this &lt; other in lexicographical order, zero if *this == other and positive value if *this &gt; other. </dd></dl>

</div>
</div>
<a id="aa1a06c0ef69676e35b6bd3cfdce3762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a06c0ef69676e35b6bd3cfdce3762e">&#9670;&nbsp;</a></span>compare() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count) substring of this to other. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring &lt; other in lexicographical order, zero if substring == other and positive value if substring &gt; other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad769eb94ffb310cdc279191c27df73cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad769eb94ffb310cdc279191c27df73cd">&#9670;&nbsp;</a></span>compare() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count) substring of this to s. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>C-style string to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring &lt; s in lexicographical order, zero if substring == s and positive value if substring &gt; s.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bcef57c33ff14f67e4651119c4d3d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcef57c33ff14f67e4651119c4d3d55">&#9670;&nbsp;</a></span>compare() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count) substring of this to std::basic_string&lt;CharT&gt; other. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>length of the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring &lt; other in lexicographical order, zero if substring == other and positive value if substring &gt; other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a763cffb1f2439ca5fb0a107142fb15f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763cffb1f2439ca5fb0a107142fb15f5">&#9670;&nbsp;</a></span>compare() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos, pos + count1) substring of this to [s, s + count2) substring of s. </p>
<p>If count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>beginning of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count1</td><td>length of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>C-style string to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of substring of s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring of *this &lt; substring of s in lexicographical order, zero if substring of *this == substring of s and positive value if substring of *this &gt; substring of s.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad3ed854a3ed1e5ebf5f7fb7569209e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3ed854a3ed1e5ebf5f7fb7569209e4">&#9670;&nbsp;</a></span>compare() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of other. </p>
<p>If count1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos1, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos1</td><td>beginning of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count1</td><td>length of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>string to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos2</td><td>beginning of substring of other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of substring of other.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring of *this &lt; substring of other in lexicographical order, zero if substring of *this == substring of other and positive value if substring of *this &gt; substring of other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> or pos2 &gt; other.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f371ce3428c15e1547a7b055c49850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f371ce3428c15e1547a7b055c49850d">&#9670;&nbsp;</a></span>compare() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count2</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares [pos1, pos1 + count1) substring of this to [pos2, pos2 + count2) substring of std::basic_string&lt;CharT&gt; other. </p>
<p>If count1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - pos, substring is equal to [pos1, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos1</td><td>beginning of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count1</td><td>length of substring of this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>std::basic_string&lt;CharT&gt; to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos2</td><td>beginning of substring of other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count2</td><td>length of substring of other.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative value if substring of *this &lt; substring of other in lexicographical order, zero if substring of *this == substring of other and positive value if substring of *this &gt; substring of other.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is pos1 &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> or pos2 &gt; other.size() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6347729401d23409ae8e3c20cbbdfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6347729401d23409ae8e3c20cbbdfa4">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a114ee8aa04b5200d10589ca9d8ace785" title="Access element at specific index with bounds checking and snapshot it if there is an active transacti...">at()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4" title="Access element at specific index with bounds checking.">const_at()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::basic_string doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ab6347729401d23409ae8e3c20cbbdfa4" title="Access element at specific index with bounds checking.">const_at()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a550ba03ad47efe24c30fff1b4c2548b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ba03ad47efe24c30fff1b4c2548b7">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::crbegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reverse iterator pointing to the last element in non-reversed string. </dd></dl>

</div>
</div>
<a id="a2d27e932b80a8f6572055fdbca5fa368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d27e932b80a8f6572055fdbca5fa368">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::crend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const reverse iterator referring to character preceding first character in the non-reversed string. </dd></dl>

</div>
</div>
<a id="abe1c0f6e18623b888cb65dae95a9d79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1c0f6e18623b888cb65dae95a9d79d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if string is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a526ba2aa7a34084c46018888f67cc9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526ba2aa7a34084c46018888f67cc9d4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the string. </dd></dl>

</div>
</div>
<a id="a0e2c8133289e2290e7d476eb65294f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c8133289e2290e7d476eb65294f4f">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the string. </dd></dl>

</div>
</div>
<a id="a2efe18b1b78afcfaf8b715daa3276a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efe18b1b78afcfaf8b715daa3276a49">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove characters from string at [first, last) range transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>begin of the range of characters to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>end of the range of characters to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator which points to the element pointed by the last iterator before the erase operation. If no such element exists then <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4" title="Return an iterator to past the end.">end()</a> iterator is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>first and last are valid iterators on *this.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if [first, last) is not a valid range of *this. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad94c51bfd094b006063e77603cad10f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94c51bfd094b006063e77603cad10f3">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove character from string at pos position transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>position of character to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the removed element. If the iterator pos refers to the last element, the <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a526ba2aa7a34084c46018888f67cc9d4" title="Return an iterator to past the end.">end()</a> iterator is returned.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - 1</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a271994efb0040688a3feb7d5392c253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271994efb0040688a3feb7d5392c253b">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove characters from string starting at index transactionally. </p>
<p>Length of the string to erase is determined as the smaller of count and <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>first character to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of characters to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>index &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> = <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - std::min(count, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> - index)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4a254b366ac8a14024171dafe32336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a254b366ac8a14024171dafe32336b">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Participate in overload resulution only if T is not convertible to size_type. </p>
<p>Call iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ad94c51bfd094b006063e77603cad10f3" title="Remove character from string at pos position transactionally.">erase(const_iterator pos)</a> if enabled. </p>

</div>
</div>
<a id="a7bdd408b3929ce784004ccc236c085f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdd408b3929ce784004ccc236c085f8">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt;CharT, Traits&gt;&amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Participate in overload resulution only if T is convertible to size_type. </p>
<p>Call <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;erase(size_type index, size_type count = npos) if enabled. </p>

</div>
</div>
<a id="a0a95614480a2ad9c7fa4279c7ff7a40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a95614480a2ad9c7fa4279c7ff7a40f">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element and snapshot it if there is an active transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1290019d34af257ce831aa51800f4c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1290019d34af257ce831aa51800f4c1f">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const CharT &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to first element in string. </dd></dl>

</div>
</div>
<a id="a78a54981fd56128506298de2317e5b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a54981fd56128506298de2317e5b4f">&#9670;&nbsp;</a></span>get_size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of generic get_size method used to calculate size based on provided parameters. </p>
<p>Return size of other <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> </p>

</div>
</div>
<a id="a7a73397ef9970aff7df1e67b3212a3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a73397ef9970aff7df1e67b3212a3ef">&#9670;&nbsp;</a></span>get_size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename Enable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of generic get_size method used to calculate size based on provided parameters. </p>
<p>Return std::distance(first, last) for pair of iterators. </p>

</div>
</div>
<a id="a1d4e4fe677319c6477085637e5b178c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4e4fe677319c6477085637e5b178c3">&#9670;&nbsp;</a></span>get_size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of generic get_size method used to calculate size based on provided parameters. </p>
<p>Return count for (count, value) </p>

</div>
</div>
<a id="a04af91240ccce74722307c1c8480be1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04af91240ccce74722307c1c8480be1e">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function which initializes memory based on provided parameters - forwards parameters to initialize function of either non_sso.data or sso.data. </p>
<p>Allowed parameters are:</p><ul>
<li>size_type count, CharT value</li>
<li>InputIt first, InputIt last</li>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;&amp;</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
memory must be allocated before initialization. </dd></dl>

</div>
</div>
<a id="a14112c493bbcf4cc127095cfc4c6f53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14112c493bbcf4cc127095cfc4c6f53e">&#9670;&nbsp;</a></span>large_to_sso()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::large_to_sso</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize large string to sso string of <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> size. </p>
<p>Content of large string is preserved and copied to the sso string.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> of large string must be less than or equal sso_capacity</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sso is used. </dd></dl>

</div>
</div>
<a id="a7ad312f37adadcbbf3396945fa685165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad312f37adadcbbf3396945fa685165">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of CharT elements in the string. </dd></dl>

</div>
</div>
<a id="aa41f64c4d254dac34bde1a6e475e5585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41f64c4d254dac34bde1a6e475e5585">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the string is able to hold. </dd></dl>

</div>
</div>
<a id="a339651e065a2f36c8f505ff7bc55e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339651e065a2f36c8f505ff7bc55e689">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replace the string with the contents of other using move semantics transactionally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the string to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04d3972852c0ca602af1388d0695c9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d3972852c0ca602af1388d0695c9c2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with character ch transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae25e9887350ba1e523c037e4299613f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25e9887350ba1e523c037e4299613f0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replace the string with contents of other transactionally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the string to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f2724d48368f4c61ab0797075031f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2724d48368f4c61ab0797075031f90">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with copy of C-style string s transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>pointer to source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8880f3c3282290b40a1a548eeaac6395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8880f3c3282290b40a1a548eeaac6395">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Replace the string with contents of std::basic_string&lt;CharT&gt; other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the std::basic_string&lt;CharT&gt; to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43c9ce280f65d22e0d01fd961c8fc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43c9ce280f65d22e0d01fd961c8fc27">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt; &amp; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; CharT &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the contents with those of the initializer list ilist transactionally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>initializer_list of characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying storage in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13a43584f35e464b753766f263b98f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a43584f35e464b753766f263b98f6a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and snapshot it if there is an active transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab59f7eaab5e9a72d3c8794d8857576d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59f7eaab5e9a72d3c8794d8857576d3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array. </dd></dl>

</div>
</div>
<a id="a0930182af8a2448d010aa603c1495326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0930182af8a2448d010aa603c1495326">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>a reverse iterator pointing to the last element in non-reversed string. </dd></dl>

</div>
</div>
<a id="a8fa6e329ea0d45e17a74e880994f947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa6e329ea0d45e17a74e880994f947e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rbegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reverse iterator pointing to the last element in non-reversed string. </dd></dl>

</div>
</div>
<a id="aad1ba265e840da1b926a621ee932e332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1ba265e840da1b926a621ee932e332">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse iterator referring to character preceding first character in the non-reversed string. </dd></dl>

</div>
</div>
<a id="a6e77ec7a6f29e8a004e4e8bbaa262a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e77ec7a6f29e8a004e4e8bbaa262a1c">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::rend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const reverse iterator referring to character preceding first character in the non-reversed string. </dd></dl>

</div>
</div>
<a id="ac5f3ebbbd4159f48caa7a3cb8de08599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f3ebbbd4159f48caa7a3cb8de08599">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::pointer <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function which replaces current content based on provided parameters. </p>
<p>Allowed parameters are:</p><ul>
<li>size_type count, CharT value</li>
<li>InputIt first, InputIt last</li>
<li><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html" title="pmem::obj::experimental::string - EXPERIMENTAL persistent container with std::basic_string compatible...">basic_string</a> &amp;&amp; </li>
</ul>

</div>
</div>
<a id="a4eb5f5ee3bf50b379aea23497bbd1643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb5f5ee3bf50b379aea23497bbd1643">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_cap</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the capacity of the string to new_cap transactionally. </p>
<p>If new_cap is greater than the current <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a>, new storage is allocated, otherwise the method does nothing. If new_cap is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_cap</td><td>new capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == max(capacity(), capacity_new)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new_cap &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9f2e06a142986d71fd4281d1a1c1e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f2e06a142986d71fd4281d1a1c1e67">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the string to count characters transactionally. </p>
<p>If the current size is greater than count, the string is reduced to its first count elements. If the current size is less than count, additional characters of ch value are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>character to initialize elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == std::max(count, capacity()) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a> </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8277ae71bc4e95ee236a187a9251f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8277ae71bc4e95ee236a187a9251f452">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the string to count characters transactionally. </p>
<p>If the current size is greater than count, the string is reduced to its first count elements. If the current size is less than count, additional default-initialized characters are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == std::max(count, capacity()) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#a10d70fe47d10ff8af64ece41610b0c2c">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if count &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#aa41f64c4d254dac34bde1a6e475e5585">max_size()</a> </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce135d86a3cb44379de7d00d174d3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce135d86a3cb44379de7d00d174d3d5">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::shrink_to_fit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unused capacity transactionally. </p>
<p>If large string is used capacity will be set to current size. If sso is used nothing happens.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html#ae688b8f07ddcd5314de694e4ef91dad8">capacity()</a> == std::min(sso_capacity, capacity())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class.">pmem::transaction_alloc_error</a></td><td>when reallocating failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class.">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10d70fe47d10ff8af64ece41610b0c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d70fe47d10ff8af64ece41610b0c2c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">basic_string</a>&lt; CharT, Traits &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of CharT elements in the string. </dd></dl>

</div>
</div>
<a id="a2560487847d51b525572657ca25c0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2560487847d51b525572657ca25c0638">&#9670;&nbsp;</a></span>sso_to_large()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::sso_to_large </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize sso string to large string. </p>
<p>Capacity is equal new_capacity plus sizeof(CharT) bytes for null character. Content of sso string is preserved and copied to the large string object.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sso is not used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_capacity</td><td>capacity of constructed large string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a87ed0f5bec8217c4235bd9e5185e1ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ed0f5bec8217c4235bd9e5185e1ffe">&#9670;&nbsp;</a></span>@3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... } </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This union holds sso data inside of an array and non sso data inside a vector. </p>
<p>If vector is used, it must be manually created and destroyed.</p>
<p>_size is used to store length in case when SSO is used. It is the same type as first member of data field. This means that it can be safely accessed through both sso (_size variable) and non_sso (as size in a vector) no matter which one is used.</p>
<p>C++11 9.2/18 says: If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them. </p>

</div>
</div>
<a id="a89c652d0158c27321e78f21dd449dac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c652d0158c27321e78f21dd449dac7">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CharT * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1basic__string.html">pmem::obj::experimental::basic_string</a>&lt; CharT, Traits &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>pointer to underlying data.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when adding data to the transaction failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to underlying data. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="basic__string_8hpp_source.html">basic_string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
