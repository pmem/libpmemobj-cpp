<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::persistent_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.8.1</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><b>obj</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1persistent__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::persistent_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Persistent pointer class.  
 <a href="classpmem_1_1obj_1_1persistent__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="persistent__ptr_8hpp_source.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5a5f287d06995fe517000650ee35a2a8"><td class="memTemplParams" colspan="2"><a id="a5a5f287d06995fe517000650ee35a2a8"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a5a5f287d06995fe517000650ee35a2a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a5a5f287d06995fe517000650ee35a2a8">rebind</a> = <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; U &gt;</td></tr>
<tr class="memdesc:a5a5f287d06995fe517000650ee35a2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind to a different type of pointer. <br /></td></tr>
<tr class="separator:a5a5f287d06995fe517000650ee35a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b743ee332a992f938b2e086e9f182d"><td class="memItemLeft" align="right" valign="top"><a id="a49b743ee332a992f938b2e086e9f182d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a49b743ee332a992f938b2e086e9f182d">persistency_type</a> = <a class="el" href="classpmem_1_1obj_1_1p.html">p</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a49b743ee332a992f938b2e086e9f182d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The persistency type to be used with this pointer. <br /></td></tr>
<tr class="separator:a49b743ee332a992f938b2e086e9f182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e85a0b982f88b0eeb217cf3c0ad3e35"><td class="memItemLeft" align="right" valign="top"><a id="a3e85a0b982f88b0eeb217cf3c0ad3e35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a3e85a0b982f88b0eeb217cf3c0ad3e35">bool_type</a> = bool</td></tr>
<tr class="memdesc:a3e85a0b982f88b0eeb217cf3c0ad3e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The used bool_type. <br /></td></tr>
<tr class="separator:a3e85a0b982f88b0eeb217cf3c0ad3e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978fa74b702f6d40c235a68103d3e0ff"><td class="memItemLeft" align="right" valign="top"><a id="a978fa74b702f6d40c235a68103d3e0ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a978fa74b702f6d40c235a68103d3e0ff">iterator_category</a> = std::random_access_iterator_tag</td></tr>
<tr class="memdesc:a978fa74b702f6d40c235a68103d3e0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> iterator category. <br /></td></tr>
<tr class="separator:a978fa74b702f6d40c235a68103d3e0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725a74e0fa382ae9cafbe90dbc0c3b7"><td class="memItemLeft" align="right" valign="top"><a id="ad725a74e0fa382ae9cafbe90dbc0c3b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ad725a74e0fa382ae9cafbe90dbc0c3b7">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ad725a74e0fa382ae9cafbe90dbc0c3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> difference type. <br /></td></tr>
<tr class="separator:ad725a74e0fa382ae9cafbe90dbc0c3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ba9ff5c043395ac9cebcb33dae7f21"><td class="memItemLeft" align="right" valign="top"><a id="aa9ba9ff5c043395ac9cebcb33dae7f21"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aa9ba9ff5c043395ac9cebcb33dae7f21">value_type</a> = T</td></tr>
<tr class="memdesc:aa9ba9ff5c043395ac9cebcb33dae7f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:aa9ba9ff5c043395ac9cebcb33dae7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7015e71f65550faab67a820744f6bfa1"><td class="memItemLeft" align="right" valign="top"><a id="a7015e71f65550faab67a820744f6bfa1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a7015e71f65550faab67a820744f6bfa1">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a7015e71f65550faab67a820744f6bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the value pointed to by the <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a>. <br /></td></tr>
<tr class="separator:a7015e71f65550faab67a820744f6bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8000c13e9a76ddaae15a8df5344a5ba"><td class="memItemLeft" align="right" valign="top"><a id="ad8000c13e9a76ddaae15a8df5344a5ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#ad8000c13e9a76ddaae15a8df5344a5ba">pointer</a> = <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ad8000c13e9a76ddaae15a8df5344a5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer type. <br /></td></tr>
<tr class="separator:ad8000c13e9a76ddaae15a8df5344a5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22b7f8fa1c18dd36c4a726e3cb25e584"><td class="memItemLeft" align="right" valign="top"><a id="a22b7f8fa1c18dd36c4a726e3cb25e584"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a22b7f8fa1c18dd36c4a726e3cb25e584">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; void &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a22b7f8fa1c18dd36c4a726e3cb25e584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit void specialization of the converting constructor. <br /></td></tr>
<tr class="separator:a22b7f8fa1c18dd36c4a726e3cb25e584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602b7a7c3030bbb04b200e4390676337"><td class="memItemLeft" align="right" valign="top"><a id="a602b7a7c3030bbb04b200e4390676337"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a602b7a7c3030bbb04b200e4390676337">persistent_ptr</a> (<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; const void &gt; const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a602b7a7c3030bbb04b200e4390676337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit const void specialization of the converting constructor. <br /></td></tr>
<tr class="separator:a602b7a7c3030bbb04b200e4390676337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eceeb630b864b49d68bb184c0253331"><td class="memItemLeft" align="right" valign="top"><a id="a6eceeb630b864b49d68bb184c0253331"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a6eceeb630b864b49d68bb184c0253331">operator persistent_ptr&lt; void &gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a6eceeb630b864b49d68bb184c0253331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent pointer to void conversion operator. <br /></td></tr>
<tr class="separator:a6eceeb630b864b49d68bb184c0253331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bb784984c1e92e028d0d568e7db3ae"><td class="memItemLeft" align="right" valign="top"><a id="a55bb784984c1e92e028d0d568e7db3ae"></a>
pmem::detail::sp_dereference&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a55bb784984c1e92e028d0d568e7db3ae">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a55bb784984c1e92e028d0d568e7db3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator. <br /></td></tr>
<tr class="separator:a55bb784984c1e92e028d0d568e7db3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60126ca2fe1952c22d85ba73ea05575a"><td class="memItemLeft" align="right" valign="top"><a id="a60126ca2fe1952c22d85ba73ea05575a"></a>
pmem::detail::sp_member_access&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a60126ca2fe1952c22d85ba73ea05575a">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a60126ca2fe1952c22d85ba73ea05575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access operator. <br /></td></tr>
<tr class="separator:a60126ca2fe1952c22d85ba73ea05575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ab81005cbc26bbb5fd796cacb5f809"><td class="memTemplParams" colspan="2">template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a90ab81005cbc26bbb5fd796cacb5f809"><td class="memTemplItemLeft" align="right" valign="top">pmem::detail::sp_array_access&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a90ab81005cbc26bbb5fd796cacb5f809">operator[]</a> (std::ptrdiff_t i) const noexcept</td></tr>
<tr class="memdesc:a90ab81005cbc26bbb5fd796cacb5f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array access operator.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a90ab81005cbc26bbb5fd796cacb5f809">More...</a><br /></td></tr>
<tr class="separator:a90ab81005cbc26bbb5fd796cacb5f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc70b76fe385715c59d72e12420b6070"><td class="memItemLeft" align="right" valign="top"><a id="abc70b76fe385715c59d72e12420b6070"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#abc70b76fe385715c59d72e12420b6070">operator++</a> ()</td></tr>
<tr class="memdesc:abc70b76fe385715c59d72e12420b6070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator. <br /></td></tr>
<tr class="separator:abc70b76fe385715c59d72e12420b6070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca3c65cd59cda6dbf98a510c5fe242"><td class="memItemLeft" align="right" valign="top"><a id="a52ca3c65cd59cda6dbf98a510c5fe242"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a52ca3c65cd59cda6dbf98a510c5fe242">operator++</a> (int)</td></tr>
<tr class="memdesc:a52ca3c65cd59cda6dbf98a510c5fe242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator. <br /></td></tr>
<tr class="separator:a52ca3c65cd59cda6dbf98a510c5fe242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0a128d4b126684827fa624a4f4d602"><td class="memItemLeft" align="right" valign="top"><a id="a4d0a128d4b126684827fa624a4f4d602"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a4d0a128d4b126684827fa624a4f4d602">operator--</a> ()</td></tr>
<tr class="memdesc:a4d0a128d4b126684827fa624a4f4d602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator. <br /></td></tr>
<tr class="separator:a4d0a128d4b126684827fa624a4f4d602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69b7d64fdfc5d48e6e3110a1cb7f46"><td class="memItemLeft" align="right" valign="top"><a id="a7f69b7d64fdfc5d48e6e3110a1cb7f46"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a7f69b7d64fdfc5d48e6e3110a1cb7f46">operator--</a> (int)</td></tr>
<tr class="memdesc:a7f69b7d64fdfc5d48e6e3110a1cb7f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator. <br /></td></tr>
<tr class="separator:a7f69b7d64fdfc5d48e6e3110a1cb7f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e03767491d6a3d3d7ce5fae7a8bb6c"><td class="memItemLeft" align="right" valign="top"><a id="a57e03767491d6a3d3d7ce5fae7a8bb6c"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a57e03767491d6a3d3d7ce5fae7a8bb6c">operator+=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a57e03767491d6a3d3d7ce5fae7a8bb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator. <br /></td></tr>
<tr class="separator:a57e03767491d6a3d3d7ce5fae7a8bb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc718501518e2bbb567dcc12d501c44"><td class="memItemLeft" align="right" valign="top"><a id="a7cc718501518e2bbb567dcc12d501c44"></a>
<a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a7cc718501518e2bbb567dcc12d501c44">operator-=</a> (std::ptrdiff_t s)</td></tr>
<tr class="memdesc:a7cc718501518e2bbb567dcc12d501c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator. <br /></td></tr>
<tr class="separator:a7cc718501518e2bbb567dcc12d501c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a44b42d2e9466cff96b62d1439b559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a25a44b42d2e9466cff96b62d1439b559">persist</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;pop)</td></tr>
<tr class="memdesc:a25a44b42d2e9466cff96b62d1439b559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persists the content of the underlying object.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a25a44b42d2e9466cff96b62d1439b559">More...</a><br /></td></tr>
<tr class="separator:a25a44b42d2e9466cff96b62d1439b559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199f8eb81d381af36016d5c784780df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a3199f8eb81d381af36016d5c784780df">persist</a> (void)</td></tr>
<tr class="memdesc:a3199f8eb81d381af36016d5c784780df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persists what the persistent pointer points to.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a3199f8eb81d381af36016d5c784780df">More...</a><br /></td></tr>
<tr class="separator:a3199f8eb81d381af36016d5c784780df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3576b7c9381e281518a077ee76e9188e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a3576b7c9381e281518a077ee76e9188e">flush</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;pop)</td></tr>
<tr class="memdesc:a3576b7c9381e281518a077ee76e9188e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes what the persistent pointer points to.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a3576b7c9381e281518a077ee76e9188e">More...</a><br /></td></tr>
<tr class="separator:a3576b7c9381e281518a077ee76e9188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fe3d39a95e1281ba102a3fc51fa1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#a52fe3d39a95e1281ba102a3fc51fa1a3">flush</a> (void)</td></tr>
<tr class="memdesc:a52fe3d39a95e1281ba102a3fc51fa1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes what the persistent pointer points to.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#a52fe3d39a95e1281ba102a3fc51fa1a3">More...</a><br /></td></tr>
<tr class="separator:a52fe3d39a95e1281ba102a3fc51fa1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aff9a32d18e6ccaf34b1c08ca3ddeb473"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html#aff9a32d18e6ccaf34b1c08ca3ddeb473">pointer_to</a> (T &amp;ref)</td></tr>
<tr class="memdesc:aff9a32d18e6ccaf34b1c08ca3ddeb473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a persistent pointer from a given reference.  <a href="classpmem_1_1obj_1_1persistent__ptr.html#aff9a32d18e6ccaf34b1c08ca3ddeb473">More...</a><br /></td></tr>
<tr class="separator:aff9a32d18e6ccaf34b1c08ca3ddeb473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::persistent_ptr&lt; T &gt;</h3>

<p>Persistent pointer class. </p>
<p><a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> implements a smart ptr. It encapsulates the PMEMoid fat pointer and provides member access, dereference and array access operators.</p>
<p>Template parameter type has following requirements:</p><ul>
<li>Is not polymorphic</li>
<li>Has no non-static data members of reference type</li>
<li>Satisfies Destructible requirement: <a href="https://en.cppreference.com/w/cpp/named_req/Destructible">https://en.cppreference.com/w/cpp/named_req/Destructible</a></li>
<li>All non-static data members and base classes follows the same requirements</li>
</ul>
<p>Even if all of the above requirements are met, type representation may vary depending on ABI and compiler optimizations (as stated in [class.mem]: "the order of allocation of non-static data members with different access control is unspecified"). To enforce the same layout for all ABIs and optimization levels type should satisfy StandardLayoutType requirement.</p>
<p>If <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> is used with array type, additional requirement is:</p><ul>
<li>Element type must be default constructible</li>
</ul>
<p>The <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> is not designed to work with polymorphic types, as they have runtime RTTI info embedded, which is implementation specific and thus not consistently rebuildable. Such constructs as polymorphic members or members of a union defined within a class held in a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> will also yield undefined behavior.</p>
<p>C++ standard states that lifetime of an object is a runtime property [basic.lifetime]. Conditions which must be fulfilled for object's lifetime to begin, imply that using any non-trivially constructible object with <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> is undefined behaviour. This is being partially addressed by the following proposal: <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/bk8esqk-Qoo</a></p>
<p>Another caveat is that snapshotting elements in a transaction and performing rollback uses memcpy internally. Using memcpy on an object in C++ is allowed by the standard only if the type satisfies TriviallyCopyable requirement.</p>
<p>This type does NOT manage the life-cycle of the object. The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>pmem::obj;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">persistent_ptr_example()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>compound_type {</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span></div>
<div class="line">        set_some_variable(<span class="keywordtype">int</span> val)</div>
<div class="line">        {</div>
<div class="line">            some_variable = val;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> some_variable;</div>
<div class="line">        <span class="keywordtype">double</span> some_other_variable;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// pool root structure</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;compound_type&gt;</a> comp;</div>
<div class="line">    } proot;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a pmemobj pool</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// typical usage schemes</span></div>
<div class="line">    <a class="code" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">transaction::run</a>(pop, [&amp;] {</div>
<div class="line">        proot.comp = make_persistent&lt;compound_type&gt;(); <span class="comment">// allocation</span></div>
<div class="line">        proot.comp-&gt;set_some_variable(12);       <span class="comment">// call function</span></div>
<div class="line">        proot.comp-&gt;some_other_variable = 2.3;   <span class="comment">// set variable</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// reading from the persistent_ptr</span></div>
<div class="line">    compound_type tmp = *proot.comp;</div>
<div class="line">    (void)tmp;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Changing a persistent_ptr&lt;&gt; variable outside of a transaction is a</span></div>
<div class="line">    <span class="comment">// volatile modification. No way to ensure persistence in case of power</span></div>
<div class="line">    <span class="comment">// failure.</span></div>
<div class="line">    proot.comp-&gt;some_variable = 12;</div>
<div class="line">}</div>
</div><!-- fragment --></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3576b7c9381e281518a077ee76e9188e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3576b7c9381e281518a077ee76e9188e">&#9670;&nbsp;</a></span>flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes what the persistent pointer points to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pop</td><td>Pmemobj pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52fe3d39a95e1281ba102a3fc51fa1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fe3d39a95e1281ba102a3fc51fa1a3">&#9670;&nbsp;</a></span>flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes what the persistent pointer points to. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>when cannot get pool from persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ab81005cbc26bbb5fd796cacb5f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ab81005cbc26bbb5fd796cacb5f809">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename  = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::detail::sp_array_access&lt;T&gt;::type <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array access operator. </p>
<p>Contains run-time bounds checking for static arrays. </p>

</div>
</div>
<a id="a25a44b42d2e9466cff96b62d1439b559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a44b42d2e9466cff96b62d1439b559">&#9670;&nbsp;</a></span>persist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::persist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Persists the content of the underlying object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pop</td><td>Pmemobj pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3199f8eb81d381af36016d5c784780df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3199f8eb81d381af36016d5c784780df">&#9670;&nbsp;</a></span>persist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::persist </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Persists what the persistent pointer points to. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class.">pool_error</a></td><td>when cannot get pool from persistent pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff9a32d18e6ccaf34b1c08ca3ddeb473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9a32d18e6ccaf34b1c08ca3ddeb473">&#9670;&nbsp;</a></span>pointer_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr</a>&lt;T&gt; <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a>&lt; T &gt;::pointer_to </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a persistent pointer from a given reference. </p>
<p>This can create a <a class="el" href="classpmem_1_1obj_1_1persistent__ptr.html" title="Persistent pointer class.">persistent_ptr</a> to a volatile object, use with extreme caution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>reference to an object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libpmemobj++/detail/<a class="el" href="common_8hpp_source.html">common.hpp</a></li>
<li>libpmemobj++/<a class="el" href="persistent__ptr_8hpp_source.html">persistent_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:646</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">Persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1transaction_html_aae32a7ede01bfcf20672433263267387"><div class="ttname"><a href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">pmem::obj::transaction::run</a></div><div class="ttdeci">static void run(pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:403</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr_html"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a></div><div class="ttdoc">Persistent pointer class.</div><div class="ttdef"><b>Definition:</b> persistent_ptr.hpp:132</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
