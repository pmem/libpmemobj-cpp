<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::transaction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.8.1</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepmem.html">pmem</a></li><li class="navelem"><b>obj</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1transaction.html">transaction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1transaction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::transaction Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ transaction handler class.  
 <a href="classpmem_1_1obj_1_1transaction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transaction_8hpp_source.html">libpmemobj++/transaction.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction_1_1automatic.html">automatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ automatic scope transaction class.  <a href="classpmem_1_1obj_1_1transaction_1_1automatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction_1_1manual.html">manual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ manual scope transaction class.  <a href="classpmem_1_1obj_1_1transaction_1_1manual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78ab1cc9876472a0f0fcf96d6a0d16d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a78ab1cc9876472a0f0fcf96d6a0d16d0">~transaction</a> () noexcept=delete</td></tr>
<tr class="memdesc:a78ab1cc9876472a0f0fcf96d6a0d16d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classpmem_1_1obj_1_1transaction.html#a78ab1cc9876472a0f0fcf96d6a0d16d0">More...</a><br /></td></tr>
<tr class="separator:a78ab1cc9876472a0f0fcf96d6a0d16d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4ff5a4362ea2a82830c7ca06a4358e05"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a4ff5a4362ea2a82830c7ca06a4358e05">abort</a> (int err)</td></tr>
<tr class="memdesc:a4ff5a4362ea2a82830c7ca06a4358e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually abort the current transaction.  <a href="classpmem_1_1obj_1_1transaction.html#a4ff5a4362ea2a82830c7ca06a4358e05">More...</a><br /></td></tr>
<tr class="separator:a4ff5a4362ea2a82830c7ca06a4358e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378c803f81ae0f6756fe9e9ab21ec1c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a378c803f81ae0f6756fe9e9ab21ec1c9">commit</a> ()</td></tr>
<tr class="memdesc:a378c803f81ae0f6756fe9e9ab21ec1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually commit a transaction.  <a href="classpmem_1_1obj_1_1transaction.html#a378c803f81ae0f6756fe9e9ab21ec1c9">More...</a><br /></td></tr>
<tr class="separator:a378c803f81ae0f6756fe9e9ab21ec1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae32a7ede01bfcf20672433263267387"><td class="memTemplParams" colspan="2">template&lt;typename... Locks&gt; </td></tr>
<tr class="memitem:aae32a7ede01bfcf20672433263267387"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">run</a> (<a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;<a class="el" href="classpmem_1_1obj_1_1pool.html">pool</a>, std::function&lt; void()&gt; tx, Locks &amp;... locks)</td></tr>
<tr class="memdesc:aae32a7ede01bfcf20672433263267387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a closure-like transaction and lock <code>locks</code>.  <a href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">More...</a><br /></td></tr>
<tr class="separator:aae32a7ede01bfcf20672433263267387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ac1809dae102c7ef8a84196d94862"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; LIBPMEMOBJ_CPP_IS_TRIVIALLY_COPYABLE(T), T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a723ac1809dae102c7ef8a84196d94862"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#a723ac1809dae102c7ef8a84196d94862">snapshot</a> (const T *addr, size_t num=1)</td></tr>
<tr class="memdesc:a723ac1809dae102c7ef8a84196d94862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a “snapshot” of given elements of type T number (1 by default), located at the given address ptr in the virtual memory space and saves it to the undo log.  <a href="classpmem_1_1obj_1_1transaction.html#a723ac1809dae102c7ef8a84196d94862">More...</a><br /></td></tr>
<tr class="separator:a723ac1809dae102c7ef8a84196d94862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="memTemplParams" colspan="2">template&lt;typename L , typename... Locks&gt; </td></tr>
<tr class="memitem:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#aa5a605fedbe2a633f2921c2d0e9ccdde">add_lock</a> (L &amp;lock, Locks &amp;... locks) noexcept</td></tr>
<tr class="memdesc:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively add locks to the active transaction.  <a href="classpmem_1_1obj_1_1transaction.html#aa5a605fedbe2a633f2921c2d0e9ccdde">More...</a><br /></td></tr>
<tr class="separator:aa5a605fedbe2a633f2921c2d0e9ccdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b9ef6f5a49231fd2d9ccadc66fa132"><td class="memItemLeft" align="right" valign="top"><a id="af1b9ef6f5a49231fd2d9ccadc66fa132"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1transaction.html#af1b9ef6f5a49231fd2d9ccadc66fa132">add_lock</a> () noexcept</td></tr>
<tr class="memdesc:af1b9ef6f5a49231fd2d9ccadc66fa132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method ending the recursive algorithm. <br /></td></tr>
<tr class="separator:af1b9ef6f5a49231fd2d9ccadc66fa132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ transaction handler class. </p>
<p>This class is the pmemobj transaction handler. Scoped transactions are handled through two internal classes: <a class="el" href="classpmem_1_1obj_1_1transaction_1_1manual.html">manual</a> and <a class="el" href="classpmem_1_1obj_1_1transaction_1_1automatic.html">automatic</a>.</p><ul>
<li><a class="el" href="classpmem_1_1obj_1_1transaction_1_1manual.html">manual</a> transactions need to be committed manually, otherwise they will be aborted on object destruction.<br  />
</li>
<li><a class="el" href="classpmem_1_1obj_1_1transaction_1_1automatic.html">automatic</a> transactions are only available in C++17. They handle transaction commit/abort automatically.</li>
</ul>
<p>This class also exposes a closure-like transaction API, which is the preferred way of handling transactions.</p>
<p>The typical usage example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="make__persistent_8hpp.html">libpmemobj++/make_persistent.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mutex_8hpp.html">libpmemobj++/mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="persistent__ptr_8hpp.html">libpmemobj++/persistent_ptr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pext_8hpp.html">libpmemobj++/pext.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pool_8hpp.html">libpmemobj++/pool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__mutex_8hpp.html">libpmemobj++/shared_mutex.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transaction_8hpp.html">libpmemobj++/transaction.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>pmem::obj;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">general_tx_example()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// pool root structure</span></div>
<div class="line">    <span class="keyword">struct </span>root {</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1mutex.html">mutex</a> pmutex;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1shared__mutex.html">shared_mutex</a> shared_pmutex;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1p.html">p&lt;int&gt;</a> count;</div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1persistent__ptr.html">persistent_ptr&lt;root&gt;</a> another_root;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a pmemobj pool</span></div>
<div class="line">    <span class="keyword">auto</span> pop = <a class="code" href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pool&lt;root&gt;::create</a>(<span class="stringliteral">&quot;poolfile&quot;</span>, <span class="stringliteral">&quot;layout&quot;</span>, PMEMOBJ_MIN_POOL);</div>
<div class="line">    <span class="keyword">auto</span> proot = pop.root();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// typical usage schemes</span></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// take locks and start a transaction</span></div>
<div class="line">        <a class="code" href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">transaction::run</a>(</div>
<div class="line">            pop,</div>
<div class="line">            [&amp;]() {</div>
<div class="line">                <span class="comment">// atomically allocate objects</span></div>
<div class="line">                proot-&gt;another_root = make_persistent&lt;root&gt;();</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// atomically modify objects</span></div>
<div class="line">                proot-&gt;count++;</div>
<div class="line">            },</div>
<div class="line">            proot-&gt;pmutex, proot-&gt;shared_pmutex);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="classpmem_1_1transaction__error.html">pmem::transaction_error</a> &amp;) {</div>
<div class="line">        <span class="comment">// a transaction error occurred, transaction got aborted</span></div>
<div class="line">        <span class="comment">// reacquire locks if necessary</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">// some other exception got propagated from within the tx</span></div>
<div class="line">        <span class="comment">// reacquire locks if necessary</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a78ab1cc9876472a0f0fcf96d6a0d16d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab1cc9876472a0f0fcf96d6a0d16d0">&#9670;&nbsp;</a></span>~transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pmem::obj::transaction::~transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>End pmemobj transaction. If the transaction has not been committed before object destruction, an abort will be issued. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ff5a4362ea2a82830c7ca06a4358e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff5a4362ea2a82830c7ca06a4358e05">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually abort the current transaction. </p>
<p>If called within an inner transaction, the outer transactions will also be aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>the error to be reported as the reason of the abort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>if the transaction is in an invalid state. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class.">manual_tx_abort</a></td><td>this exception is thrown to signify a transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5a605fedbe2a633f2921c2d0e9ccdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a605fedbe2a633f2921c2d0e9ccdde">&#9670;&nbsp;</a></span>add_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pmem::obj::transaction::add_lock </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively add locks to the active transaction. </p>
<p>The locks are taken in the provided order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>the lock to add. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>the rest of the locks to be added to the active transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number if adding any of the locks failed, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a378c803f81ae0f6756fe9e9ab21ec1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378c803f81ae0f6756fe9e9ab21ec1c9">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually commit a transaction. </p>
<p>It is the sole responsibility of the caller, that after the call to <a class="el" href="classpmem_1_1obj_1_1transaction.html#a378c803f81ae0f6756fe9e9ab21ec1c9" title="Manually commit a transaction.">transaction::commit()</a> no other operations are done within the transaction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>on any errors with ending the transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae32a7ede01bfcf20672433263267387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae32a7ede01bfcf20672433263267387">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Locks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Locks &amp;...&#160;</td>
          <td class="paramname"><em>locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a closure-like transaction and lock <code>locks</code>. </p>
<p>The locks have to be persistent memory resident locks. An attempt to lock the locks will be made. If any of the specified locks is already locked, the method will block. The locks are held until the end of the transaction. The transaction does not have to be committed manually. Manual aborts will end the transaction with an active exception.</p>
<p>If an exception is thrown within the transaction, it gets aborted and the exception is rethrown. Therefore extra care has to be taken with proper error handling.</p>
<p>The locks are held for the entire duration of the transaction. They are released at the end of the scope, so within the <code>catch</code> block, they are already unlocked. If the cleanup action requires access to data within a critical section, the locks have to be manually acquired once again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>the pool in which the transaction will take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx</td><td>an std::function&lt;void ()&gt; which will perform operations within this transaction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locks</td><td>locks to be taken for the duration of the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>on any error pertaining the execution of the transaction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1manual__tx__abort.html" title="Custom transaction error class.">manual_tx_abort</a></td><td>on manual transaction abort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723ac1809dae102c7ef8a84196d94862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723ac1809dae102c7ef8a84196d94862">&#9670;&nbsp;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; LIBPMEMOBJ_CPP_IS_TRIVIALLY_COPYABLE(T), T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pmem::obj::transaction::snapshot </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a “snapshot” of given elements of type T number (1 by default), located at the given address ptr in the virtual memory space and saves it to the undo log. </p>
<p>The application is then free to directly modify the object in that memory range. In case of a failure or abort, all the changes within this range will be rolled back. The supplied block of memory has to be within the pool registered in the transaction. This function must be called during transaction. This overload only participates in overload resolution of function template if T satisfies requirements of LIBPMEMOBJ_CPP_IS_TRIVIALLY_COPYABLE macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>pointer to the first object to be snapshotted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of elements to be snapshotted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must be called during transaction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class.">transaction_error</a></td><td>when snapshotting failed or if function wasn't called during transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/<a class="el" href="transaction_8hpp_source.html">transaction.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasspmem_1_1obj_1_1mutex_html"><div class="ttname"><a href="classpmem_1_1obj_1_1mutex.html">pmem::obj::mutex</a></div><div class="ttdoc">Persistent memory resident mutex implementation.</div><div class="ttdef"><b>Definition:</b> mutex.hpp:60</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1pool_html_a8c7a780cfb3bc6c708856783938a9e8c"><div class="ttname"><a href="classpmem_1_1obj_1_1pool.html#a8c7a780cfb3bc6c708856783938a9e8c">pmem::obj::pool::create</a></div><div class="ttdeci">static pool&lt; T &gt; create(const std::string &amp;path, const std::string &amp;layout, std::size_t size=PMEMOBJ_MIN_POOL, mode_t mode=DEFAULT_MODE)</div><div class="ttdoc">Creates a new transactional object store pool.</div><div class="ttdef"><b>Definition:</b> pool.hpp:646</div></div>
<div class="ttc" id="aclasspmem_1_1transaction__error_html"><div class="ttname"><a href="classpmem_1_1transaction__error.html">pmem::transaction_error</a></div><div class="ttdoc">Custom transaction error class.</div><div class="ttdef"><b>Definition:</b> pexceptions.hpp:90</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1p_html"><div class="ttname"><a href="classpmem_1_1obj_1_1p.html">pmem::obj::p</a></div><div class="ttdoc">Resides on pmem class.</div><div class="ttdef"><b>Definition:</b> p.hpp:64</div></div>
<div class="ttc" id="apool_8hpp_html"><div class="ttname"><a href="pool_8hpp.html">pool.hpp</a></div><div class="ttdoc">C++ pmemobj pool.</div></div>
<div class="ttc" id="amake__persistent_8hpp_html"><div class="ttname"><a href="make__persistent_8hpp.html">make_persistent.hpp</a></div><div class="ttdoc">Persistent_ptr transactional allocation functions for objects.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1transaction_html_aae32a7ede01bfcf20672433263267387"><div class="ttname"><a href="classpmem_1_1obj_1_1transaction.html#aae32a7ede01bfcf20672433263267387">pmem::obj::transaction::run</a></div><div class="ttdeci">static void run(pool_base &amp;pool, std::function&lt; void()&gt; tx, Locks &amp;... locks)</div><div class="ttdoc">Execute a closure-like transaction and lock locks.</div><div class="ttdef"><b>Definition:</b> transaction.hpp:403</div></div>
<div class="ttc" id="atransaction_8hpp_html"><div class="ttname"><a href="transaction_8hpp.html">transaction.hpp</a></div><div class="ttdoc">C++ pmemobj transactions.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1persistent__ptr_html"><div class="ttname"><a href="classpmem_1_1obj_1_1persistent__ptr.html">pmem::obj::persistent_ptr</a></div><div class="ttdoc">Persistent pointer class.</div><div class="ttdef"><b>Definition:</b> persistent_ptr.hpp:132</div></div>
<div class="ttc" id="ashared__mutex_8hpp_html"><div class="ttname"><a href="shared__mutex_8hpp.html">shared_mutex.hpp</a></div><div class="ttdoc">Pmem-resident shared mutex.</div></div>
<div class="ttc" id="apext_8hpp_html"><div class="ttname"><a href="pext_8hpp.html">pext.hpp</a></div><div class="ttdoc">Convenience extensions for the resides on pmem property template.</div></div>
<div class="ttc" id="apersistent__ptr_8hpp_html"><div class="ttname"><a href="persistent__ptr_8hpp.html">persistent_ptr.hpp</a></div><div class="ttdoc">Persistent smart pointer.</div></div>
<div class="ttc" id="aclasspmem_1_1obj_1_1shared__mutex_html"><div class="ttname"><a href="classpmem_1_1obj_1_1shared__mutex.html">pmem::obj::shared_mutex</a></div><div class="ttdoc">Persistent memory resident shared_mutex implementation.</div><div class="ttdef"><b>Definition:</b> shared_mutex.hpp:59</div></div>
<div class="ttc" id="amutex_8hpp_html"><div class="ttname"><a href="mutex_8hpp.html">mutex.hpp</a></div><div class="ttdoc">Pmem-resident mutex.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
